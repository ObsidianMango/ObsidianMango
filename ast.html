<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Spinning Globe with Asteroid Simulation</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
    #simulate {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 1;
      padding: 10px 20px;
      font-size: 16px;
    }
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
      "three/examples/jsm/": "https://unpkg.com/three@0.128.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <button id="simulate">Simulate Asteroid Impact</button>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
    
    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 7); // zoomed out a bit
    
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);
    
    // Ambient Light
    const ambientLight = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambientLight);
    
    // Texture Loader: using your hosted NASA image
    const textureLoader = new THREE.TextureLoader();
    const earthTexture = textureLoader.load('land_ocean_ice_2048.jpeg');
    
    // Globe Geometry: radius 2, 64 segments for width and height (for smooth texturing)
    const sphereGeometry = new THREE.SphereGeometry(2, 64, 64);
    const sphereMaterial = new THREE.MeshStandardMaterial({ map: earthTexture });
    const globe = new THREE.Mesh(sphereGeometry, sphereMaterial);
    scene.add(globe);
    
    // Orbit Controls for interactivity
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    
    // Simulate Asteroid Impact Function
    function simulateImpact() {
      // 1 in 43 chance
      if (Math.random() < 1/43) {
        console.log("Asteroid impact detected!");
        // Divide Earth into 64 equal segments (8 lat x 8 lon)
        const segments = 8;
        const latIndex = Math.floor(Math.random() * segments);
        const lonIndex = Math.floor(Math.random() * segments);
        const theta = (latIndex + 0.5) * (Math.PI / segments);      // polar angle [0, PI]
        const phi = (lonIndex + 0.5) * ((2 * Math.PI) / segments);    // azimuth angle [0, 2PI]
        const r = 2; // globe radius
        
        const hitX = r * Math.sin(theta) * Math.cos(phi);
        const hitY = r * Math.cos(theta);
        const hitZ = r * Math.sin(theta) * Math.sin(phi);
        const hitPoint = new THREE.Vector3(hitX, hitY, hitZ);
        
        // Create a red circle marker at the hit point
        const circleGeometry = new THREE.CircleGeometry(0.2, 32);
        const circleMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, side: THREE.DoubleSide });
        const marker = new THREE.Mesh(circleGeometry, circleMaterial);
        marker.position.copy(hitPoint);
        // Orient the marker so it lies tangent to the sphere surface
        marker.lookAt(hitPoint.clone().multiplyScalar(2));
        scene.add(marker);
        
        // Animate the marker (pulsate)
        let scaleDirection = 1;
        function animateMarker() {
          marker.scale.x += scaleDirection * 0.005;
          marker.scale.y += scaleDirection * 0.005;
          if (marker.scale.x > 1.5 || marker.scale.x < 1) {
            scaleDirection *= -1;
          }
          requestAnimationFrame(animateMarker);
        }
        animateMarker();
        
        console.log("Asteroid hit at segment (lat index, lon index):", latIndex, lonIndex);
      } else {
        console.log("No asteroid hit.");
      }
    }
    
    document.getElementById('simulate').addEventListener('click', simulateImpact);
    
    // Responsive resizing
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // Animation Loop: Globe rotation
    function animate() {
      requestAnimationFrame(animate);
      globe.rotation.y += 0.002;
      controls.update();
      renderer.render(scene, camera);
    }
    
    animate();
  </script>
</body>
</html>
