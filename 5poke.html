<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>ðŸ”¥ Texas Holdâ€™em â€” One-Page Poker (SB $0.25 / BB $0.50)</title>
<style>
  :root{
    --bg:#07090d; --ink:#eaf7ff; --muted:#97a7b7;
    --felt:#072b24; --felt2:#0a3c31; --rim:#10473b;
    --neon:#39ffb6; --neon2:#6ac8ff; --warn:#ffcf5a; --bad:#ff6b6b; --good:#2ecc71; --btn:#0e1724;
    --card:#0c1822; --cardEdge:#143041;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:
      radial-gradient(1200px 600px at 50% -300px, rgba(72,170,255,.08),transparent 60%),
      radial-gradient(1000px 600px at 50% 120%, rgba(57,255,182,.08),transparent 60%),
      linear-gradient(180deg,#04060a,#090f14 40%,#06090e);
    color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Inter,Roboto,Arial,sans-serif}
  a{color:var(--neon2)}
  .wrap{max-width:1050px;margin-inline:auto;padding:14px 12px 140px}
  header{display:flex;align-items:center;gap:10px;justify-content:space-between;margin:8px 0 12px}
  h1{margin:0;font-size:20px;letter-spacing:.5px}
  .topbar{display:flex;gap:8px;flex-wrap:wrap}
  .chip, .pill, .pot{
    display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;
    background:linear-gradient(180deg,#101a22,#0a1219);color:#dff7ff;border:1px solid #1f2f3d;font-weight:700;font-size:14px
  }
  .pill{color:#bfeaff;background:linear-gradient(180deg,#0a1520,#071018);border-color:#213446}
  .pot{box-shadow:0 0 24px -6px var(--neon);border-color:#1a3d34}
  .table{
    position:relative;border:2px solid var(--rim);border-radius:20px;padding:14px;overflow:hidden;
    background:
      radial-gradient(900px 420px at 50% -360px, rgba(255,255,255,.07), transparent 60%),
      radial-gradient(1000px 420px at 50% 120%, rgba(255,255,255,.07), transparent 60%),
      conic-gradient(from 90deg at 50% 50%, var(--felt) 0 25%, var(--felt2) 0 50%, var(--felt) 0 75%, var(--felt2) 0 100%);
  }
  .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center}
  .center{justify-content:center}
  .between{justify-content:space-between}
  .players{display:grid;grid-template-columns:repeat(auto-fit,minmax(170px,1fr));gap:12px;margin-top:12px}
  .seat{
    background:linear-gradient(180deg,#0b1218,#091117);border:1px solid #172532;border-radius:14px;padding:10px;min-height:150px;position:relative
  }
  .seat.me{outline:2px solid #2b8f76; box-shadow:0 0 0 2px #000 inset}
  .name{font-weight:900;font-size:14px;margin:0 0 2px}
  .stack{font-size:12px;color:var(--muted)}
  .status{font-size:12px;color:#b8cad8;min-height:16px;margin-top:2px}
  .dealer{position:absolute;right:8px;top:8px;background:#fff;color:#000;font-weight:900;border-radius:999px;padding:2px 7px;font-size:12px}
  .blind{position:absolute;right:8px;top:30px;background:var(--warn);color:#000;border-radius:8px;padding:1px 6px;font-size:11px;font-weight:900}
  .cards{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .card{
    width:46px;height:64px;border-radius:10px;background:linear-gradient(180deg,var(--card),#08121a);
    border:1px solid var(--cardEdge);display:grid;place-items:center;font-weight:900;font-family:ui-monospace,Menlo,Consolas,monospace;
    color:#cfe9ff; position:relative; user-select:none; letter-spacing:.5px; box-shadow:0 2px 12px #000a
  }
  .card.red{color:#ffd9d9}
  .card.faceup{background:linear-gradient(180deg,#0e1e2b,#0b1722)}
  .card.ghost{opacity:.4}
  .board{display:flex;gap:10px;justify-content:center;margin:10px auto}
  .glow{box-shadow:0 0 22px -6px var(--neon)}
  .log{max-height:170px;overflow:auto;padding:10px;background:#0a1117;border:1px solid #182532;border-radius:10px;font-size:13px;margin-top:12px}
  .btn{
    appearance:none;border:0;border-radius:12px;padding:14px 16px;background:linear-gradient(180deg,#132033,#0b1624);
    color:#eaf7ff;font-weight:900;font-size:16px;box-shadow:0 1px 0 #0008, inset 0 -2px 0 #0007; touch-action:manipulation
  }
  .btn:disabled{opacity:.45}
  .btn.good{background:linear-gradient(180deg,#1e6e44,#0f4d2f)}
  .btn.warn{background:linear-gradient(180deg,#7a5417,#4c3713)}
  .btn.danger{background:linear-gradient(180deg,#7a1e1e,#4a0f0f)}
  .btn.alt{background:linear-gradient(180deg,#17314b,#0c2034)}
  .sel{
    appearance:none;background:#13202b;color:#e9f2ef;border:1px solid #264155;border-radius:10px;padding:10px 12px;font-weight:800;min-height:44px
  }

  .hud{
    position:sticky;bottom:0;left:0;right:0;background:
      linear-gradient(180deg,#0b0f15,#070a0f);
    padding:12px;border-top:1px solid #152230;box-shadow:0 -24px 48px #000a
  }
  .hud .row{justify-content:space-between;gap:8px}
  .bet-controls{display:flex;gap:8px;flex-wrap:wrap}
  input[type=range]{width:220px}
  .chipline{display:flex;gap:8px;flex-wrap:wrap}
  .tag{font-size:11px;padding:2px 8px;border-radius:999px;background:#0e1b24;border:1px solid #143043;color:#bfeaff;font-weight:800}
  .sm{font-size:12px}
  .xs{font-size:11px}

  /* Card suit icons (tiny) */
  .suit{position:absolute;left:6px;top:4px;font-size:12px;opacity:.9}
  .rank{font-size:16px}

  /* iPhone touch targets */
  .btn, .sel {min-height:48px}

  @media (min-width:800px){
    .board .card{width:56px;height:78px;font-size:18px}
    .card{width:52px;height:72px}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>ðŸ”¥ Texas Holdâ€™em â€” Neon Table</h1>
    <div class="topbar">
      <span class="chip">Stacks start: $50</span>
      <span class="chip">Blinds: <strong>$0.25/$0.50</strong></span>
      <select id="playerCount" class="sel" title="Players">
        <option value="3">3 players</option>
        <option value="4" selected>4 players</option>
        <option value="5">5 players</option>
      </select>
      <button class="btn alt" id="newGameBtn">New Game</button>
    </div>
  </header>

  <div class="table glow">
    <div class="row center" style="margin-bottom:10px">
      <div class="pot">Pot: $<span id="pot">0.00</span></div>
      <span class="pill" id="phasePill">â€”</span>
      <span class="pill xs" id="toActPill">â€”</span>
    </div>

    <div class="board" id="board">
      <!-- community cards -->
    </div>

    <div id="players" class="players"></div>

    <div class="log" id="log" aria-live="polite"></div>
  </div>
</div>

<!-- HUD -->
<div class="hud" id="hud">
  <div class="row">
    <div class="bet-controls">
      <button class="btn danger" id="foldBtn">Fold</button>
      <button class="btn" id="checkCallBtn">Check / Call</button>
      <button class="btn good" id="betRaiseBtn">Bet / Raise</button>
      <input type="range" id="betSlider" min="0.5" max="10" step="0.5" value="0.5" />
      <span class="chip">Bet: $<span id="betVal">0.50</span></span>
      <button class="btn warn" id="allInBtn">All-in</button>
    </div>
    <div class="chipline">
      <span class="tag" id="handTag">â€”</span>
    </div>
  </div>
</div>

<script>
/* =========================
   CONFIG
========================= */
const SB = 0.25, BB = 0.50, START_STACK = 50;
const STREETS = ["preflop","flop","turn","river","showdown"];
let G = null;

/* =========================
   DECK + UTIL
========================= */
function newDeck(){
  const ranks = ["2","3","4","5","6","7","8","9","T","J","Q","K","A"];
  const suits = ["â™£","â™¦","â™¥","â™ "];
  const deck=[];
  for(const r of ranks) for(const s of suits) deck.push(r+s);
  for(let i=deck.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1)); [deck[i],deck[j]]=[deck[j],deck[i]];}
  return deck;
}
function rv(r){return "23456789TJQKA".indexOf(r);}
function cardColor(c){return (c.includes("â™¦")||c.includes("â™¥")) ? "red" : ""}
function roundCash(x){ return Math.round(x*100)/100; }
function log(s){ const el=document.getElementById('log'); const d=document.createElement('div'); d.textContent=s; el.appendChild(d); el.scrollTop=el.scrollHeight; }

/* =========================
   EVALUATION (5-card)
   returns [rank, kickers...]
========================= */
function evaluate5(cards){
  const rs = cards.map(c=>c[0]).sort((a,b)=>rv(b)-rv(a));
  const ss = cards.map(c=>c[1]);
  const counts={}; rs.forEach(r=>counts[r]=(counts[r]||0)+1);
  const groups = Object.entries(counts).sort((a,b)=>{
    if(b[1]!==a[1]) return b[1]-a[1];
    return rv(b[0]) - rv(a[0]);
  });
  const isFlush = ss.every(s=>s===ss[0]);
  // Straight with wheel
  let vals = rs.map(rv);
  const uniq=[...new Set(vals)];
  let straightHigh=-1;
  const a=uniq.slice().sort((x,y)=>y-x);
  if(uniq.length>=5){
    // normal
    for(let i=0;i<=uniq.length-5;i++){
      if(a[i]-a[i+4]===4){ straightHigh=a[i]; break; }
    }
    // wheel A-2-3-4-5
    const wheel = [12,3,2,1,0].every(v=>uniq.includes(v));
    if(wheel) straightHigh=Math.max(straightHigh,3);
  }
  const isStraight = straightHigh>=0;

  if(isStraight && isFlush) return [8, straightHigh];
  if(groups[0][1]===4){ // quads
    return [7, rv(groups[0][0]), rv(groups[1][0])];
  }
  if(groups[0][1]===3 && groups[1][1]===2){
    return [6, rv(groups[0][0]), rv(groups[1][0])];
  }
  if(isFlush) return [5, ...rs.map(rv)];
  if(isStraight) return [4, straightHigh];
  if(groups[0][1]===3){
    const kick = rs.filter(r=>r!==groups[0][0]).map(rv);
    return [3, rv(groups[0][0]), ...kick];
  }
  if(groups[0][1]===2 && groups[1][1]===2){
    return [2, rv(groups[0][0]), rv(groups[1][0]), rv(groups[2][0])];
  }
  if(groups[0][1]===2){
    const kick = rs.filter(r=>r!==groups[0][0]).map(rv);
    return [1, rv(groups[0][0]), ...kick];
  }
  return [0, ...rs.map(rv)];
}
function cmp(a,b){
  for(let i=0;i<Math.max(a.length,b.length);i++){
    const x=a[i]??-1, y=b[i]??-1;
    if(x>y) return 1; if(x<y) return -1;
  }
  return 0;
}
// Best hand out of 7 (2 hole + up to 5 board)
function bestOf7(hole, board){
  const cards = [...hole, ...board];
  let best=null;
  for(let i=0;i<cards.length;i++){
    for(let j=i+1;j<cards.length;j++){
      for(let k=j+1;k<cards.length;k++){
        for(let l=k+1;l<cards.length;l++){
          for(let m=l+1;m<cards.length;m++){
            const pick=[cards[i],cards[j],cards[k],cards[l],cards[m]];
            const sc=evaluate5(pick);
            if(!best || cmp(sc,best)<0) best=sc; // keep max later
            else if(cmp(sc,best)>0) best=sc;
          }
        }
      }
    }
  }
  return best;
}
function handLabel(score){
  const labels=["High Card","Pair","Two Pair","Three of a Kind","Straight","Flush","Full House","Four of a Kind","Straight Flush"];
  return labels[score[0]];
}

/* =========================
   GAME SETUP
========================= */
function newGame(count=4){
  const players=[];
  for(let i=0;i<count;i++){
    players.push({
      id:i, name: i===0?"You":"CPU "+i, stack:START_STACK, hole:[], folded:false, allin:false,
      toAct:false, status:"", bet:0, dealer:false, blindTag:"", contributed:0, inHand:true, isMe:i===0
    });
  }
  G = {
    deck:newDeck(),
    players,
    pot:0,
    board:[],
    dealer:0,
    street:"preflop",
    currentBet:0,
    minRaise:BB,
    toActIdx:0,
    handNo:0,
  };
  startHand();
}
function startHand(){
  G.handNo++;
  G.pot=0; G.board=[]; G.street="preflop"; G.currentBet=0; G.minRaise=BB;
  G.players.forEach((p,i)=>{
    p.hole=[]; p.folded=false; p.allin=false; p.bet=0; p.contributed=0; p.inHand=true; p.status=""; p.dealer=(i===G.dealer); p.blindTag="";
  });
  G.deck=newDeck();

  // deal 2
  for(let r=0;r<2;r++){ for(const p of G.players){ p.hole.push(G.deck.pop()); } }

  // blinds
  const sbIdx = (G.dealer+1)%G.players.length;
  const bbIdx = (G.dealer+2)%G.players.length;
  postBlind(G.players[sbIdx], SB, "SB");
  postBlind(G.players[bbIdx], BB, "BB");
  G.currentBet = Math.min(BB, G.players[bbIdx].bet);

  // action starts UTG (left of BB)
  G.toActIdx = (bbIdx+1)%G.players.length;
  setActing(G.toActIdx);
  updateUI();
  if(!G.players[G.toActIdx].isMe) setTimeout(cpuAct, 500);
}
function nextDealer(){ G.dealer=(G.dealer+1)%G.players.length; }
function postBlind(p, amt, label){
  const pay=Math.min(amt, p.stack);
  p.stack-=pay; p.bet+=pay; p.contributed+=pay; G.pot+=pay; p.blindTag=label;
  log(`${p.name} posts ${label} $${pay.toFixed(2)}`);
}
function alivePlayers(){ return G.players.filter(p=>!p.folded && p.inHand); }
function nextIdxFrom(i){
  const n=G.players.length;
  for(let step=1;step<=n;step++){
    const j=(i+step)%n;
    const pj=G.players[j];
    if(pj.inHand && !pj.folded && !pj.allin) return j;
  }
  return i;
}
function allBetsClosed(){
  const active=G.players.filter(p=>p.inHand && !p.folded);
  const target=Math.max(...active.map(p=>p.bet));
  return active.every(p=>p.bet===target || p.allin);
}
function collectBets(){
  for(const p of G.players){ G.pot+=p.bet; p.bet=0; }
  G.currentBet=0;
}

/* =========================
   STREET ADVANCE
========================= */
function moveStreet(next){
  G.street=next;
  document.getElementById('phasePill').textContent = streetDisplay(next);
}
function streetDisplay(s){
  return s==="preflop"?"Preflop": s==="flop"?"Flop": s==="turn"?"Turn": s==="river"?"River":"Showdown";
}
function dealBoard(count){
  // burn one (optional cosmetic)
  G.deck.pop();
  for(let i=0;i<count;i++) G.board.push(G.deck.pop());
}
function startNextStreet(){
  collectBets();
  if(G.street==="preflop"){
    dealBoard(3); moveStreet("flop");
  } else if(G.street==="flop"){
    dealBoard(1); moveStreet("turn");
  } else if(G.street==="turn"){
    dealBoard(1); moveStreet("river");
  } else if(G.street==="river"){
    moveStreet("showdown"); showdown(false); return;
  }
  // action from left of dealer
  G.toActIdx = (G.dealer+1)%G.players.length;
  G.toActIdx = adjustToLive(G.toActIdx);
  setActing(G.toActIdx);
  updateUI();
  if(!G.players[G.toActIdx].isMe) setTimeout(cpuAct, 500);
}
function adjustToLive(i){
  const n=G.players.length;
  for(let k=0;k<n;k++){
    const j=(i+k)%n;
    const p=G.players[j];
    if(p.inHand && !p.folded && !p.allin) return j;
  }
  return i;
}

/* =========================
   CPU LOGIC
========================= */
function preflopStrength(hole){
  // Very rough: pair>AK>... map to score
  const [a,b]=hole; const ra=rv(a[0]), rb=rv(b[0]);
  const suited = a[1]===b[1];
  const hi=Math.max(ra,rb), lo=Math.min(ra,rb);
  let s = 0;
  if(ra===rb) s = 600 + ra*10;                       // pairs
  else if((hi===12 && lo>=9) || (hi===11 && lo===10)) s=520; // AK/AQ/KQ-ish
  else s = 360 + hi*4 + (suited?12:0);
  // small bonus for connectivity
  if(Math.abs(ra-rb)===1) s+=10;
  return s;
}
function currentStrength(p){
  if(G.street==="preflop") return preflopStrength(p.hole);
  const score = bestOf7(p.hole, G.board);
  // scale 0..800 roughly
  return score[0]*100 + (score[1]??0)*2 + (score[2]??0);
}
function cpuBetSize(p){
  const s=currentStrength(p);
  let bb = (G.street==="preflop"?1:1.5);
  if(s>620) bb+=1;
  if(s>700) bb+=1.5;
  if(s>760) bb+=2;
  let bet = Math.min(p.stack, Math.max(BB, bb*BB));
  return roundCash(bet);
}
function cpuDecision(p){
  const need = Math.max(0, G.currentBet - p.bet);
  const canCheck = need<=0;
  const s = currentStrength(p);

  // fold thresholds vary by street
  const foldCut = (G.street==="preflop")? 380 : (G.street==="flop"? 420 : (G.street==="turn"? 470 : 520));
  if(!canCheck && s<foldCut) return "fold";
  if(canCheck && s<foldCut-20) return "check";

  // aggressive with strength
  const raiseProb = (s>730)?0.75 : (s>650)?0.45 : 0.25;
  if(Math.random() < raiseProb && p.stack > need+BB){
    return {type:"raise", amt: cpuBetSize(p)};
  }
  return canCheck? "check" : "call";
}
function cpuAct(){
  const p=G.players[G.toActIdx];
  if(!p || p.folded || p.allin || !p.inHand){ nextAction(); return; }

  const need=Math.max(0, G.currentBet - p.bet);
  const mv = cpuDecision(p);
  if(mv==="fold"){
    p.folded=true; p.inHand=false; p.status="Fold";
    log(`${p.name} folds`);
  } else if(mv==="check" && need===0){
    p.status="Check"; log(`${p.name} checks`);
  } else if(mv==="call"){
    const pay=Math.min(need, p.stack);
    p.stack-=pay; p.bet+=pay; p.contributed+=pay;
    if(p.stack===0) p.allin=true;
    p.status= need>0 ? `Call $${pay.toFixed(2)}` : "Check";
    if(need>0) log(`${p.name} calls $${pay.toFixed(2)}`);
  } else if(typeof mv==="object" && mv.type==="raise"){
    let target = (G.currentBet>0) ? Math.max(G.currentBet + G.minRaise, G.currentBet + mv.amt) : Math.max(BB, mv.amt);
    let add = target - p.bet;
    add = Math.min(add, p.stack);
    if(add<=need){
      // fallback to call
      const pay=Math.min(need, p.stack);
      p.stack-=pay; p.bet+=pay; p.contributed+=pay;
      if(p.stack===0) p.allin=true;
      p.status=`Call $${pay.toFixed(2)}`; log(`${p.name} calls $${pay.toFixed(2)}`);
    } else {
      p.stack-=add; p.bet+=add; p.contributed+=add;
      if(p.stack===0) p.allin=true;
      const raiseAmt = p.bet - G.currentBet;
      G.minRaise = Math.max(G.minRaise, raiseAmt);
      G.currentBet = p.bet;
      p.status=`Raise to $${p.bet.toFixed(2)}`;
      log(`${p.name} raises to $${p.bet.toFixed(2)}`);
    }
  } else {
    // default call/check
    const pay=Math.min(need, p.stack);
    p.stack-=pay; p.bet+=pay; p.contributed+=pay;
    if(p.stack===0) p.allin=true;
    p.status = need>0 ? `Call $${pay.toFixed(2)}` : "Check";
    if(need>0) log(`${p.name} calls $${pay.toFixed(2)}`);
  }
  updateUI();
  nextAction();
}

/* =========================
   TURN ENGINE
========================= */
function setActing(i){
  G.players.forEach(p=>p.toAct=false);
  G.players[i].toAct=true;
  updateHUD();
}
function nextAction(){
  const inPlay = G.players.filter(p=>p.inHand && !p.folded);
  if(inPlay.length===1){ showdown(true); return; }

  if(allBetsClosed()){
    startNextStreet(); return;
  }
  G.toActIdx = nextIdxFrom(G.toActIdx);
  setActing(G.toActIdx);
  updateUI();
  if(!G.players[G.toActIdx].isMe) setTimeout(cpuAct, 500);
}

/* =========================
   PLAYER ACTIONS
========================= */
function actFold(){
  const me=G.players[0];
  if(!me.toAct || me.folded || !me.inHand) return;
  me.folded=true; me.inHand=false; me.status="Fold";
  log(`You fold`);
  updateUI(); nextAction();
}
function actCheckCall(){
  const me=G.players[0];
  if(!me.toAct || me.folded || !me.inHand) return;
  const need=Math.max(0, G.currentBet - me.bet);
  if(need<=0){ me.status="Check"; log(`You check`); }
  else{
    const pay=Math.min(need, me.stack);
    me.stack-=pay; me.bet+=pay; me.contributed+=pay;
    if(me.stack===0) me.allin=true;
    me.status=`Call $${pay.toFixed(2)}`;
    log(`You call $${pay.toFixed(2)}`);
  }
  updateUI(); nextAction();
}
function actBetRaise(){
  const me=G.players[0];
  if(!me.toAct || me.folded || !me.inHand) return;
  let want=roundCash(parseFloat(document.getElementById('betSlider').value));
  const need=Math.max(0, G.currentBet - me.bet);

  let target = (G.currentBet>0) ? (G.currentBet + Math.max(G.minRaise, BB)) : Math.max(BB, want);
  let add = (G.currentBet>0) ? (target - me.bet) : want;
  add = Math.max(add, need + BB);
  add = Math.min(add, me.stack);

  if(add<=need){ actCheckCall(); return; }
  me.stack-=add; me.bet+=add; me.contributed+=add;
  if(me.stack===0) me.allin=true;
  G.minRaise = Math.max(G.minRaise, me.bet - G.currentBet);
  G.currentBet = me.bet;
  me.status=`Raise to $${me.bet.toFixed(2)}`;
  log(`You raise to $${me.bet.toFixed(2)}`);
  updateUI(); nextAction();
}
function actAllIn(){
  const me=G.players[0];
  if(!me.toAct || me.folded || !me.inHand) return;
  const add=me.stack;
  if(add<=0){ actCheckCall(); return; }
  me.stack=0; me.bet+=add; me.contributed+=add; me.allin=true;
  if(me.bet>G.currentBet){ G.minRaise=Math.max(G.minRaise, me.bet-G.currentBet); G.currentBet=me.bet; }
  me.status="All-in";
  log(`You go ALL-IN ($${add.toFixed(2)})`);
  updateUI(); nextAction();
}

/* =========================
   SHOWDOWN & POTS (basic side pots)
========================= */
function showdown(walk){
  moveStreet("showdown");
  collectBets();
  const contenders = G.players.filter(p=>p.inHand && !p.folded);
  if(contenders.length===0){ // weird edge
    updateUI(true); nextHandSoon(); return;
  }

  // Build side pots based on contributed amounts
  const levels = [...new Set(G.players.map(p=>p.contributed))].filter(x=>x>0).sort((a,b)=>a-b);
  const pots=[]; let prev=0;
  for(const lvl of levels){
    // eligible players: those who contributed >= lvl
    const elig = G.players.filter(p=>p.contributed>=lvl);
    const slice = (lvl - prev) * elig.length;
    if(slice>0){
      pots.push({amount:slice, eligible: elig.filter(p=>p.inHand)});
    }
    prev=lvl;
  }
  // Safety fallback if rounding leaves remainder
  let tot = pots.reduce((s,p)=>s+p.amount,0);
  if(tot < G.pot){ pots.push({amount:G.pot-tot, eligible:contenders}); }

  // Determine winners per pot
  const results=[];
  for(const pot of pots){
    if(pot.eligible.length===0) continue;
    let bestScore=null, winners=[];
    for(const p of pot.eligible){
      const sc = bestOf7(p.hole, G.board);
      if(!bestScore || cmp(sc,bestScore)>0){ bestScore=sc; winners=[p]; }
      else if(cmp(sc,bestScore)===0){ winners.push(p); }
    }
    const share = pot.amount / winners.length;
    winners.forEach(w=> w.stack += share);
    results.push({amount:pot.amount, winners, label:handLabel(bestOf7(winners[0].hole, G.board))});
  }

  // Log winners
  const uniqWinners = new Set();
  for(const r of results){ r.winners.forEach(w=>uniqWinners.add(w)); }
  const names = [...uniqWinners].map(w=>w.name).join(", ");
  log(`Showdown â€” Winner(s): ${names}`);

  updateUI(true);
  nextHandSoon();
}
function nextHandSoon(){
  setTimeout(()=>{
    nextDealer();
    startHand();
  }, 1600);
}

/* =========================
   UI
========================= */
function suitSpan(s){ return `<span class="suit">${s}</span>` }
function renderCard(c, faceup=true, ghost=false){
  if(!faceup) return `<div class="card">ðŸ‚ </div>`;
  const col = cardColor(c);
  return `<div class="card faceup ${ghost?'ghost':''} ${col}">
    ${suitSpan(c[1])}<div class="rank">${c[0]}</div>
  </div>`;
}
function renderPlayers(){
  const wrap=document.getElementById('players');
  wrap.innerHTML="";
  G.players.forEach(p=>{
    const seat=document.createElement('div');
    seat.className='seat'+(p.isMe?' me':'');
    const name=document.createElement('div');
    name.className='name'; name.textContent=p.name;
    const stack=document.createElement('div');
    stack.className='stack'; stack.textContent=`Stack: $${p.stack.toFixed(2)}   Bet: $${p.bet.toFixed(2)}`;
    const status=document.createElement('div');
    status.className='status'; status.textContent=(p.toAct?'â–¶ ':'')+(p.status||'');
    const cards=document.createElement('div'); cards.className='cards';

    if(p.dealer){ const d=document.createElement('div'); d.className='dealer'; d.textContent='D'; seat.appendChild(d); }
    if(p.blindTag){ const b=document.createElement('div'); b.className='blind'; b.textContent=p.blindTag; seat.appendChild(b); }

    if(p.isMe || G.street==="showdown"){
      for(const c of p.hole){ cards.insertAdjacentHTML('beforeend', renderCard(c,true)); }
    } else {
      cards.insertAdjacentHTML('beforeend', renderCard("ðŸ‚ ",false));
      cards.insertAdjacentHTML('beforeend', renderCard("ðŸ‚ ",false));
    }

    seat.appendChild(name); seat.appendChild(stack); seat.appendChild(status); seat.appendChild(cards);
    if(p.folded || !p.inHand) seat.style.opacity=.55;
    wrap.appendChild(seat);
  });

  // board
  const b=document.getElementById('board'); b.innerHTML="";
  const showCount = (G.street==="preflop")?0 : (G.street==="flop")?3 : (G.street==="turn")?4 : (G.street==="river"||G.street==="showdown")?5:0;
  for(let i=0;i<5;i++){
    if(i<showCount) b.insertAdjacentHTML('beforeend', renderCard(G.board[i],true));
    else b.insertAdjacentHTML('beforeend', `<div class="card ghost">ðŸ‚ </div>`);
  }

  document.getElementById('pot').textContent=G.pot.toFixed(2);
  document.getElementById('phasePill').textContent=streetDisplay(G.street);
  const actor=G.players.find(p=>p.toAct);
  document.getElementById('toActPill').textContent = actor? `${actor.name} to act` : 'â€”';

  // My current best label
  const tag=document.getElementById('handTag');
  const me=G.players[0];
  if(G.street==="preflop") tag.textContent = `Hole: ${me.hole.join(' ')}`;
  else tag.textContent = `Best: ${handLabel(bestOf7(me.hole, G.board))}`;
}
function updateHUD(){
  const fold=document.getElementById('foldBtn');
  const call=document.getElementById('checkCallBtn');
  const raise=document.getElementById('betRaiseBtn');
  const slider=document.getElementById('betSlider');
  const betVal=document.getElementById('betVal');
  const allIn=document.getElementById('allInBtn');

  const actor = G.players.find(p=>p.toAct);
  const canMe = actor && actor.isMe && !actor.folded && actor.inHand && !actor.allin && G.street!=="showdown";
  fold.disabled=!canMe; call.disabled=!canMe; raise.disabled=!canMe; slider.disabled=!canMe; allIn.disabled=!canMe;

  const need = actor? Math.max(0,G.currentBet - actor.bet) : 0;
  call.textContent = need<=0 ? "Check" : `Call $${Math.min(need, actor?actor.stack:0).toFixed(2)}`;

  const maxBet = actor ? roundCash(Math.max(BB, Math.min(actor.stack, 25))) : 10;
  slider.max = String(maxBet);
  if(parseFloat(slider.value)>maxBet) slider.value=String(maxBet);
  betVal.textContent=parseFloat(slider.value).toFixed(2);
}
function updateUI(forceReveal=false){
  renderPlayers();
  updateHUD();
  if(forceReveal && G.street==="showdown"){
    // statuses with hand labels
    const seats = document.querySelectorAll('.seat');
    G.players.forEach((p,pi)=>{
      const sEl = seats[pi].querySelector('.status');
      if(p.inHand){
        const lab = handLabel(bestOf7(p.hole, G.board));
        sEl.textContent = (p.status? p.status+" â€¢ ":"") + lab;
      }
    });
  }
}

/* =========================
   EVENTS
========================= */
document.getElementById('newGameBtn').addEventListener('click', ()=>{
  const pc=parseInt(document.getElementById('playerCount').value,10);
  newGame(pc);
});
document.getElementById('betSlider').addEventListener('input',(e)=>{
  document.getElementById('betVal').textContent=parseFloat(e.target.value).toFixed(2);
});
document.getElementById('foldBtn').addEventListener('click', actFold);
document.getElementById('checkCallBtn').addEventListener('click', actCheckCall);
document.getElementById('betRaiseBtn').addEventListener('click', actBetRaise);
document.getElementById('allInBtn').addEventListener('click', actAllIn);

/* =========================
   BOOT
========================= */
(function boot(){
  const pc=parseInt(document.getElementById('playerCount').value,10);
  newGame(pc);
})();
</script>
</body>
</html>