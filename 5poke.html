<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Texas Hold’em — Single File • You vs 5 CPU</title>
<style>
  :root{
    --bg:#0b1016;
    --felt:#0e2d1b;
    --felt2:#154a28;
    --ink:#ecf4ef;
    --muted:#a9c3b2;
    --accent:#27d6ff;
    --accent2:#55ffc5;
    --warn:#ff8a65;
    --danger:#ff4d6d;
    --chip:#ffd166;
    --panel:#0f1720cc;
    --btn:#172635;
    --btnHi:#1e3954;
    --gold:#ffd54a;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;
    background:
      radial-gradient(1200px 800px at 70% -10%, #1a2e22 0%, transparent 60%),
      radial-gradient(900px 600px at 0% 100%, #13212a 0%, transparent 60%),
      linear-gradient(180deg, #090c10 0%, #0a1117 100%);
    color:var(--ink);
    overflow:hidden;
    -webkit-font-smoothing:antialiased;
    touch-action:manipulation;
  }
  .app{
    display:grid;grid-template-rows:auto 1fr auto;height:100%;
    min-height:100vh;
  }
  @supports (height:100dvh){ .app{height:100dvh;min-height:100dvh} }

  header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px max(14px, env(safe-area-inset-left)) 10px max(14px, env(safe-area-inset-right));
    background:linear-gradient(180deg,#0b141b 0%, #0a1218 100%);
    border-bottom:1px solid #0f2832;
  }
  .title{font-weight:700;letter-spacing:.4px;color:var(--muted);font-size:14px}
  .bank{display:flex;gap:10px;flex-wrap:wrap}
  .tag{padding:6px 10px;border:1px solid #1a3542;border-radius:10px;background:#0c1a22;color:var(--muted);font-size:12px}
  .tag strong{color:var(--ink)}

  .tableWrap{position:relative;padding:12px;display:grid;place-items:center}
  .table{
    position:relative;width:min(1120px,96vw);aspect-ratio:16/9;border-radius:32px;
    background:radial-gradient(120% 120% at 50% 50%, var(--felt2) 0%, var(--felt) 60%, #0a1510 100%);
    box-shadow:inset 0 0 0 3px #113c2a,inset 0 0 40px #0b1f15,0 20px 60px #0009;
    overflow:visible;
  }
  .rail{position:absolute;inset:-18px;border-radius:40px;background:linear-gradient(180deg,#3a2412,#1e1209 70%);box-shadow:inset 0 4px 14px #0008,0 10px 30px #0008}
  .pot{position:absolute;left:50%;top:50%;transform:translate(-50%,-32%);background:#0c1a22e6;border:1px solid #153241;backdrop-filter:blur(6px);padding:6px 10px;border-radius:10px;font-size:13px;color:var(--gold);box-shadow:0 4px 18px #0006}
  .community{position:absolute;left:50%;top:50%;transform:translate(-50%,-10%);display:flex;gap:8px;align-items:center;justify-content:center}
  .players{position:absolute;inset:0;pointer-events:none}
  .topPanel{position:absolute;right:10px;top:10px;display:flex;gap:8px;z-index:5}
  .pill{background:#0c1a22cc;border:1px solid #153241;color:var(--muted);border-radius:999px;padding:6px 10px;font-size:12px;display:flex;gap:8px;align-items:center}

  .seat{position:absolute;width:220px;display:grid;gap:6px;justify-items:center}
  .seat .name{font-size:13px;color:var(--muted);background:#0c1a22cc;border:1px solid #153241;border-radius:10px;padding:4px 8px}
  .seat .chips{font-size:12px;color:var(--chip)}
  .seat .status{min-height:16px;font-size:12px;color:var(--muted)}
  .dealerBtn{position:absolute;transform:translate(-50%,-50%);width:26px;height:26px;border-radius:50%;background:#f2f2f2;color:#111;display:grid;place-items:center;font-size:11px;font-weight:800;border:2px solid #dedede;box-shadow:0 2px 6px #0007}

  .card{width:64px;height:92px;border-radius:10px;background:#e6f3f0;border:2px solid #cfe3dc;box-shadow:0 6px 20px #0008;position:relative;display:grid;place-items:center;font-weight:700;color:#0a1012;user-select:none}
  .card.small{width:54px;height:78px;border-radius:8px}
  .card.back{background:repeating-linear-gradient(45deg, #122a3a 0 8px, #0e2230 8px 16px);border-color:#2a5c74;color:transparent}
  .pip{font-size:20px}
  .suit{font-size:12px;opacity:.85}
  .♥,.♦{color:#ce1b45}.♣,.♠{color:#0b1d2b}

  .hand{display:flex;gap:8px;align-items:center;justify-content:center}
  .me{position:absolute;left:50%;bottom:-10px;transform:translateX(-50%);width:400px}
  .me .hand .card{transform:translateY(-6px)}
  .glow{box-shadow:0 0 0 2px var(--accent), 0 0 26px var(--accent) !important}

  .controls{display:grid;gap:8px;padding:10px 10px calc(10px + env(safe-area-inset-bottom));grid-template-columns:1fr;background:linear-gradient(180deg,#0b141b,#091219);border-top:1px solid #0f2832}
  .controlRow{display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center}
  .buttons{display:flex;gap:8px;flex-wrap:wrap}
  button{-webkit-tap-highlight-color:transparent;background:var(--btn);color:#e8f3ec;border:1px solid #254456;border-radius:12px;padding:12px 14px;font-weight:700;font-size:15px;box-shadow:inset 0 -2px 0 #0a1620,0 2px 8px #0008;cursor:pointer}
  button:hover{background:var(--btnHi)}
  button.primary{border-color:#1e6f86;box-shadow:inset 0 -2px 0 #0d2a33,0 4px 14px #0008}
  button.warn{border-color:#6a2a1b;background:#2a1611}
  button.danger{border-color:#7a1d2f;background:#2a0f16}
  button:disabled{opacity:.45;cursor:not-allowed}
  .sliderRow{display:flex;align-items:center;gap:10px}
  input[type="range"]{width:240px;height:34px}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:28px;height:28px;border-radius:50%;background:#e8f3ec;border:2px solid #254456;box-shadow:0 1px 4px #0007}
  input[type="range"]::-moz-range-thumb{width:28px;height:28px;border:none;border-radius:50%}
  .betAmt{min-width:88px;text-align:right;font-variant-numeric:tabular-nums}
  .log{height:120px;overflow:auto;background:#081017;border:1px solid #0e2230;border-radius:12px;padding:8px;font-size:12px;color:var(--muted)}
  .toast{position:absolute;left:50%;top:6%;transform:translateX(-50%);background:#0c1a22e6;border:1px solid #153241;backdrop-filter:blur(6px);padding:10px 14px;border-radius:12px;color:var(--ink);font-weight:700;box-shadow:0 8px 24px #000a}

  @media (max-width:900px){
    .seat{width:180px}
    .card{width:56px;height:82px}
    .card.small{width:48px;height:70px}
    .me{width:360px}
  }
  @media (max-width:700px){
    button{padding:14px 16px;font-size:16px;border-radius:14px}
    .buttons{gap:10px}
    .log{height:96px}
    .seat{width:150px}
    .card{width:50px;height:74px}
    .card.small{width:44px;height:64px}
    .me{width:320px}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">Texas Hold’em — 6-Handed • Single File</div>
    <div class="bank">
      <div class="tag">Stacks: <strong id="stacksTag">$—</strong></div>
      <div class="tag">Blinds: <strong id="blindsTag">0.25 / 0.50</strong></div>
      <div class="tag">Level: <strong id="levelTag">1</strong></div>
      <div class="tag">Hands: <strong id="handsTag">0</strong></div>
    </div>
  </header>

  <div class="tableWrap">
    <div class="table" id="table">
      <div class="rail"></div>
      <div class="topPanel">
        <div class="pill">Bot delay
          <input id="delay" type="range" min="200" max="1600" step="100" value="700">
          <span id="delayLbl">700ms</span>
        </div>
        <div class="pill">Speed: <span id="speedLbl">Normal</span></div>
      </div>
      <div class="toast" id="toast" style="display:none"></div>
      <div class="pot" id="potBox">Pot: $0.00</div>
      <div class="community" id="community"></div>
      <div class="players" id="players"></div>

      <div class="seat me" id="meSeat">
        <div class="name" id="meName">You</div>
        <div class="hand" id="meHand"></div>
        <div class="chips" id="meChips">$50.00</div>
        <div class="status" id="meStatus"></div>
      </div>
    </div>
  </div>

  <div class="controls">
    <div class="controlRow">
      <div class="buttons">
        <button id="newGame" class="primary">New Table ($50 stacks)</button>
        <button id="nextHand">Next Hand</button>
        <button id="showdown">Showdown</button>
        <button id="autoNext">Auto Next: Off</button>
      </div>
      <div class="buttons">
        <button id="helpBtn">?</button>
      </div>
    </div>

    <div class="controlRow">
      <div class="buttons">
        <button id="checkBtn">Check</button>
        <button id="callBtn" class="primary">Call</button>
        <button id="betBtn">Bet / Raise</button>
        <button id="allinBtn" class="warn">All-In</button>
        <button id="foldBtn" class="danger">Fold</button>
      </div>
      <div class="sliderRow">
        <span id="betLabel">Bet: $</span>
        <input id="betSlider" type="range" min="0" max="50" step="0.25" value="1">
        <span id="betAmt" class="betAmt">1.00</span>
      </div>
    </div>

    <div class="log" id="log"></div>
  </div>
</div>

<script>
(() => {
  // ---------- Helpers ----------
  const $ = s=>document.querySelector(s);
  const fmt = n => (n<0?'-$':'$') + Math.abs(n).toFixed(2);
  const suits = ["♣","♦","♥","♠"];
  const ranks = [2,3,4,5,6,7,8,9,10,11,12,13,14]; // 11=J,12=Q,13=K,14=A
  const randInt = (a,b)=> (a + Math.floor(Math.random()*(b-a+1)));

  const UI = {
    potBox: $('#potBox'),
    comm: $('#community'),
    playersBox: $('#players'),
    meHand: $('#meHand'), meChips: $('#meChips'), meStatus: $('#meStatus'),
    stacksTag: $('#stacksTag'), blindsTag: $('#blindsTag'), levelTag: $('#levelTag'), handsTag: $('#handsTag'),
    betSlider: $('#betSlider'), betAmt: $('#betAmt'), betLabel: $('#betLabel'),
    delay: $('#delay'), delayLbl: $('#delayLbl'), speedLbl: $('#speedLbl'),
    log: $('#log'), toast: $('#toast'),
    btn: {
      new: $('#newGame'), next: $('#nextHand'), showdown: $('#showdown'), autoNext: $('#autoNext'),
      check: $('#checkBtn'), call: $('#callBtn'), bet: $('#betBtn'), allin: $('#allinBtn'), fold: $('#foldBtn'), help: $('#helpBtn')
    }
  };

  function logLine(html){
    const d=document.createElement('div'); d.innerHTML=html; UI.log.appendChild(d); UI.log.scrollTop=UI.log.scrollHeight;
  }
  function banner(text, ms=1400){ UI.toast.textContent=text; UI.toast.style.display='block'; setTimeout(()=>UI.toast.style.display='none', ms); }
  const cardEl = (c, small=false, back=false) => {
    const d=document.createElement('div');
    d.className='card'+(small?' small':'')+(back?' back':'');
    if(!back){
      const pip=(c.r===14?'A':c.r===13?'K':c.r===12?'Q':c.r===11?'J':c.r);
      d.innerHTML=`<div class="pip ${c.s}">${pip}</div><div class="suit ${c.s}">${c.s}</div>`;
    }
    return d;
  };
  function rankChar(r){ return r===14?'A':r===13?'K':r===12?'Q':r===11?'J':r; }
  const cardsText = cs => cs.map(c=>`${rankChar(c.r)}${c.s}`).join(' ');

  // ---------- Game State ----------
  const startStack=50;
  let smallBlind=0.25, bigBlind=0.50;
  let level=1, handsPlayed=0, autoNext=false;

  let deck=[], community=[];
  let players=[], dealerIdx=0, street='idle', toAct=-1;
  let currentBet=0, lastRaise=0;        // per street
  let handActive=false;

  // players[i]: {id, name, isHuman, stack, hand[], inHand, allIn, bet (this street), committed (this hand)}
  function freshDeck(){
    deck=[]; for (let s=0;s<4;s++) for (let r=0;r<ranks.length;r++) deck.push({r:ranks[r], s:suits[s]});
    for(let i=deck.length-1;i>0;i--){const j=(Math.random()*(i+1))|0; [deck[i],deck[j]]=[deck[j],deck[i]];}
  }

  function resetTable(){
    players=[];
    ["You","Bot A","Bot B","Bot C","Bot D","Bot E"].forEach((n,i)=>players.push({
      id:i,name:n,isHuman:i===0,stack:startStack,hand:[],inHand:true,allIn:false,bet:0,committed:0
    }));
    dealerIdx=0; handsPlayed=0; level=1; smallBlind=.25; bigBlind=.50;
    UI.log.innerHTML='';
    renderSeats(); updateHeader();
    UI.btn.showdown.disabled=true;
    street='idle'; handActive=false;
  }

  function renderSeats(){
    UI.playersBox.innerHTML='';
    const pos=[
      {x:50,y:96},
      {x:85,y:75},{x:85,y:28},
      {x:50,y:8},
      {x:15,y:28},{x:15,y:75}
    ];
    players.forEach((p,i)=>{
      const seat=document.createElement('div');
      seat.className='seat'; seat.style.left=`calc(${pos[i].x}% - 110px)`; seat.style.top=`calc(${pos[i].y}% - 46px)`; seat.id=`seat${i}`;
      const name=document.createElement('div'); name.className='name'; name.id=`name${i}`; name.textContent=p.name+(i===dealerIdx?' (D)':'');
      const hand=document.createElement('div'); hand.className='hand'; hand.id=`hand${i}`;
      const chips=document.createElement('div'); chips.className='chips'; chips.id=`chips${i}`; chips.textContent=fmt(p.stack);
      const status=document.createElement('div'); status.className='status'; status.id=`status${i}`;
      seat.append(name,hand,chips,status); UI.playersBox.appendChild(seat);
      if(i===dealerIdx){ const d=document.createElement('div'); d.className='dealerBtn'; d.style.left=pos[i].x+'%'; d.style.top=(pos[i].y-7)+'%'; d.textContent='D'; UI.playersBox.appendChild(d); }
    });
    UI.meHand.innerHTML=''; UI.meChips.textContent=fmt(players[0].stack);
  }

  function updateHeader(){
    UI.stacksTag.textContent = players.map(p=>`${p.isHuman?'You':p.name}:${fmt(p.stack)}`).join('  ');
    UI.blindsTag.textContent = `${smallBlind.toFixed(2)} / ${bigBlind.toFixed(2)}`;
    UI.levelTag.textContent = level;
    UI.handsTag.textContent = handsPlayed;
  }

  function clearBoard(){
    community=[]; UI.comm.innerHTML=''; potUpdate(0,true);
    players.forEach(p=>{ p.hand=[]; p.inHand = p.stack>0; p.allIn=false; p.bet=0; p.committed=0; status(iOf(p),''); seatHand(iOf(p)).innerHTML=''; });
    UI.meStatus.textContent='';
    UI.meHand.innerHTML='';
  }

  function seatHand(i){ return document.getElementById(`hand${i}`); }
  function status(i, msg){ const el=document.getElementById(`status${i}`); if(el) el.textContent=msg||''; if(i===0) UI.meStatus.textContent=msg||''; }
  function say(i, msg){ status(i,msg); logLine(`<b>${players[i].name}</b>: ${msg}`); }
  function iOf(p){ return p.id; }

  // ---------- Pot & Chips ----------
  function potTotal(){ return players.reduce((s,p)=>s+p.committed,0); }
  function potUpdate(_,force=false){ if(force) UI.potBox.textContent = 'Pot: '+fmt(potTotal()); else UI.potBox.textContent = 'Pot: '+fmt(potTotal()); }
  function pay(i, amount){ // move from stack to bet & committed
    const p=players[i]; const payAmt=Math.max(0, Math.min(amount, p.stack));
    p.stack -= payAmt; p.bet += payAmt; p.committed += payAmt;
    document.getElementById(`chips${i}`).textContent=fmt(p.stack);
    potUpdate();
    if(p.stack===0) p.allIn=true;
    return payAmt;
  }

  // ---------- Dealing ----------
  function dealHole(){
    for(let r=0;r<2;r++){
      for(let k=1;k<=players.length;k++){
        const i=(dealerIdx+k)%players.length; const p=players[i];
        if(!p.inHand) continue;
        p.hand.push(deck.pop());
      }
    }
    players.forEach(p=>{
      const el=seatHand(p.id); el.innerHTML='';
      if(p.isHuman){
        p.hand.forEach(c=> el.appendChild(cardEl(c,true,false)));
        UI.meHand.innerHTML=''; p.hand.forEach(c=> UI.meHand.appendChild(cardEl(c,false,false)));
        UI.meHand.querySelectorAll('.card').forEach(c=>c.classList.add('glow'));
      }else{
        el.appendChild(cardEl({},true,true)); el.appendChild(cardEl({},true,true));
      }
    });
  }
  function burn(){ deck.pop(); }
  function flop(){ burn(); community=[deck.pop(),deck.pop(),deck.pop()]; renderCommunity(); }
  function turn(){ burn(); community.push(deck.pop()); renderCommunity(); }
  function river(){ burn(); community.push(deck.pop()); renderCommunity(); }
  function renderCommunity(){ UI.comm.innerHTML=''; community.forEach(c=> UI.comm.appendChild(cardEl(c,false,false))); }

  // ---------- Blinds & Turn Order ----------
  function nextActive(from){
    for(let step=1;step<=players.length;step++){
      const i=(from+step)%players.length, p=players[i];
      if(p.inHand && !p.allIn) return i;
    }
    return from;
  }
  function liveCount(){ return players.filter(p=>p.inHand).length; }

  function postBlinds(){
    // SB is next after dealer, then BB
    const sbIdx = nextActive(dealerIdx);
    const bbIdx = nextActive(sbIdx);
    say(sbIdx, `Posts SB ${fmt(smallBlind)}`); pay(sbIdx, Math.min(players[sbIdx].stack, smallBlind));
    say(bbIdx, `Posts BB ${fmt(bigBlind)}`);   pay(bbIdx, Math.min(players[bbIdx].stack, bigBlind));
    currentBet = Math.max(players[sbIdx].bet, players[bbIdx].bet);
    lastRaise = bigBlind; // initial raise size baseline
    toAct = nextActive(bbIdx); // UTG
  }

  // ---------- Betting Round Control ----------
  function everyoneSettled(){
    // Round ends if:
    // - Only one player remains inHand, or
    // - For every player inHand: (p.allIn || p.bet===currentBet)
    const alive = players.filter(p=>p.inHand);
    if(alive.length<=1) return true;
    return alive.every(p=> p.allIn || p.bet===currentBet);
  }

  function resetBetsForNewStreet(){
    players.forEach(p=> p.bet=0);
    currentBet=0; lastRaise=bigBlind; // lastRaise resets to bb (minimum future raise size)
  }

  function setButtons(){
    const me=players[0];
    const acting = (toAct===0 && handActive && me.inHand && !me.allIn && street!=='idle' && street!=='showdown');
    const toCall = Math.max(0, currentBet - me.bet);

    UI.btn.check.disabled = !acting || toCall>0;
    UI.btn.call.disabled  = !acting || toCall===0 || me.stack===0;
    UI.btn.fold.disabled  = !acting;
    UI.btn.bet.disabled   = !acting || me.stack===0;
    UI.btn.allin.disabled = !acting || me.stack===0;

    // Slider meaning: shows the additional chips to put in now (not total)
    // If currentBet==0 => "Bet", else "Raise"
    UI.betLabel.textContent = (currentBet===0?'Bet: $':'Raise by: $');

    const minInc = currentBet===0 ? bigBlind : lastRaise; // minimal increase when betting/raising
    const minAdd = Math.min(me.stack, (toCall===0 ? Math.max(bigBlind, 0.25) : Math.max(lastRaise, 0.25)));
    const maxAdd = me.stack;

    UI.betSlider.min = minAdd.toFixed(2);
    UI.betSlider.max = Math.max(minAdd, maxAdd).toFixed(2);
    if(parseFloat(UI.betSlider.value) < minAdd) UI.betSlider.value = minAdd.toFixed(2);
    UI.betAmt.textContent = parseFloat(UI.betSlider.value).toFixed(2);

    UI.delayLbl.textContent = UI.delay.value+'ms';
    const sp=+UI.delay.value; UI.speedLbl.textContent = sp<500?'Fast':sp>1200?'Leisurely':'Normal';
  }

  let thinking=false;
  function actLoop(){
    if(!handActive) return;
    if(everyoneSettled()){
      advanceStreet(); return;
    }
    const i = toAct, p=players[i];
    highlightToAct(i);

    if(!p.inHand || p.allIn){ toAct = nextActive(i); actLoop(); return; }

    if(p.isHuman){ setButtons(); return; }

    // CPU
    thinking=true; setButtons();
    const delay=+UI.delay.value;
    cpuDecision(i).then(a=>{
      thinking=false;
      applyAction(i, a.type, a.add || 0);
      setTimeout(actLoop, 90);
    });
  }

  function highlightToAct(i){
    players.forEach(pp=>{
      const el=document.getElementById(`name${pp.id}`); if(el) el.style.outline='';
    });
    const el=document.getElementById(`name${i}`); if(el) el.style.outline='2px solid var(--accent)';
  }

  // ---------- Actions ----------
  function fold(i){
    const p=players[i]; p.inHand=false; p.allIn=false; say(i,'Folds');
  }
  function call(i){
    const p=players[i]; const need = Math.max(0, currentBet - p.bet);
    if(need<=0){ check(i); return; }
    const paid = pay(i, need);
    say(i, `Calls ${fmt(paid)}`);
  }
  function check(i){ say(i, 'Checks'); }
  function betOrRaise(i, add){ // add = additional chips to put in now
    const p=players[i];
    const toCall = Math.max(0, currentBet - p.bet);
    const addClamped = Math.min(add, p.stack);

    // put in at least toCall first
    if(toCall>0){
      // RAISE
      const raiseInc = addClamped; // additional over call
      const totalAdd = Math.min(p.stack, toCall + raiseInc);
      const beforeBet = p.bet;
      const paid = pay(i, totalAdd);
      const newBet = p.bet;
      const raiseSize = newBet - currentBet;
      if(newBet > currentBet){
        // Only raises that meet or exceed lastRaise update the lastRaise (unless all-in smaller -> doesn't reset lastRaise)
        if(raiseSize >= lastRaise) lastRaise = raiseSize;
        currentBet = newBet;
        say(i, p.stack===0 ? `All-in to ${fmt(newBet)}` : `Raises to ${fmt(newBet)}`);
      }else{
        say(i, `Calls ${fmt(newBet - beforeBet)}`);
      }
    }else{
      // BET
      const paid = pay(i, Math.max(addClamped, bigBlind));
      if(paid<=0){ check(i); return; }
      currentBet = p.bet;
      lastRaise = Math.max(lastRaise, currentBet); // first bet sets lastRaise baseline
      say(i, p.stack===0 ? `All-in ${fmt(p.bet)}` : `Bets ${fmt(paid)}`);
    }
  }
  function shove(i){
    const p=players[i];
    const add = p.stack;
    if(add<=0){ // nothing to add -> act as call/check
      const need = Math.max(0, currentBet - p.bet);
      if(need>0) call(i); else check(i);
      return;
    }
    betOrRaise(i, add);
  }

  function applyAction(i, type, add){
    const need = Math.max(0, currentBet - players[i].bet);
    if(type==='fold'){ fold(i); }
    else if(type==='check'){ if(need>0){ call(i); } else check(i); }
    else if(type==='call'){ call(i); }
    else if(type==='bet' || type==='raise'){ betOrRaise(i, add); }
    else if(type==='allin'){ shove(i); }
    toAct = nextActive(i);

    // if only one player left, finish hand now (award immediately)
    if(players.filter(p=>p.inHand).length===1){ finishByFold(); }
    setButtons();
  }

  function finishByFold(){
    const winner = players.find(p=>p.inHand);
    if(!winner){ advanceStreet(); return; }
    // No showdown needed, award entire pot to remaining player
    revealBots(false);
    awardPots([{amount:potTotal(), elig:players.filter(p=>p.inHand || p.committed>0)}], [winner]);
    endHand();
  }

  // ---------- Streets ----------
  function startHand(){
    handActive=true; street='pre'; currentBet=0; lastRaise=bigBlind; clearBoard();
    freshDeck(); dealHole(); postBlinds(); setButtons(); actLoop();
    UI.btn.showdown.disabled=false;
  }

  function advanceStreet(){
    if(!handActive) return;
    // equalize bets into pot (already tracked in committed), just reset per-street
    players.forEach(p=>{ /* committed remains; bet resets */ });

    if(street==='pre'){
      flop(); street='flop'; resetBetsForNewStreet(); sayAll(''); toAct = nextActive(dealerIdx); banner('Flop'); actLoop();
    }else if(street==='flop'){
      turn(); street='turn'; resetBetsForNewStreet(); sayAll(''); toAct = nextActive(dealerIdx); banner('Turn'); actLoop();
    }else if(street==='turn'){
      river(); street='river'; resetBetsForNewStreet(); sayAll(''); toAct = nextActive(dealerIdx); banner('River'); actLoop();
    }else if(street==='river'){
      doShowdown();
    }
  }
  function sayAll(txt){ players.forEach(p=>status(p.id,txt)); }

  function doShowdown(){
    street='showdown';
    revealBots(true);
    // Build side pots from committed amounts
    const pots = buildSidePots();
    // Eligible winners per pot are those not folded (inHand) who committed >= pot level
    const live = players.filter(p=>p.inHand);
    const winnersByPot = pots.map(pot=>{
      const elig = players.filter(pl=>pl.committed>=pot.level && (pl.inHand));
      if(elig.length===0) return [];
      const ranked = elig.map(pl=>({p:pl, r:evaluateBest7(pl.hand.concat(community))})).sort((a,b)=>cmpRank(b.r,a.r));
      const best=ranked[0].r;
      return ranked.filter(x=>cmpRank(x.r,best)===0).map(x=>x.p);
    });
    // Award
    pots.forEach((pot,idx)=> awardPots([pot], winnersByPot[idx]));
    endHand();
  }

  function revealBots(show){
    players.forEach(p=>{
      if(p.isHuman) return;
      const el=seatHand(p.id);
      if(!p.inHand && !show) return;
      el.innerHTML='';
      if(show && p.hand.length===2){
        el.appendChild(cardEl(p.hand[0],true,false));
        el.appendChild(cardEl(p.hand[1],true,false));
      }else{
        el.appendChild(cardEl({},true,true));
        el.appendChild(cardEl({},true,true));
      }
    });
  }

  function buildSidePots(){
    // Based on each player's committed amount; create tiers
    const commits = players.map(p=>p.committed).filter(x=>x>0).sort((a,b)=>a-b);
    const levels = [...new Set(commits)];
    const pots=[];
    let prev=0;
    for(const lvl of levels){
      const contribPlayers = players.filter(p=>p.committed>prev);
      const amount = contribPlayers.reduce((s,p)=> s + Math.min(p.committed, lvl) - Math.min(p.committed, prev), 0);
      pots.push({level:lvl, amount});
      prev=lvl;
    }
    // Log pots
    pots.forEach((p,i)=> logLine(`<i>Pot ${i+1}</i>: ${fmt(p.amount)} (level ${fmt(p.level)})`));
    return pots;
  }

  function awardPots(pots, winners){
    if(!winners || winners.length===0){ return; }
    const total = pots.reduce((s,p)=>s+p.amount,0);
    const share = total / winners.length;
    winners.forEach(w=>{
      w.stack += share;
      document.getElementById(`chips${w.id}`).textContent=fmt(w.stack);
      say(w.id, `Wins ${fmt(share)}`);
    });
    banner(winners.length>1?`Split pot ${fmt(share)} each`:`${winners[0].name} wins ${fmt(total)}`, 1500);
  }

  function endHand(){
    handActive=false; handsPlayed++; UI.handsTag.textContent=handsPlayed;
    UI.btn.showdown.disabled=true;
    setButtons();
    if(autoNext) setTimeout(()=>UI.btn.next.click(), 1100);
  }

  // ---------- Hand Evaluation ----------
  function evaluateBest7(cs){
    let best=null;
    const idx=[0,1,2,3,4,5,6];
    const combs = combinations(idx,5);
    for(const comb of combs){
      const five = comb.map(i=>cs[i]).sort((a,b)=>b.r-a.r || suitW(b.s)-suitW(a.s));
      const rank = eval5(five);
      if(!best || cmpRank(rank,best)>0) best=rank;
    }
    return best;
  }
  function combinations(arr,k){ const res=[]; const go=(s,a)=>{ if(a.length===k){res.push(a.slice());return;} for(let i=s;i<arr.length;i++) go(i+1,a.concat([arr[i]]));}; go(0,[]); return res; }
  function suitW(s){ return {'♣':0,'♦':1,'♥':2,'♠':3}[s]; }
  function straightHighVal(uniqDesc){
    if(uniqDesc.length<5) return 0;
    const v=uniqDesc.slice(); if(v.includes(14)) v.push(1);
    let run=1, best=0;
    for(let i=0;i<v.length-1;i++){
      if(v[i]-1===v[i+1]){ run++; best=Math.max(best, v[i+1]===1?5:v[i]); }
      else if(v[i]!==v[i+1]) run=1;
      if(run>=5) break;
    }
    return run>=5 ? best : 0;
  }
  function eval5(cs){
    const counts={}, suitCounts={}; const vals=cs.map(c=>c.r).sort((a,b)=>b-a);
    cs.forEach(c=>{ counts[c.r]=(counts[c.r]||0)+1; suitCounts[c.s]=(suitCounts[c.s]||0)+1; });
    let flushSuit=null; for(const s in suitCounts) if(suitCounts[s]===5) flushSuit=s;
    const uniq=[...new Set(vals)];
    const strHi = straightHighVal(uniq);

    if(flushSuit && strHi){
      const suited = cs.filter(c=>c.s===flushSuit).map(c=>c.r).sort((a,b)=>b-a);
      const uniqS=[...new Set(suited)];
      const sHigh=straightHighVal(uniqS);
      if(sHigh) return [9, sHigh, ...kickers(uniqS,5)];
    }
    const fours = Object.entries(counts).filter(([r,c])=>c===4).map(([r])=>+r).sort((a,b)=>b-a);
    if(fours.length){ const quad=fours[0]; const k=vals.find(v=>v!==quad); return [8, quad, k,0,0]; }
    const trips = Object.entries(counts).filter(([r,c])=>c===3).map(([r])=>+r).sort((a,b)=>b-a);
    const pairs = Object.entries(counts).filter(([r,c])=>c===2).map(([r])=>+r).sort((a,b)=>b-a);
    if(trips.length && (pairs.length || trips.length>1)){
      const t=trips[0]; const p=pairs.length?pairs[0]:trips[1]; return [7,t,p,0,0];
    }
    if(flushSuit) return [6, ...vals,0];
    if(strHi) return [5, strHi,0,0,0];
    if(trips.length){ const t=trips[0]; const k=vals.filter(v=>v!==t).slice(0,2); return [4,t,...k,0]; }
    if(pairs.length>=2){ const [p1,p2]=pairs.slice(0,2); const k=vals.find(v=>v!==p1 && v!==p2); return [3,Math.max(p1,p2),Math.min(p1,p2),k,0]; }
    if(pairs.length===1){ const p=pairs[0]; const k=vals.filter(v=>v!==p).slice(0,3); return [2,p,...k]; }
    return [1, ...vals];
  }
  function kickers(arr,n){ return arr.slice().sort((a,b)=>b-a).slice(0,n); }
  function cmpRank(a,b){ for(let i=0;i<Math.max(a.length,b.length);i++){ const d=(a[i]||0)-(b[i]||0); if(d!==0) return d>0?1:-1; } return 0; }

  // ---------- CPU ----------
  function preflopScore(h){ // rough 0..1
    const [A,B]=h.slice().sort((x,y)=>y.r-x.r);
    const suited = h[0].s===h[1].s;
    const gap = Math.abs(h[0].r - h[1].r)-1;
    const pair = A.r===B.r;
    let base = (A.r-1)/13 * 0.6 + (B.r-1)/13 * 0.3;
    if(pair) base = 0.7 + (A.r-2)/12 * 0.25;
    if(suited) base += 0.06;
    if(gap<=0) base += 0.05; else if(gap>=3) base -= 0.08*gap;
    const rc=A.r*100+B.r+(suited?1:0);
    if([1413,1412,1411,1312].some(x=>Math.abs(x-rc)<=1)) base=0.95;
    if(pair && A.r>=12) base=0.98;
    return Math.max(0,Math.min(1,base));
  }
  function postflopStrength(p){
    const r = evaluateBest7(p.hand.concat(community));
    return (r[0] + (r[1]/100)) / 10; // crude scalar
  }
  function cpuDecision(i){
    const p=players[i], delay=+UI.delay.value;
    return new Promise(res=>{
      setTimeout(()=>{
        const toCall = Math.max(0, currentBet - p.bet);
        let act={type:'check'};
        if(street==='pre'){
          const s = preflopScore(p.hand);
          if(toCall===0){
            if(s>=0.75){
              const add = Math.min(p.stack, Math.max(bigBlind*2.5, randInt(2,3)*bigBlind));
              act = {type: add>=p.stack?'allin':'bet', add};
            }else act={type:'check'};
          }else{
            if(s>=0.6){
              if(s>=0.82 && p.stack>toCall+bigBlind*3){
                act={type:'raise', add: Math.min(p.stack, bigBlind*3)};
              }else act={type:'call'};
            }else act={type: Math.random()<0.15?'call':'fold'};
          }
        }else{
          const s=postflopStrength(p);
          if(toCall===0){
            if(s>0.55){ const add=Math.min(p.stack, Math.max(bigBlind*2, Math.round(potTotal()*0.5*4)/4)); act={type:add>=p.stack?'allin':'bet', add}; }
            else act={type:'check'};
          }else{
            if(s>0.62){
              if(s>0.78 && p.stack>toCall+potTotal()*0.35){
                act={type:'raise', add: Math.min(p.stack, Math.max(bigBlind*3, Math.round(potTotal()*0.4*4)/4))};
              }else act={type:'call'};
            }else act={type: Math.random()<0.2?'call':'fold'};
          }
        }
        res(act);
      }, delay);
    });
  }

  // ---------- Controls ----------
  UI.btn.new.addEventListener('click', ()=>{ resetTable(); banner('New Table — Good luck!'); });
  UI.btn.next.addEventListener('click', ()=>{
    if(handActive) return;
    // Rotate dealer to next player with chips
    let tries=0;
    do { dealerIdx = (dealerIdx+1)%players.length; tries++; if(tries>6) break; } while(players[dealerIdx].stack<=0);
    renderSeats();
    startHand();
  });
  UI.btn.autoNext.addEventListener('click', ()=>{ autoNext=!autoNext; UI.btn.autoNext.textContent='Auto Next: '+(autoNext?'On':'Off'); });
  UI.btn.showdown.addEventListener('click', ()=>{ if(handActive) doShowdown(); });
  UI.btn.help.addEventListener('click', ()=> banner('Check/Call/Bet/Raise/Fold. Slider sets the extra chips you put in now.', 2200));

  UI.btn.check.addEventListener('click', ()=>{ if(toAct!==0) return; applyAction(0,'check',0); actLoop(); });
  UI.btn.call.addEventListener('click', ()=>{ if(toAct!==0) return; applyAction(0,'call',0); actLoop(); });
  UI.btn.bet.addEventListener('click', ()=>{
    if(toAct!==0) return;
    const add=parseFloat(UI.betSlider.value)||0;
    applyAction(0, currentBet===0?'bet':'raise', add);
    actLoop();
  });
  UI.btn.allin.addEventListener('click', ()=>{ if(toAct!==0) return; applyAction(0,'allin',players[0].stack); actLoop(); });
  UI.btn.fold.addEventListener('click', ()=>{ if(toAct!==0) return; applyAction(0,'fold',0); actLoop(); });

  UI.delay.addEventListener('input', ()=> setButtons());
  UI.betSlider.addEventListener('input', ()=> UI.betAmt.textContent = parseFloat(UI.betSlider.value).toFixed(2));

  // ---------- Init ----------
  resetTable();
  banner('Tap “Next Hand” to deal', 1400);
  setButtons();

})();
</script>
</body>
</html>