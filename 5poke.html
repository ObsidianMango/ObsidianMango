<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Texas Hold’em — Single-File, 6-Handed (You + 5 CPU)</title>
<style>
  :root{
    --bg:#0a0f14;
    --felt:#0e2d1b;
    --felt2:#154a28;
    --ink:#e8f3ec;
    --muted:#a9c3b2;
    --accent:#55ffc5;
    --accent2:#27d6ff;
    --warn:#ff8a65;
    --danger:#ff4d6d;
    --chip:#ffd166;
    --panel:#0f1720cc;
    --btn:#172635;
    --btnHi:#1e3954;
    --gold:#ffd54a;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;
    background:
      radial-gradient(1200px 800px at 70% -10%, #1a2e22 0%, transparent 60%),
      radial-gradient(900px 600px at 0% 100%, #13212a 0%, transparent 60%),
      linear-gradient(180deg, #090c10 0%, #0a1117 100%);
    color:var(--ink);
    overflow:hidden;
  }
  .app{
    display:grid;
    grid-template-rows:auto 1fr auto;
    height:100%;
    gap:10px;
  }
  header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 14px;
    background:linear-gradient(180deg,#0b141b 0%, #0a1218 100%);
    border-bottom:1px solid #0f2832;
  }
  header .bank{
    display:flex;gap:12px;flex-wrap:wrap;align-items:center;
  }
  .tag{padding:6px 10px;border:1px solid #1a3542;border-radius:10px;background:#0c1a22;color:var(--muted);font-size:12px}
  .tag strong{color:var(--ink)}
  .title{
    letter-spacing:.5px;font-weight:700;font-size:14px;color:var(--muted)
  }

  /* TABLE */
  .tableWrap{
    position:relative;
    padding:14px;
    display:grid;place-items:center;
  }
  .table{
    position:relative;
    width:min(1100px, 96vw);
    aspect-ratio: 16/9;
    border-radius:32px;
    background:
      radial-gradient(120% 120% at 50% 50%, var(--felt2) 0%, var(--felt) 60%, #0a1510 100%);
    box-shadow:
      inset 0 0 0 3px #113c2a,
      inset 0 0 40px #0b1f15,
      0 20px 60px #0009;
    overflow:visible;
  }
  .rail{
    position:absolute;inset:-18px;
    border-radius:40px;
    background:
      linear-gradient(180deg,#3a2412,#1e1209 70%);
    box-shadow:
      inset 0 4px 14px #0008,
      0 10px 30px #0008;
  }
  .pot{
    position:absolute;left:50%;top:50%;
    transform:translate(-50%,-30%);
    background:#0c1a22e6;border:1px solid #153241;backdrop-filter:blur(6px);
    padding:6px 10px;border-radius:10px;font-size:13px;color:var(--gold);
    box-shadow:0 4px 18px #0006;
  }
  .community{
    position:absolute;left:50%;top:50%;
    transform:translate(-50%,-10%);
    display:flex;gap:8px;align-items:center;justify-content:center;
  }
  .players{
    position:absolute;inset:0;pointer-events:none;
  }

  /* PLAYER SEATS */
  .seat{
    position:absolute;width:220px;display:grid;gap:6px;justify-items:center;
  }
  .seat .name{
    font-size:13px;color:var(--muted);background:#0c1a22cc;border:1px solid #153241;border-radius:10px;padding:4px 8px
  }
  .seat .chips{
    font-size:12px;color:var(--chip);
  }
  .seat .status{
    min-height:16px;font-size:12px;color:var(--muted)
  }
  .dealerBtn{
    position:absolute;transform:translate(-50%,-50%);
    width:26px;height:26px;border-radius:50%;
    background:#f2f2f2;color:#111;display:grid;place-items:center;
    font-size:11px;font-weight:800;border:2px solid #dedede;box-shadow:0 2px 6px #0007
  }

  /* CARDS */
  .card{
    width:64px;height:92px;border-radius:10px;background:#e6f3f0;
    border:2px solid #cfe3dc;box-shadow:0 6px 20px #0008;
    position:relative;
    display:grid;place-items:center;
    font-weight:700;color:#0a1012;
    user-select:none;
  }
  .card.small{width:54px;height:78px;border-radius:8px}
  .card.back{
    background:
      repeating-linear-gradient(45deg, #122a3a 0 8px, #0e2230 8px 16px);
    border-color:#2a5c74;color:transparent;
  }
  .pip{font-size:20px}
  .suit{font-size:12px;opacity:.85}
  .♥, .♦{color:#ce1b45}
  .♣, .♠{color:#0b1d2b}

  .hand{
    display:flex;gap:8px;align-items:center;justify-content:center;
  }
  .seat .hand{pointer-events:none}

  .me{
    position:absolute;left:50%;bottom:-10px;transform:translateX(-50%);width:400px
  }
  .me .hand .card{transform:translateY(-6px)}
  .glow{box-shadow:0 0 0 2px var(--accent2), 0 0 26px var(--accent2) !important}

  /* CONTROLS */
  .controls{
    display:grid;gap:8px;padding:10px;
    grid-template-columns:1fr;
    background:linear-gradient(180deg,#0b141b,#091219);
    border-top:1px solid #0f2832;
  }
  .controlRow{
    display:grid;grid-template-columns:1fr auto;gap:8px;align-items:center
  }
  .buttons{display:flex;gap:8px;flex-wrap:wrap}
  button{
    -webkit-tap-highlight-color:transparent;
    background:var(--btn);color:#e8f3ec;border:1px solid #254456;
    border-radius:12px;padding:12px 14px;font-weight:700;font-size:15px;
    box-shadow:inset 0 -2px 0 #0a1620, 0 2px 8px #0008;
    cursor:pointer
  }
  button:hover{background:var(--btnHi)}
  button.primary{border-color:#1e6f86;box-shadow:inset 0 -2px 0 #0d2a33,0 4px 14px #0008}
  button.warn{border-color:#6a2a1b;background:#2a1611}
  button.danger{border-color:#7a1d2f;background:#2a0f16}
  button:disabled{opacity:.45;cursor:not-allowed}
  .sliderRow{display:flex;align-items:center;gap:10px}
  input[type="range"]{width:100%}
  .betAmt{min-width:88px;text-align:right;font-variant-numeric:tabular-nums}
  .log{
    height:120px;overflow:auto;background:#081017;border:1px solid #0e2230;border-radius:12px;padding:8px;font-size:12px;color:var(--muted)
  }

  .topPanel{
    position:absolute;right:10px;top:10px;display:flex;gap:8px;z-index:5
  }
  .pill{
    background:#0c1a22cc;border:1px solid #153241;color:var(--muted);
    border-radius:999px;padding:6px 10px;font-size:12px
  }
  .rangeBox{
    display:flex;gap:8px;align-items:center;justify-content:flex-end;flex-wrap:wrap
  }
  .think{
    width:9px;height:9px;border-radius:50%;background:#263a46;box-shadow:0 0 0 0 #263a46;animation:pulse 1.6s infinite
  }
  @keyframes pulse{
    0%{box-shadow:0 0 0 0 rgba(39,214,255,.6)}
    70%{box-shadow:0 0 0 8px rgba(39,214,255,0)}
    100%{box-shadow:0 0 0 0 rgba(39,214,255,0)}
  }
  .toast{
    position:absolute;left:50%;top:6%;transform:translateX(-50%);
    background:#0c1a22e6;border:1px solid #153241;backdrop-filter:blur(6px);
    padding:10px 14px;border-radius:12px;color:var(--ink);font-weight:700;box-shadow:0 8px 24px #000a
  }

  /* Responsive tweaks */
  @media (max-width:900px){
    .seat{width:180px}
    .card{width:56px;height:82px}
    .card.small{width:48px;height:70px}
    .me{width:360px}
  }
  @media (max-width:700px){
    .seat{width:150px}
    .card{width:50px;height:74px}
    .card.small{width:44px;height:64px}
    .me{width:320px}
  }
</style>
</head>
<body>
<div class="app">
  <header>
    <div class="title">Texas Hold’em — 6-Handed (You + 5 CPU)</div>
    <div class="bank">
      <div class="tag">Stacks: <strong id="stacksTag">$—</strong></div>
      <div class="tag">Blinds: <strong id="blindsTag">0.25 / 0.50</strong></div>
      <div class="tag">Level: <strong id="levelTag">1</strong></div>
      <div class="tag">Hands Played: <strong id="handsTag">0</strong></div>
    </div>
  </header>

  <div class="tableWrap">
    <div class="table" id="table">
      <div class="rail"></div>
      <div class="topPanel">
        <div class="pill">Bot delay
          <span class="rangeBox">
            <input id="delay" type="range" min="200" max="1600" step="100" value="700">
            <span id="delayLbl" class="muted">700ms</span>
          </span>
        </div>
        <div class="pill">Speed: <span id="speedLbl">Normal</span></div>
      </div>
      <div class="toast" id="toast" style="display:none"></div>
      <div class="pot" id="potBox">Pot: $0.00</div>
      <div class="community" id="community"></div>
      <div class="players" id="players"></div>

      <!-- My seat UI (cards sit visually near bottom) -->
      <div class="seat me" id="meSeat">
        <div class="name" id="meName">You</div>
        <div class="hand" id="meHand"></div>
        <div class="chips" id="meChips">$50.00</div>
        <div class="status" id="meStatus"></div>
      </div>
    </div>
  </div>

  <div class="controls">
    <div class="controlRow">
      <div class="buttons">
        <button id="newGame" class="primary">New Table ($50 stacks)</button>
        <button id="nextHand">Next Hand</button>
        <button id="showdown" class="">Showdown</button>
        <button id="autoNext">Auto Next: Off</button>
      </div>
      <div class="buttons">
        <button id="helpBtn">?</button>
      </div>
    </div>

    <div class="controlRow">
      <div class="buttons">
        <button id="checkBtn">Check</button>
        <button id="callBtn" class="primary">Call</button>
        <button id="betBtn">Bet/Raise</button>
        <button id="allinBtn" class="warn">All-In</button>
        <button id="foldBtn" class="danger">Fold</button>
      </div>
      <div class="sliderRow">
        <span>Bet: $</span>
        <input id="betSlider" type="range" min="0" max="50" step="0.25" value="1">
        <span id="betAmt" class="betAmt">1.00</span>
      </div>
    </div>

    <div class="log" id="log"></div>
  </div>
</div>

<script>
(() => {
  const $ = sel => document.querySelector(sel);
  const $$ = sel => Array.from(document.querySelectorAll(sel));
  const fmt = n => (n<0?'-$':'$') + Math.abs(n).toFixed(2);
  const suits = ["♣","♦","♥","♠"];
  const ranks = [2,3,4,5,6,7,8,9,10,11,12,13,14]; // 11=J,12=Q,13=K,14=A

  const startStack = 50;
  let smallBlind = 0.25, bigBlind = 0.50;
  let level = 1, handsPlayed = 0;
  let autoNext = false;

  // Game state
  let players = []; // array of seat objects {id,name,stack,hand,folded,allin,bid,seatPos,isHuman}
  let deck = [];
  let dealerIndex = 0; // dealer button (rotates each hand)
  let pot = 0;
  let community = []; // flop/turn/river
  let street = 'pre'; // pre, flop, turn, river, showdown
  let toAct = -1; // index of player whose turn it is
  let minRaiseTo = 0; // current minimum legal raise amount (total bet amount, not increment)
  let currentBet = 0; // highest bid this street
  let lastAggressor = -1;
  let handActive = false;
  let thinking = false;

  // UI refs
  const potBox = $('#potBox'), commBox = $('#community'), playersBox = $('#players'),
        meHand = $('#meHand'), meChips = $('#meChips'), meStatus = $('#meStatus'),
        stacksTag = $('#stacksTag'), blindsTag = $('#blindsTag'), levelTag = $('#levelTag'), handsTag = $('#handsTag'),
        betSlider = $('#betSlider'), betAmt = $('#betAmt'), delayInput = $('#delay'),
        delayLbl = $('#delayLbl'), speedLbl = $('#speedLbl'),
        logBox = $('#log'), toast = $('#toast');

  const btn = {
    new: $('#newGame'),
    next: $('#nextHand'),
    showdown: $('#showdown'),
    autoNext: $('#autoNext'),
    check: $('#checkBtn'),
    call: $('#callBtn'),
    bet: $('#betBtn'),
    allin: $('#allinBtn'),
    fold: $('#foldBtn'),
    help: $('#helpBtn')
  };

  function log(msg){
    const line = document.createElement('div');
    line.innerHTML = msg;
    logBox.appendChild(line);
    logBox.scrollTop = logBox.scrollHeight;
  }
  function banner(msg, ms=1200){
    toast.textContent = msg; toast.style.display='block';
    setTimeout(()=> toast.style.display='none', ms);
  }

  function freshDeck(){
    deck = [];
    for (let s=0;s<4;s++) for (let r=0;r<ranks.length;r++) deck.push({r:ranks[r], s:suits[s]});
    // shuffle
    for (let i=deck.length-1;i>0;i--){
      const j = (Math.random()* (i+1))|0;
      [deck[i],deck[j]]=[deck[j],deck[i]];
    }
  }
  const cardEl = (c, small=false, back=false) => {
    const d = document.createElement('div');
    d.className = 'card'+(small?' small':'')+(back?' back':'');
    if(!back){
      const pip = (c.r===14?'A':c.r===13?'K':c.r===12?'Q':c.r===11?'J':c.r);
      d.innerHTML = `<div class="pip ${c.s}">${pip}</div><div class="suit ${c.s}">${c.s}</div>`;
    }
    return d;
  }

  function resetSeats(){
    players = [];
    const names = ["You","Bot A","Bot B","Bot C","Bot D","Bot E"];
    for(let i=0;i<6;i++){
      players.push({
        id:i,
        name:names[i],
        stack:startStack,
        hand:[],
        folded:false,
        allin:false,
        bid:0,
        seatPos:i,
        isHuman: i===0
      });
    }
    dealerIndex = 0;
    updateHeader();
    renderSeats();
  }

  function updateHeader(){
    stacksTag.textContent = players.map(p=>`${p.name==='You'?'You':p.name}:${fmt(p.stack)}`).join('  ');
    blindsTag.textContent = `${smallBlind.toFixed(2)} / ${bigBlind.toFixed(2)}`;
    levelTag.textContent = level;
    handsTag.textContent = handsPlayed;
  }

  function renderSeats(){
    playersBox.innerHTML = '';
    const rect = $('#table').getBoundingClientRect();
    // positions (percentages) around oval
    const pos = [
      {x:50,y:96},   // You (bottom center)
      {x:85,y:75},
      {x:85,y:28},
      {x:50,y:8},
      {x:15,y:28},
      {x:15,y:75}
    ];
    players.forEach((p,i)=>{
      const seat = document.createElement('div');
      seat.className = 'seat';
      seat.style.left = `calc(${pos[i].x}% - 110px)`;
      seat.style.top  = `calc(${pos[i].y}% - 46px)`;
      seat.id = `seat${i}`;

      const name = document.createElement('div');
      name.className = 'name';
      name.textContent = p.name + (i===dealerIndex?' (D)':'');
      name.id = `name${i}`;

      const hand = document.createElement('div');
      hand.className = 'hand';
      hand.id = `hand${i}`;

      const chips = document.createElement('div');
      chips.className = 'chips';
      chips.id = `chips${i}`;
      chips.textContent = fmt(p.stack);

      const status = document.createElement('div');
      status.className = 'status';
      status.id = `status${i}`;
      status.textContent = '';

      seat.appendChild(name);
      seat.appendChild(hand);
      seat.appendChild(chips);
      seat.appendChild(status);
      playersBox.appendChild(seat);

      // Dealer button
      if(i===dealerIndex){
        const btn = document.createElement('div');
        btn.className='dealerBtn';
        btn.style.left = pos[i].x+'%';
        btn.style.top = (pos[i].y-7)+'%';
        btn.textContent='D';
        playersBox.appendChild(btn);
      }
    });

    // My bottom cards render area mirrors seat0
    meHand.innerHTML='';
    meChips.textContent = fmt(players[0].stack);
  }

  function clearTable(){
    community = [];
    commBox.innerHTML='';
    pot = 0;
    potBox.textContent = 'Pot: $0.00';
    players.forEach(p=>{
      p.hand=[];p.folded=false;p.allin=false;p.bid=0;
      qs(`#status${p.id}`).textContent='';
      qs(`#hand${p.id}`).innerHTML='';
      if(!p.isHuman){
        // hide bot hole cards (backs) pre-deal
      }
    });
    meStatus.textContent='';
    meHand.innerHTML='';
  }

  function qs(id){ return document.getElementById(id.replace('#','')); }

  function dealHoleCards(){
    for(let r=0;r<2;r++){
      for(let i=0;i<players.length;i++){
        const p = players[(dealerIndex+1+i)%players.length];
        if(p.stack<=0) { p.folded=true; continue; }
        p.hand.push(deck.pop());
      }
    }
    // Render: show your cards, bots face down
    players.forEach(p=>{
      const el = qs(`#hand${p.id}`);
      el.innerHTML='';
      if(p.isHuman){
        p.hand.forEach(c=> el.appendChild(cardEl(c)));
        meHand.innerHTML = '';
        p.hand.forEach(c=> meHand.appendChild(cardEl(c)));
        meHand.querySelectorAll('.card').forEach(x=>x.classList.add('glow'));
      }else{
        el.appendChild(cardEl({},true,true));
        el.appendChild(cardEl({},true,true));
      }
    });
  }

  function postBlinds(){
    const sb = nextActive(dealerIndex);
    const bb = nextActive(sb);
    takeToPot(sb, Math.min(players[sb].stack, smallBlind));
    takeToPot(bb, Math.min(players[bb].stack, bigBlind));
    currentBet = Math.min(players[bb].bid, bigBlind);
    minRaiseTo = currentBet + bigBlind; // first raise must be to at least 2x bb
    lastAggressor = bb;

    say(sb, `SB ${fmt(smallBlind)}`);
    say(bb, `BB ${fmt(bigBlind)}`);
    toAct = nextActive(bb);
    updateHeader();
  }

  function takeToPot(i, amt){
    const p = players[i];
    const pay = Math.min(amt, p.stack);
    p.stack -= pay;
    p.bid += pay;
    pot += pay;
    qs(`#chips${i}`).textContent = fmt(p.stack);
    potBox.textContent = 'Pot: ' + fmt(pot);
  }

  function nextActive(from){
    for(let k=1;k<=players.length;k++){
      const i = (from + k) % players.length;
      const p = players[i];
      if(!p.folded && p.stack + p.bid > 0) return i;
    }
    return from;
  }

  function everyoneActedOrAllIn(){
    // Betting round ends when all bets equalized and no action pending (or only one player remains)
    const live = players.filter(p=>!p.folded && (p.stack>0 || p.bid>0));
    if(live.length<=1) return true;
    const maxBid = Math.max(...players.map(p=>p.folded?0:p.bid));
    const needAction = players.some((p,i)=>{
      if(p.folded || p.allin) return false;
      if(p.bid < maxBid) return true;
      // if p was last aggressor and everyone else matched, action can end once it returns (handled by equalization check)
      return false;
    });
    return !needAction;
  }

  function startHand(){
    handActive = true;
    street = 'pre';
    clearTable();
    freshDeck();
    dealHoleCards();
    postBlinds();
    updateActions();
    actLoop();
  }

  function actLoop(){
    if(!handActive) return;
    if(everyoneActedOrAllIn()){
      // advance street or showdown
      advanceStreet();
      return;
    }
    const i = toAct;
    const p = players[i];
    highlightToAct(i);
    if(p.isHuman || p.folded || p.allin){ updateActions(); return; }
    // CPU turn
    thinking = true;
    setButtonsEnabled(false);
    const delay = +delayInput.value;
    cpuDecide(i).then(action=>{
      thinking = false;
      doAction(i, action.type, action.amount || 0);
      setTimeout(actLoop, 120); // small tick
    });
  }

  function highlightToAct(i){
    players.forEach(pp=>{
      const el = qs(`#name${pp.id}`);
      el.style.outline = '';
    });
    const el = qs(`#name${i}`);
    if(el) el.style.outline = '2px solid #27d6ff';
  }

  function setButtonsEnabled(on){
    [btn.check, btn.call, btn.bet, btn.allin, btn.fold].forEach(b=> b.disabled = !on);
  }

  function updateActions(){
    const me = players[0];
    const maxBid = Math.max(...players.map(p=>p.bid));
    const toCall = Math.max(0, maxBid - me.bid);
    const canCheck = toCall===0;
    btn.check.disabled = !(toAct===0 && canCheck && handActive && !thinking && !me.allin && !me.folded);
    btn.call.disabled  = !(toAct===0 && !canCheck && handActive && !thinking && !me.allin && !me.folded && me.stack>0);
    btn.fold.disabled  = !(toAct===0 && handActive && !thinking && !me.allin && !me.folded);
    btn.bet.disabled   = !(toAct===0 && handActive && !thinking && !me.allin && !me.folded && me.stack>0);
    btn.allin.disabled = !(toAct===0 && handActive && !thinking && !me.allin && !me.folded && me.stack>0);

    // Slider bounds: min raise is either bigBlind (if unopened) or (current raise increment)
    let minTo = canCheck ? Math.max(bigBlind, currentBet) : Math.max(currentBet, maxBid) + Math.max(bigBlind, currentBet - maxBid + bigBlind);
    if(currentBet===0) minTo = Math.max(bigBlind, minRaiseTo);
    const maxTo = me.stack + me.bid; // total commitment cap
    // Ensure min slider is at least toCall + small increment
    const minRaiseAbs = Math.min(maxTo, Math.max(minRaiseTo, Math.max(bigBlind, currentBet*1 || bigBlind*2)));
    betSlider.min = Math.max(toCall + 0.25, Math.min(minRaiseAbs - me.bid, me.stack)).toFixed(2);
    betSlider.max = Math.max(0.25, me.stack).toFixed(2);
    if(+betSlider.min > +betSlider.max){ betSlider.min = betSlider.max; }
    if(+betSlider.value < +betSlider.min) betSlider.value = betSlider.min;
    betAmt.textContent = parseFloat(betSlider.value).toFixed(2);

    // Labels
    $('#delayLbl').textContent = delayInput.value+'ms';
    const sp = +delayInput.value;
    speedLbl.textContent = sp<500?'Fast':sp>1200?'Leisurely':'Normal';
  }

  function doAction(i, type, amount){
    const p = players[i];
    if(p.folded || p.allin) { toAct = nextActive(i); return; }
    const maxBid = Math.max(...players.map(pl=>pl.bid));
    const toCall = Math.max(0, maxBid - p.bid);
    let sayMsg = '';
    if(type==='fold'){
      p.folded = true; sayMsg = 'Folds';
    }else if(type==='check'){
      if(toCall>0){ // cannot check
        // treat as call safety
        type='call';
      }else{
        sayMsg = 'Checks';
      }
    }
    if(type==='call'){
      const callAmt = Math.min(toCall, p.stack);
      takeToPot(i, callAmt);
      sayMsg = `Calls ${fmt(callAmt)}`;
      if(p.stack===0) p.allin = true;
    }else if(type==='bet' || type==='raise' || type==='allin'){
      let commit;
      if(type==='allin'){
        commit = p.stack; // push all remaining
      }else{
        // amount is the ADDITION to current bid (not total); we interpret slider as additional commit
        commit = Math.min(p.stack, Math.max(0, amount));
      }
      const targetBid = p.bid + commit;
      const newBet = targetBid;

      // Validate min raise if raising over maxBid
      if(newBet <= maxBid){
        // treat as call up to maxBid
        const need = Math.min(p.stack, maxBid - p.bid);
        takeToPot(i, need);
        sayMsg = `Calls ${fmt(need)}`;
      }else{
        const raiseTo = newBet;
        // min raise rule
        const minRaiseAbs = Math.max(minRaiseTo, currentBet===0 ? bigBlind*2 : currentBet + (currentBet - (maxBid - (p.bid)) || bigBlind));
        const minToMeet = Math.max(maxBid + bigBlind, minRaiseAbs);
        if(raiseTo < minToMeet && raiseTo < p.stack + p.bid){
          // bump up to minToMeet if possible, else all-in
          const desired = Math.min(p.stack, minToMeet - p.bid);
          takeToPot(i, desired);
          sayMsg = `Raises to ${fmt(p.bid)}`;
          currentBet = Math.max(currentBet, p.bid);
          minRaiseTo = currentBet + Math.max(bigBlind, currentBet - maxBid);
          lastAggressor = i;
        }else{
          takeToPot(i, commit);
          sayMsg = p.stack===0 ? `All-in ${fmt(p.bid)}` : `Raises to ${fmt(p.bid)}`;
          currentBet = Math.max(currentBet, p.bid);
          minRaiseTo = currentBet + Math.max(bigBlind, currentBet - maxBid);
          lastAggressor = i;
        }
        if(p.stack===0) p.allin = true;
      }
    }

    say(i, sayMsg);
    toAct = nextActive(i);
    updateActions();

    // If only one player remains, immediate showdown
    const live = players.filter(pl=>!pl.folded);
    if(live.length===1){ showdown(true); }
  }

  function say(i, msg){
    const el = qs(`#status${i}`);
    el.textContent = msg;
    if(players[i].isHuman) meStatus.textContent = msg;
    log(`<b>${players[i].name}</b>: ${msg}`);
  }

  function collectBids(){
    // (already added to pot as we go)
    players.forEach(p=> p.bid=0);
    currentBet = 0;
    minRaiseTo = bigBlind*2;
  }

  function advanceStreet(){
    // if some street ended pre because all-in+calls and community not complete, go straight to showdown after dealing all streets
    if(street==='pre'){
      // deal flop
      community = [deck.pop(), deck.pop(), deck.pop()];
      renderCommunity();
      collectBids();
      street='flop';
      banner('Flop');
      startBettingRound();
    }else if(street==='flop'){
      community.push(deck.pop());
      renderCommunity();
      collectBids();
      street='turn';
      banner('Turn');
      startBettingRound();
    }else if(street==='turn'){
      community.push(deck.pop());
      renderCommunity();
      collectBids();
      street='river';
      banner('River');
      startBettingRound();
    }else if(street==='river'){
      showdown(false);
    }
  }

  function startBettingRound(){
    // set first to act: next active from dealer (on flop/turn/river) or from BB on pre was already set
    if(street!=='pre'){
      toAct = nextActive(dealerIndex);
      players.forEach(p=> qs(`#status${p.id}`).textContent=''); // clear statuses for new street
    }
    actLoop();
  }

  function renderCommunity(){
    commBox.innerHTML='';
    community.forEach(c=> commBox.appendChild(cardEl(c)));
  }

  function showdown(early){
    street='showdown';
    // Reveal bot hole cards
    players.forEach(p=>{
      const h = qs(`#hand${p.id}`);
      if(!p.isHuman && !p.folded){
        h.innerHTML='';
        p.hand.forEach(c=> h.appendChild(cardEl(c,true,false)));
      }
    });
    // Evaluate hands of live players
    const live = players.filter(p=>!p.folded);
    if(live.length===0){
      // edge case: everyone folded? Pot stays? Give to last aggressor or the only not-folded previously.
      const last = players.find(p=>!p.folded===true) || players[lastAggressor] || players[0];
      award([last]);
      return;
    }
    const results = live.map(p=>({p, rank:evaluateBest7(p.hand.concat(community))}));
    results.sort((a,b)=>cmpRank(b.rank,a.rank));
    // find ties
    const best = results[0].rank;
    const winners = results.filter(r=>cmpRank(r.rank,best)===0).map(r=>r.p);
    showRankLines(results);
    award(winners);
    handActive=false;
    handsPlayed++;
    updateHeader();
    btn.showdown.disabled = true;
    if(autoNext) setTimeout(()=>btn.next.click(), 1200);
  }

  function showRankLines(results){
    results.forEach(r=>{
      const line = `${r.p.name}: ${rankLabel(r.rank)} ${cardsText(r.p.hand)} ${community.length?` | Board ${cardsText(community)}`:''}`;
      log(line);
    });
  }
  function cardsText(cs){
    return cs.map(c=>`${rankChar(c.r)}${c.s}`).join(' ');
  }
  function rankChar(r){ return r===14?'A':r===13?'K':r===12?'Q':r===11?'J':r; }

  function award(winners){
    const share = pot / winners.length;
    winners.forEach(w=>{
      w.stack += share;
      qs(`#chips${w.id}`).textContent = fmt(w.stack);
      say(w.id, `Wins ${fmt(share)}`);
    });
    banner(winners.length>1?`Split pot ${fmt(share)} each`:`${winners[0].name} wins ${fmt(pot)}`, 1500);
    pot=0; potBox.textContent='Pot: $0.00';
  }

  // ======= Hand Evaluation (7 -> best 5) =======
  // Rank format: [primary, kick1, kick2, kick3, kick4, tiebreak]
  // primary codes: 9=StraightFlush,8=Quads,7=FullHouse,6=Flush,5=Straight,4=Trips,3=TwoPair,2=OnePair,1=HighCard
  function evaluateBest7(cs){
    // choose best of C(7,5)=21
    const idx=[0,1,2,3,4,5,6];
    let best=null;
    const combs = combinations(idx,5);
    for(const comb of combs){
      const five = comb.map(i=>cs[i]).sort((a,b)=>b.r-a.r || suitWeight(b.s)-suitWeight(a.s));
      const rank = eval5(five);
      if(!best || cmpRank(rank,best)>0) best=rank;
    }
    return best;
  }
  function suitWeight(s){ return {'♣':0,'♦':1,'♥':2,'♠':3}[s]; }
  function combinations(arr,k){
    const res=[];
    const go=(start,acc)=>{
      if(acc.length===k){res.push(acc.slice());return;}
      for(let i=start;i<arr.length;i++) go(i+1, acc.concat([arr[i]]));
    }; go(0,[]);
    return res;
  }
  function eval5(cs){
    const counts = {};
    const suitCounts = {};
    const vals = cs.map(c=>c.r).sort((a,b)=>b-a);
    cs.forEach(c=> {
      counts[c.r]=(counts[c.r]||0)+1;
      suitCounts[c.s]=(suitCounts[c.s]||0)+1;
    });
    // Flush?
    let flushSuit = null; for(const s in suitCounts) if(suitCounts[s]===5) flushSuit = s;
    // Straight?
    const uniq = [...new Set(vals)];
    let straightHigh = straightHighVal(uniq);

    if(flushSuit && straightHigh){
      // confirm straight flush: check if the straight cards are same suit
      const suited = cs.filter(c=>c.s===flushSuit).map(c=>c.r).sort((a,b)=>b-a);
      const uniqS = [...new Set(suited)];
      const sHigh = straightHighVal(uniqS);
      if(sHigh) return [9, sHigh, highKickers(uniqS,5)]; // 9 = straight flush
    }

    // Four of a kind?
    const fours = Object.entries(counts).filter(([r,c])=>c===4).map(([r])=>+r).sort((a,b)=>b-a);
    if(fours.length){
      const quad = fours[0];
      const kicker = vals.find(v=>v!==quad);
      return [8, quad, kicker,0,0];
    }
    // Full house?
    const trips = Object.entries(counts).filter(([r,c])=>c===3).map(([r])=>+r).sort((a,b)=>b-a);
    const pairs = Object.entries(counts).filter(([r,c])=>c===2).map(([r])=>+r).sort((a,b)=>b-a);
    if(trips.length && (pairs.length || trips.length>1)){
      const t = trips[0];
      const p = pairs.length? pairs[0] : trips[1];
      return [7, t, p,0,0];
    }
    if(flushSuit){
      // flush: rank by top 5 kickers (already 5)
      return [6, ...vals,0];
    }
    if(straightHigh){
      return [5, straightHigh,0,0,0];
    }
    if(trips.length){
      const t = trips[0];
      const kick = vals.filter(v=>v!==t).slice(0,2);
      return [4, t, ...kick,0];
    }
    if(pairs.length>=2){
      const [p1,p2] = pairs.slice(0,2);
      const kick = vals.filter(v=>v!==p1 && v!==p2)[0];
      return [3, Math.max(p1,p2), Math.min(p1,p2), kick,0];
    }
    if(pairs.length===1){
      const p = pairs[0];
      const kick = vals.filter(v=>v!==p).slice(0,3);
      return [2, p, ...kick];
    }
    return [1, ...vals];
  }
  function straightHighVal(uniqDesc){
    // handle wheel A-5: treat Ace as 1
    if(uniqDesc.length<5) return 0;
    const v = uniqDesc.slice();
    // include A as 1
    if(v.includes(14)) v.push(1);
    let run=1, best=0;
    for(let i=0;i<v.length-1;i++){
      if(v[i]-1===v[i+1]) { run++; best=Math.max(best, v[i+1]===1?5:v[i]); }
      else if(v[i]!==v[i+1]) run=1;
      if(run>=5) break;
    }
    return run>=5 ? best : 0;
  }
  function highKickers(arr,n){
    const a=arr.slice().sort((a,b)=>b-a); return a.slice(0,n);
  }
  function cmpRank(a,b){
    for(let i=0;i<Math.max(a.length,b.length);i++){
      const d=(a[i]||0)-(b[i]||0);
      if(d!==0) return d>0?1:-1;
    }
    return 0;
  }
  function rankLabel(rank){
    const code = rank[0];
    const map={
      9:'Straight Flush',8:'Four of a Kind',7:'Full House',6:'Flush',5:'Straight',4:'Three of a Kind',3:'Two Pair',2:'One Pair',1:'High Card'
    };
    return map[code] || 'Hand';
  }

  // ======= CPU Logic (simple but not braindead) =======
  function cpuDecide(i){
    const p = players[i];
    const delay = +delayInput.value;
    return new Promise((resolve)=>{
      setTimeout(()=>{
        // very basic heuristic: preflop strength & postflop made-hand rank
        const maxBid = Math.max(...players.map(pl=>pl.bid));
        const toCall = Math.max(0, maxBid - p.bid);
        const holes = p.hand;
        let action = {type:'check'};
        if(street==='pre'){
          const str = preflopScore(holes);
          if(toCall===0){
            if(str>=0.75 && p.stack>0){ // open raise
              const raise = Math.min(p.stack, Math.max(bigBlind*3, currentBet===0?bigBlind*2:bigBlind*2.5));
              action = {type: raise>=p.stack ? 'allin':'bet', amount: raise};
            }else{
              action = {type:'check'};
            }
          }else{ // facing bet
            if(str>=0.6){
              // call or raise if strong
              if(str>=0.82 && p.stack>toCall+bigBlind*3){
                action = {type:'raise', amount: Math.min(p.stack, toCall + bigBlind*3)};
              }else{
                action = {type:'call'};
              }
            }else{
              action = {type: Math.random()<0.12?'call':'fold'};
            }
          }
        }else{
          // postflop rank
          const rank = evaluateBest7(p.hand.concat(community));
          const strength = (rank[0] + (rank[1]/100)) / 10; // crude
          if(toCall===0){
            if(strength>0.55){
              const siz = Math.min(p.stack, Math.max(bigBlind*2, pot*0.5));
              action = {type: siz>=p.stack?'allin':'bet', amount: siz};
            }else{
              action = {type:'check'};
            }
          }else{
            if(strength>0.62){ // call more
              if(strength>0.78 && p.stack>toCall+pot*0.4){
                action={type:'raise', amount: Math.min(p.stack, toCall + Math.max(bigBlind*3,pot*0.4))};
              }else{
                action={type:'call'};
              }
            }else{
              action = {type: Math.random()<0.2?'call':'fold'};
            }
          }
        }
        resolve(action);
      }, delay);
    });
  }

  function preflopScore(h){ // 0..1 rough chart
    const [a,b] = h.slice().sort((x,y)=>y.r-x.r);
    const suited = h[0].s===h[1].s;
    const gap = Math.abs(h[0].r - h[1].r)-1;
    const pair = a.r===b.r;
    let base = (a.r-1)/13 * 0.6 + (b.r-1)/13 * 0.3;
    if(pair) base = 0.7 + (a.r-2)/12 * 0.25;
    if(suited) base += 0.06;
    if(gap<=0) base += 0.05;
    else if(gap>=3) base -= 0.08*gap;
    // premiums
    const rc = a.r*100+b.r+(suited?1:0);
    if([1413,1412,1411,1312].some(x=>closeRC(rc,x))) base = 0.95; // AK, AQ, AJ, KQ
    if(pair && a.r>=12) base = 0.98; // QQ+
    return Math.max(0, Math.min(1, base));
  }
  function closeRC(a,b){ return Math.abs(a-b)<=1; }

  // ======= Controls =======
  btn.new.addEventListener('click', ()=>{
    resetSeats();
    handsPlayed=0; level=1; smallBlind=0.25; bigBlind=0.50;
    logBox.innerHTML='';
    banner('New Table — Good luck!');
    btn.showdown.disabled=true;
    handActive=false;
    updateHeader();
  });

  btn.next.addEventListener('click', ()=>{
    if(handActive) return;
    // rotate dealer
    dealerIndex = nextActive(dealerIndex-1>=0?dealerIndex-1:players.length-1);
    // remove busted players from actionability
    players.forEach(p=>{ if(p.stack<=0){ p.folded=true; }});
    renderSeats();
    startHand();
    btn.showdown.disabled=false;
  });

  btn.autoNext.addEventListener('click', ()=>{
    autoNext = !autoNext;
    btn.autoNext.textContent = 'Auto Next: ' + (autoNext?'On':'Off');
  });

  btn.showdown.addEventListener('click', ()=>{
    if(!handActive) return;
    // force equalization (everyone calls current max) by pushing all-in if needed (for simplicity)
    showdown(false);
  });

  btn.check.addEventListener('click', ()=> {
    if(toAct!==0) return;
    doAction(0,'check',0);
    actLoop();
  });
  btn.call.addEventListener('click', ()=> {
    if(toAct!==0) return;
    doAction(0,'call',0);
    actLoop();
  });
  btn.bet.addEventListener('click', ()=> {
    if(toAct!==0) return;
    const amt = parseFloat(betSlider.value);
    if(!isFinite(amt) || amt<=0) return;
    doAction(0, currentBet===0?'bet':'raise', amt);
    actLoop();
  });
  btn.allin.addEventListener('click', ()=> {
    if(toAct!==0) return;
    doAction(0,'allin', players[0].stack);
    actLoop();
  });
  btn.fold.addEventListener('click', ()=> {
    if(toAct!==0) return;
    doAction(0,'fold',0);
    actLoop();
  });

  delayInput.addEventListener('input', updateActions);
  betSlider.addEventListener('input', ()=> betAmt.textContent = parseFloat(betSlider.value).toFixed(2));

  btn.help.addEventListener('click', ()=>{
    banner('Check/Call/Bet/Raise/Fold. Slider sets bet size. Next Hand to continue.', 1800);
  });

  // ======= Init =======
  resetSeats();
  banner('Tap “Next Hand” to deal', 1400);
  updateActions();

})();
</script>
</body>
</html>