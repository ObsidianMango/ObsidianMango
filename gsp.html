<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Garden State Parkway 3D Runner</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; width:100vw; height:100vh; background:#1e2633;}
    #gameCanvas { display:block; position:fixed; width:100vw; height:100vh; top:0; left:0; }
    #mobile-instructions {
      position:fixed; bottom:8px; left:0; width:100vw; text-align:center; color:#fff; font-size:1.2em; pointer-events:none; font-family:sans-serif;
      text-shadow: 1px 1px 6px #000;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="mobile-instructions"></div>
<script type="module">
// THREE.js from CDN
import * as THREE from "https://unpkg.com/three@0.160.2/build/three.module.js";

// ====== Scene Setup =======
const renderer = new THREE.WebGLRenderer({canvas:gameCanvas, antialias:true});
renderer.setClearColor(0x87ceeb); // sky blue
let W = window.innerWidth, H = window.innerHeight;
renderer.setSize(W,H);

const scene = new THREE.Scene();
// Fog for that endless parkway feel
scene.fog = new THREE.Fog(0x87ceeb, 40, 200);

const camera = new THREE.PerspectiveCamera(70, W/H, 0.1, 1000);
camera.position.set(0,5,14);
camera.lookAt(0,1,0);

const light = new THREE.HemisphereLight(0xffffff, 0x556677, 1.1);
scene.add(light);

// ====== Road & Environment ======
const roadWidth = 9, laneCount = 3, laneWidth = roadWidth/laneCount;
const roadLen = 180;
const roadGeo = new THREE.BoxGeometry(roadWidth, 0.1, roadLen);
const roadMat = new THREE.MeshStandardMaterial({color:0x3d3d3d});
const road = new THREE.Mesh(roadGeo, roadMat);
road.position.set(0,0,roadLen/2-30);
scene.add(road);

// Lane dashes
const dashGroup = new THREE.Group();
for (let lane=-1; lane<=1; lane++) {
  for (let i=0; i<30; i++) {
    const dash = new THREE.Mesh(
      new THREE.BoxGeometry(0.1,0.02,1),
      new THREE.MeshStandardMaterial({color:0xffffff})
    );
    dash.position.set(lane*laneWidth,0.07,i*6-10);
    dashGroup.add(dash);
  }
}
scene.add(dashGroup);

// Trees
const treeGroup = new THREE.Group();
for (let i=0; i<36; i++) {
  for (let side of [-1,1]) {
    const t = new THREE.Mesh(
      new THREE.CylinderGeometry(0.18,0.2,2.5,6),
      new THREE.MeshStandardMaterial({color:0x79553d})
    );
    t.position.set(side*(roadWidth/2+1.2+Math.random()*0.5),1.2,i*5-12+Math.random()*3);
    // Foliage
    const f = new THREE.Mesh(
      new THREE.DodecahedronGeometry(0.9+Math.random()*0.4,0),
      new THREE.MeshStandardMaterial({color:0x398144})
    );
    f.position.y=1.6;
    t.add(f);
    treeGroup.add(t);
  }
}
scene.add(treeGroup);

// ===== Player Car =====
const player = new THREE.Group();
const carBody = new THREE.Mesh(
  new THREE.BoxGeometry(1,0.6,2.1),
  new THREE.MeshStandardMaterial({color:0xffdd44})
);
carBody.position.y=0.38;
player.add(carBody);
// Windshield
const glass = new THREE.Mesh(
  new THREE.BoxGeometry(0.98,0.25,0.7),
  new THREE.MeshStandardMaterial({color:0xb7ecff, transparent:true, opacity:0.8})
);
glass.position.set(0,0.7,0.2);
player.add(glass);
player.position.set(0,0.1,2);
scene.add(player);

let playerLane = 1; // 0=left,1=mid,2=right
let changingLane = false, laneTarget=1, laneLerp=0;

// ===== Traffic Logic =====
const traffic = [];
const carColors = [0x5555cc,0xee4444,0x43d343,0xd4b04f,0xffffff,0xbb87ee];
const laneSpeeds = [0.36,0.29,0.24]; // fast, mid, slow

function addTrafficCar(lane, z) {
  const car = new THREE.Group();
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(1,0.62,2),
    new THREE.MeshStandardMaterial({color:carColors[Math.floor(Math.random()*carColors.length)]})
  );
  body.position.y=0.38;
  car.add(body);
  // Fake wheels
  for(let dx of [-0.4,0.4]) {
    for(let dz of [-0.7,0.7]) {
      const wheel = new THREE.Mesh(
        new THREE.CylinderGeometry(0.16,0.16,0.2,10),
        new THREE.MeshStandardMaterial({color:0x222222})
      );
      wheel.rotation.z=Math.PI/2;
      wheel.position.set(dx,0.18,dz);
      car.add(wheel);
    }
  }
  car.position.set((lane-1)*laneWidth,0.1,z);
  car.userData = { lane, speed: laneSpeeds[lane], kind:'car'};
  scene.add(car);
  traffic.push(car);
}

function spawnTrafficCluster(zOffset=65) {
  let clusterLanes = [0,1,2].sort(()=>Math.random()-0.5).slice(0,2+(Math.random()>0.6?1:0));
  for (let ln of clusterLanes) {
    addTrafficCar(ln, player.position.z+zOffset+Math.random()*3);
  }
}
// Preload traffic
for(let i=0;i<12;i++) spawnTrafficCluster(i*14+20);

// ===== Speeders & Cops =====
const effects = [];
function spawnSpeederAndCop() {
  // Choose random lane not blocked at front
  let lanes = [0,1,2], lane = lanes[Math.floor(Math.random()*3)];
  // Speeder
  const speeder = new THREE.Group();
  const body = new THREE.Mesh(
    new THREE.BoxGeometry(0.92,0.55,1.68),
    new THREE.MeshStandardMaterial({color:0x2222ff})
  );
  body.position.y=0.33;
  speeder.add(body);
  speeder.position.set((lane-1)*laneWidth,0.1,player.position.z+4);
  speeder.userData = {lane, speed:1.3, kind:'speeder', elapsed:0};
  scene.add(speeder);
  effects.push(speeder);

  // Cop after a delay
  setTimeout(()=>{
    const cop = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(1,0.6,2.05),
      new THREE.MeshStandardMaterial({color:0x202020})
    );
    body.position.y=0.36;
    cop.add(body);
    // Roof light
    const roof = new THREE.Mesh(
      new THREE.BoxGeometry(0.7,0.13,0.32),
      new THREE.MeshStandardMaterial({color:0x2222ff})
    );
    roof.position.set(0,0.72,0.35);
    cop.add(roof);
    cop.position.set((lane-1)*laneWidth,0.1,player.position.z+3.2);
    cop.userData = {lane, speed:1.23, kind:'cop', flash:0};
    scene.add(cop);
    effects.push(cop);
  }, 700);
}
// Spawner timer
let speederTimer = 3 + Math.random()*3;

// ====== Controls: Arrow keys or swipe ======
let touchStartX = 0, touchDX = 0, swiping = false;
function goLeft()  { if (playerLane > 0 && !changingLane) { laneTarget = --playerLane; changingLane = true; laneLerp=0; } }
function goRight() { if (playerLane < 2 && !changingLane) { laneTarget = ++playerLane; changingLane = true; laneLerp=0; } }
window.addEventListener('keydown', e=>{
  if(e.code==='ArrowLeft') goLeft();
  if(e.code==='ArrowRight') goRight();
});

const mobileInstructions = document.getElementById('mobile-instructions');
if (/Mobi|Android/i.test(navigator.userAgent)) {
  mobileInstructions.textContent = "Swipe left/right to switch lanes!";
  gameCanvas.addEventListener('touchstart',e=>{
    if(e.touches.length===1){touchStartX=e.touches[0].clientX; touchDX=0; swiping=true;}
  });
  gameCanvas.addEventListener('touchmove',e=>{
    if(swiping){ touchDX = e.touches[0].clientX-touchStartX;}
  });
  gameCanvas.addEventListener('touchend',e=>{
    if(swiping){
      if(touchDX < -28) goLeft();
      else if(touchDX > 28) goRight();
      swiping=false; touchDX=0;
    }
  });
} else {
  mobileInstructions.textContent = "Use ‚¨ÖÔ∏è / ‚û°Ô∏è arrows to switch lanes!";
}

// ======= GAME LOOP ==========
let tLast = performance.now()/1000, playerZ=2, speed=laneSpeeds[1], score=0;
function animate() {
  let tNow = performance.now()/1000, dt = Math.min(0.08, tNow-tLast); tLast = tNow;

  // Adjust speed by lane
  speed = laneSpeeds[playerLane];

  // Move player forward
  playerZ += speed*dt*6;
  player.position.z = playerZ;

  // Lane changing smoothness
  if(changingLane) {
    laneLerp += dt*4;
    player.position.x = THREE.MathUtils.lerp(player.position.x, (playerLane-1)*laneWidth, laneLerp);
    if(Math.abs(player.position.x-(playerLane-1)*laneWidth)<0.03) {
      player.position.x = (playerLane-1)*laneWidth;
      changingLane = false;
    }
  }

  // Move traffic towards player, respawn as needed
  for(let car of traffic) {
    car.position.z -= speed*dt*6;
    // Remove if behind
    if(car.position.z < playerZ-14) {
      scene.remove(car); car.userData.dead=true;
    }
    // Collision
    if(!car.userData.dead && Math.abs(car.position.z-playerZ)<1.2 && Math.abs(car.position.x-player.position.x)<0.7) {
      // CRASH
      mobileInstructions.textContent="üí• CRASH! Tap or press R to restart.";
      window.addEventListener('keydown',restartHandler,{once:true});
      gameCanvas.addEventListener('touchend',restartHandler,{once:true});
      return;
    }
  }
  // Remove dead cars, refill
  while(traffic.length && (traffic[0].userData.dead||traffic[0].position.z<playerZ-14)) traffic.shift();
  if(traffic.length<12) spawnTrafficCluster(38+Math.random()*18);

  // Animate dash lines (parallax)
  dashGroup.position.z = -player.position.z%6;

  // Trees parallax
  treeGroup.position.z = -player.position.z*0.8;

  // Animate speeders/cops
  for (let i=effects.length-1; i>=0; i--) {
    let obj = effects[i];
    if(obj.userData.kind==='speeder') {
      obj.position.z += obj.userData.speed;
      obj.userData.elapsed += dt;
      if(obj.position.z > player.position.z+66) {scene.remove(obj); effects.splice(i,1);}
    } else if(obj.userData.kind==='cop') {
      obj.position.z += obj.userData.speed;
      // Flashing roof lights
      obj.children[1].material.color.set(Math.random()>0.5?0xee3333:0x2222ff);
      if(obj.position.z > player.position.z+66) {scene.remove(obj); effects.splice(i,1);}
    }
  }
  // Spawn speeders/cops
  speederTimer -= dt;
  if(speederTimer<=0) {
    spawnSpeederAndCop();
    speederTimer = 4+Math.random()*7;
  }

  // Camera chase feel
  camera.position.z = player.position.z-7;
  camera.position.y = 4.2 + Math.sin(tNow*0.55)*0.07;
  camera.lookAt(player.position.x,player.position.y+0.9,player.position.z+9);

  // Score
  score = Math.floor(player.position.z*2);
  mobileInstructions.textContent += `  |  Score: ${score}`;

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
animate();

// Restart logic
function restartHandler() { location.reload(); }
window.addEventListener('resize', ()=>{
  W=window.innerWidth; H=window.innerHeight;
  renderer.setSize(W,H);
  camera.aspect = W/H; camera.updateProjectionMatrix();
});
</script>
</body>
</html>
