<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bottle Dash GP</title>
  <style>
    html, body { margin:0; padding:0; overflow:hidden; background:#232946; }
    #gameCanvas { position:fixed; top:0; left:0; width:100vw; height:100vh; display:block;}
    #overlay { position:absolute; top:10px; left:10px; color:white; font-size:2em; font-family:sans-serif; z-index:1;}
  </style>
</head>
<body>
  <div id="overlay">SCORE: <span id="score">0</span></div>
  <canvas id="gameCanvas"></canvas>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.156.1/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.156.1/examples/jsm/controls/OrbitControls.js';
    import * as CANNON from 'https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js';

    // -- Settings --
    const LANES = [-2, 0, 2];
    const LANE_SPEEDS = [1.3, 1.1, 1.0];
    const BASE_SPEED = 0.18;
    const PLAYER_Z = -6;
    const CAR_COLORS = [0x38761d, 0x134f5c, 0x990000, 0xffc20e, 0xcccccc];
    const BEER_COLOR = 0xffe599;
    const COP_COLOR = 0x1e90ff;
    const ROAD_COLOR = 0x383838;
    const GAME_WIDTH = 8;
    const GAME_HEIGHT = 30;

    // -- Three.js scene setup --
    const renderer = new THREE.WebGLRenderer({canvas:gameCanvas, antialias:true});
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x232946);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0,7,7);
    camera.lookAt(0,0,0);

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.8);
    scene.add(ambient);
    const dir = new THREE.DirectionalLight(0xffffff, 0.5);
    dir.position.set(0,10,10);
    scene.add(dir);

    // -- Cannon-es physics world --
    const world = new CANNON.World({ gravity: new CANNON.Vec3(0,0,0) });

    // -- Road (visual only) --
    const roadGeo = new THREE.BoxGeometry(GAME_WIDTH, 0.2, GAME_HEIGHT);
    const roadMat = new THREE.MeshPhongMaterial({color:ROAD_COLOR});
    const road = new THREE.Mesh(roadGeo, roadMat);
    road.position.y = -0.6;
    road.position.z = GAME_HEIGHT/2-4;
    scene.add(road);

    // Lane dash lines
    for(let lane of [-1,1]) {
      for(let i=0; i<15; ++i) {
        const dash = new THREE.Mesh(
          new THREE.BoxGeometry(0.1,0.05,1),
          new THREE.MeshBasicMaterial({color:0xffffff})
        );
        dash.position.x = lane;
        dash.position.y = -0.49;
        dash.position.z = i*2-2;
        scene.add(dash);
      }
    }
    // -- Trees (low-poly cones) --
    for(let s=-2; s<=2; s+=4){
      for(let i=0;i<18;++i){
        const tree = new THREE.Mesh(
          new THREE.ConeGeometry(0.3,1,6),
          new THREE.MeshLambertMaterial({color:0x16802c})
        );
        tree.position.x = s * 2.8 + (Math.random()-0.5)*0.3;
        tree.position.y = 0.1;
        tree.position.z = i*1.6-2 + Math.random()*1;
        scene.add(tree);
      }
    }

    // -- Player Car (Box) --
    const playerMat = new THREE.MeshPhongMaterial({color:0xff6f00});
    const playerGeo = new THREE.BoxGeometry(0.6,0.3,1.2);
    const playerMesh = new THREE.Mesh(playerGeo, playerMat);
    scene.add(playerMesh);

    // Cannon-es body for player
    const playerBody = new CANNON.Body({ mass: 1 });
    playerBody.addShape(new CANNON.Box(new CANNON.Vec3(0.3,0.15,0.6)));
    playerBody.position.set(0,0.1,PLAYER_Z);
    world.addBody(playerBody);

    // -- Vehicles --
    let vehicles = [];
    function spawnVehicle(type, lane, z, speedTier){
      let color = type === 'beer' ? BEER_COLOR : type === 'cop' ? COP_COLOR : CAR_COLORS[Math.floor(Math.random()*CAR_COLORS.length)];
      let geo = type === 'beer' ? new THREE.BoxGeometry(0.8,0.5,2.0) : new THREE.BoxGeometry(0.6,0.3,1.2);
      let mat = new THREE.MeshPhongMaterial({color});
      let mesh = new THREE.Mesh(geo, mat);
      mesh.position.x = LANES[lane];
      mesh.position.y = type === 'beer' ? 0.19 : 0.16;
      mesh.position.z = z;
      scene.add(mesh);

      let body = new CANNON.Body({ mass: 2 });
      body.addShape(new CANNON.Box(new CANNON.Vec3(geo.parameters.width/2,geo.parameters.height/2,geo.parameters.depth/2)));
      body.position.set(LANES[lane], 0.15, z);
      world.addBody(body);

      return {type, lane, mesh, body, speed: LANE_SPEEDS[lane]*BASE_SPEED* (type === 'cop'? 1.7 : type==='beer'? 0.7 : 1)};
    }

    // -- Controls --
    let currentLane = 1;
    function setLane(newLane){
      currentLane = Math.max(0,Math.min(2,newLane));
      playerBody.position.x = LANES[currentLane];
      playerMesh.position.x = LANES[currentLane];
    }

    // Touch/swipe
    let startX = null;
    window.addEventListener('pointerdown', e => { startX = e.clientX; });
    window.addEventListener('pointerup', e => {
      if(startX !== null){
        let dx = e.clientX - startX;
        if(Math.abs(dx)>30){
          if(dx>0) setLane(currentLane+1);
          else setLane(currentLane-1);
        }
        startX=null;
      }
    });
    // Keyboard
    window.addEventListener('keydown', e=>{
      if(e.key==='ArrowLeft') setLane(currentLane-1);
      if(e.key==='ArrowRight') setLane(currentLane+1);
    });

    // -- Game Logic --
    let score=0, running=true, nextSpawnZ=6;
    function spawnCluster(){
      // Each lane, maybe a car (weighted, random gaps)
      let copHere = Math.random() < 0.18; // Random cop car in random lane
      let copLane = Math.floor(Math.random()*3);
      for(let l=0;l<3;l++){
        if(copHere && l===copLane){
          vehicles.push(spawnVehicle('cop', l, nextSpawnZ, l));
        } else if(Math.random()<0.28){
          let type = Math.random()<0.17?'beer':'car';
          vehicles.push(spawnVehicle(type, l, nextSpawnZ, l));
        }
      }
      nextSpawnZ += 2.8 + Math.random()*1.1;
    }

    // -- Main Loop --
    function animate(){
      if(!running) return;
      requestAnimationFrame(animate);

      // Spawn traffic
      while(nextSpawnZ < playerBody.position.z + 24){
        spawnCluster();
      }

      // Move traffic toward player
      for(let v of vehicles){
        let tier = v.lane;
        v.body.position.z -= v.speed;
        v.mesh.position.copy(v.body.position);
      }
      // Remove passed cars
      vehicles = vehicles.filter(v => {
        if(v.body.position.z < PLAYER_Z-3){
          scene.remove(v.mesh);
          world.removeBody(v.body);
          return false;
        }
        return true;
      });

      // Dash lines scroll
      scene.children.forEach(obj=>{
        if(obj.geometry && obj.geometry.parameters && obj.geometry.parameters.width===0.1){
          obj.position.z -= BASE_SPEED;
          if(obj.position.z < -2) obj.position.z += 30;
        }
      });

      // Player update
      playerMesh.position.copy(playerBody.position);

      // Simple collision detection (AABB)
      for(let v of vehicles){
        if(Math.abs(playerBody.position.x - v.body.position.x)<0.6 &&
           Math.abs(playerBody.position.z - v.body.position.z)<0.9){
          if(v.type==='beer'){
            score+=5;
            document.getElementById('score').textContent=score;
            // Remove beer truck
            scene.remove(v.mesh);
            world.removeBody(v.body);
            v.body.position.z=-99;
          } else {
            running=false;
            document.getElementById('overlay').innerHTML = `<span style="color:#ff5560;">CRASHED! Final Score: ${score}<br><button onclick="location.reload()">RESTART</button></span>`;
          }
        }
      }

      // Move camera forward
      playerBody.position.z += BASE_SPEED*1.18;
      camera.position.z = playerBody.position.z+7;
      camera.lookAt(0,0,playerBody.position.z);

      renderer.render(scene, camera);
    }

    // Init
    setLane(1);
    animate();
    window.addEventListener('resize', ()=>{
      renderer.setSize(window.innerWidth,window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });

  </script>
</body>
</html>