<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Garden State Parkway 3D Runner (Babylon.js)</title>
  <style>
    html, body { margin:0; padding:0; width:100vw; height:100vh; overflow:hidden; background:#1e2633;}
    #renderCanvas { width:100vw; height:100vh; display:block; }
    #mobile-instructions {
      position:fixed; bottom:8px; left:0; width:100vw; text-align:center; color:#fff; font-size:1.1em; pointer-events:none;
      font-family:sans-serif; text-shadow: 1px 1px 6px #000;
    }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="mobile-instructions"></div>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script>
    // ======= INIT =======
    const canvas = document.getElementById("renderCanvas");
    const engine = new BABYLON.Engine(canvas, true);

    let scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.53,0.81,0.92); // Sky blue

    // Camera & Lighting
    let camera = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0, 7, -14), scene);
    camera.setTarget(new BABYLON.Vector3(0,1,10));
    camera.attachControl(canvas, true);

    let light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
    light.intensity = 0.95;

    // ===== ROAD, LANES, DASHES =====
    const laneCount = 3, roadWidth = 9, laneWidth = roadWidth / laneCount, roadLength = 100;
    let road = BABYLON.MeshBuilder.CreateBox("road", {width:roadWidth, depth:roadLength, height:0.12}, scene);
    road.position.z = roadLength/2 - 15;
    road.position.y = 0;
    road.material = new BABYLON.StandardMaterial("roadmat", scene);
    road.material.diffuseColor = new BABYLON.Color3(.21,.21,.21);

    // Dash lines
    for(let lane=-1; lane<=1; lane++){
      for(let i=0;i<22;i++){
        let dash = BABYLON.MeshBuilder.CreateBox("dash", {width:0.13, height:0.02, depth:1.4}, scene);
        dash.position.set(lane*laneWidth,0.07,i*4-8);
        dash.material = new BABYLON.StandardMaterial("dashmat",scene);
        dash.material.diffuseColor = BABYLON.Color3.White();
        dash.receiveShadows = true;
      }
    }

    // ===== TREES =====
    function makeTree(x,z){
      // Trunk
      let trunk = BABYLON.MeshBuilder.CreateCylinder("trunk",{diameterTop:0.15, diameterBottom:0.23, height:2.2},scene);
      trunk.position.set(x,1.1,z);
      trunk.material = new BABYLON.StandardMaterial("trunkmat",scene);
      trunk.material.diffuseColor = new BABYLON.Color3(0.48,0.35,0.20);
      // Leaves
      let leaves = BABYLON.MeshBuilder.CreateSphere("leaves",{diameter:0.75+Math.random()*0.3},scene);
      leaves.position.set(x,2.1,z);
      leaves.material = new BABYLON.StandardMaterial("leafmat",scene);
      leaves.material.diffuseColor = new BABYLON.Color3(0.14+Math.random()*0.08,0.52+Math.random()*0.12,0.20+Math.random()*0.12);
    }
    for(let i=0;i<24;i++){
      for(let side of [-1,1]){
        makeTree(side*(roadWidth/2+0.9+Math.random()*0.6),i*4-10);
      }
    }

    // ===== PLAYER CAR =====
    function makeCarMesh(color=0xffdd44, scale=1){
      let car = new BABYLON.TransformNode("car");
      let body = BABYLON.MeshBuilder.CreateBox("carbody", {width:0.9*scale, height:0.46*scale, depth:1.55*scale}, scene);
      body.material = new BABYLON.StandardMaterial("carmat",scene);
      let rgb = [((color>>16)&255)/255, ((color>>8)&255)/255, (color&255)/255];
      body.material.diffuseColor = new BABYLON.Color3(...rgb);
      body.position.y = 0.28*scale;
      body.parent = car;
      // Windshield
      let glass = BABYLON.MeshBuilder.CreateBox("glass",{width:0.83*scale, height:0.18*scale, depth:0.51*scale},scene);
      glass.position.y = 0.46*scale;
      glass.position.z = 0.18*scale;
      glass.material = new BABYLON.StandardMaterial("glassmat",scene);
      glass.material.diffuseColor = new BABYLON.Color3(0.70,0.88,1.0);
      glass.material.alpha = 0.5;
      glass.parent = car;
      // Wheels
      for(let dx of [-0.33,0.33]){
        for(let dz of [-0.48,0.48]){
          let wheel = BABYLON.MeshBuilder.CreateCylinder("wheel",{diameter:0.18*scale, height:0.12*scale},scene);
          wheel.rotation.z = Math.PI/2;
          wheel.position.set(dx,0.12*scale,dz);
          wheel.material = new BABYLON.StandardMaterial("wheelmat",scene);
          wheel.material.diffuseColor = new BABYLON.Color3(0.13,0.13,0.13);
          wheel.parent = car;
        }
      }
      return car;
    }

    let playerCar = makeCarMesh(0xffdd44, 1.09);
    playerCar.position = new BABYLON.Vector3(0,0.1,3);

    let playerLane = 1, targetLane = 1, isLaneSwitching = false, switchProgress=0;
    const laneXs = [-laneWidth, 0, laneWidth];

    // ===== TRAFFIC =====
    const carColors = [0x5555cc,0xee4444,0x43d343,0xd4b04f,0xffffff,0xbb87ee];
    const laneSpeeds = [0.37,0.29,0.21]; // left=fast, right=slow
    let traffic = [];

    function spawnTrafficCar(lane,z){
      let color = carColors[Math.floor(Math.random()*carColors.length)];
      let mesh = makeCarMesh(color,0.98);
      mesh.position.x = laneXs[lane];
      mesh.position.y = 0.11;
      mesh.position.z = z;
      scene.addTransformNode(mesh);
      mesh.metadata = {lane,speed:laneSpeeds[lane],kind:'car',mesh};
      traffic.push(mesh);
    }
    function spawnTrafficCluster(zOffset=52){
      let clusterLanes = [0,1,2].sort(()=>Math.random()-0.5).slice(0,2+(Math.random()>0.55?1:0));
      for(let ln of clusterLanes){
        spawnTrafficCar(ln, playerCar.position.z+zOffset+Math.random()*2.6);
      }
    }
    for(let i=0;i<11;i++) spawnTrafficCluster(i*11+10);

    // ===== SPEEDER & COP =====
    let effects = [];
    function spawnSpeederAndCop(){
      let lane = Math.floor(Math.random()*3);
      // Speeder
      let speeder = makeCarMesh(0x1e6ef8,0.9);
      speeder.position.x = laneXs[lane];
      speeder.position.z = playerCar.position.z+4;
      scene.addTransformNode(speeder);
      speeder.metadata = {lane, speed:1.19, kind:'speeder', elapsed:0};
      effects.push(speeder);

      // Cop, after a delay
      setTimeout(()=>{
        let cop = makeCarMesh(0x202020,0.97);
        // Cop light
        let lightBox = BABYLON.MeshBuilder.CreateBox("roof",{width:0.46,height:0.08,depth:0.18},scene);
        lightBox.position.y=0.44; lightBox.position.z=0.21;
        lightBox.material = new BABYLON.StandardMaterial("lightmat",scene);
        lightBox.material.diffuseColor = new BABYLON.Color3(0.1,0.1,1.0);
        lightBox.material.emissiveColor = new BABYLON.Color3(0.2,0.1,0.85);
        lightBox.parent = cop;
        cop.position.x = laneXs[lane];
        cop.position.z = playerCar.position.z+2.8;
        scene.addTransformNode(cop);
        cop.metadata = {lane, speed:1.13, kind:'cop', flash:0, roof:lightBox};
        effects.push(cop);
      },700);
    }
    let speederTimer = 2.8+Math.random()*4;

    // ===== CONTROLS (arrow/swipe) =====
    let mobileInstructions = document.getElementById("mobile-instructions");
    function goLeft(){
      if(playerLane>0&&!isLaneSwitching){ targetLane=--playerLane; isLaneSwitching=true; switchProgress=0; }
    }
    function goRight(){
      if(playerLane<2&&!isLaneSwitching){ targetLane=++playerLane; isLaneSwitching=true; switchProgress=0; }
    }
    window.addEventListener('keydown', e=>{
      if(e.code==="ArrowLeft") goLeft();
      if(e.code==="ArrowRight") goRight();
    });
    // Swipe
    let tsX=0,dx=0,swiping=false;
    if(/Mobi|Android|iPhone/i.test(navigator.userAgent)){
      mobileInstructions.textContent = "Swipe left/right to switch lanes!";
      canvas.addEventListener('touchstart',e=>{if(e.touches.length===1){tsX=e.touches[0].clientX;dx=0;swiping=true;}});
      canvas.addEventListener('touchmove',e=>{if(swiping){dx = e.touches[0].clientX-tsX;}});
      canvas.addEventListener('touchend',e=>{
        if(swiping){
          if(dx<-24) goLeft();
          else if(dx>24) goRight();
          swiping=false; dx=0;
        }
      });
    } else {
      mobileInstructions.textContent = "Use ‚¨ÖÔ∏è / ‚û°Ô∏è arrows to switch lanes!";
    }

    // ===== MAIN GAME LOOP =====
    let playerZ=3, speed=laneSpeeds[1], score=0, gameOver=false;
    let lastTime = performance.now()/1000;
    function gameLoop(){
      let now = performance.now()/1000, dt = Math.min(0.07, now-lastTime); lastTime = now;
      if(gameOver) return;

      speed = laneSpeeds[playerLane];

      // Lane switch anim
      if(isLaneSwitching){
        switchProgress+=dt*3.9;
        let lerp = Math.min(1,switchProgress);
        playerCar.position.x = playerCar.position.x+(laneXs[targetLane]-playerCar.position.x)*lerp;
        if(Math.abs(playerCar.position.x-laneXs[targetLane])<0.04){
          playerCar.position.x=laneXs[targetLane];
          isLaneSwitching=false;
        }
      }

      // Move forward
      playerZ += speed*dt*6;
      playerCar.position.z = playerZ;

      // Move camera to chase player
      camera.position.z = playerCar.position.z-12.5;
      camera.position.y = 5.3 + Math.sin(now*0.49)*0.13;
      camera.setTarget(new BABYLON.Vector3(playerCar.position.x,1.0,playerCar.position.z+10));

      // Move traffic
      for(let t of traffic){
        t.position.z -= speed*dt*6;
        if(t.position.z<playerCar.position.z-12){
          t.metadata.dead = true;
        }
        // Collision
        if(!t.metadata.dead && Math.abs(t.position.z-playerCar.position.z)<1.14 && Math.abs(t.position.x-playerCar.position.x)<0.75){
          // CRASH
          mobileInstructions.textContent="üí• CRASH! Tap or press R to restart.";
          window.addEventListener('keydown',restartHandler,{once:true});
          canvas.addEventListener('touchend',restartHandler,{once:true});
          gameOver=true;
          return;
        }
      }
      // Remove old traffic, add new
      while(traffic.length && (traffic[0].metadata.dead||traffic[0].position.z<playerCar.position.z-12)){
        traffic[0].dispose();
        traffic.shift();
      }
      if(traffic.length<10) spawnTrafficCluster(27+Math.random()*17);

      // Animate effects (speeders/cops)
      for(let i=effects.length-1;i>=0;i--){
        let obj=effects[i];
        if(obj.metadata.kind==='speeder'){
          obj.position.z += obj.metadata.speed;
          obj.metadata.elapsed += dt;
          if(obj.position.z > playerCar.position.z+60){ obj.dispose(); effects.splice(i,1);}
        } else if(obj.metadata.kind==='cop'){
          obj.position.z += obj.metadata.speed;
          // Flash lights
          if(Math.random()>0.5){
            obj.metadata.roof.material.diffuseColor = new BABYLON.Color3(1,0.06,0.1);
            obj.metadata.roof.material.emissiveColor = new BABYLON.Color3(0.7,0.12,0.16);
          } else {
            obj.metadata.roof.material.diffuseColor = new BABYLON.Color3(0.1,0.1,1.0);
            obj.metadata.roof.material.emissiveColor = new BABYLON.Color3(0.2,0.1,0.85);
          }
          if(obj.position.z > playerCar.position.z+60){ obj.dispose(); effects.splice(i,1);}
        }
      }
      // Spawn speeders/cops
      speederTimer -= dt;
      if(speederTimer<=0){
        spawnSpeederAndCop();
        speederTimer = 4+Math.random()*6.2;
      }

      // Score
      score = Math.floor(playerCar.position.z*2);
      mobileInstructions.textContent = (gameOver ? "üí• CRASH! Tap or press R to restart." : (/Mobi|Android|iPhone/i.test(navigator.userAgent)?"Swipe left/right":"Use ‚¨ÖÔ∏è / ‚û°Ô∏è arrows")+" to switch lanes!") + `  |  Score: ${score}`;

      engine.runRenderLoop(()=>{scene.render();});
      requestAnimationFrame(gameLoop);
    }
    gameLoop();

    function restartHandler(){ location.reload(); }
    window.addEventListener('resize',()=>{
      engine.resize();
    });

  </script>
</body>
</html>