<!DOCTYPE html>
<html>
<head>
  <title>Bottle Dash GP - Babylon.js Edition</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <style>
    html,body { margin:0; padding:0; overflow:hidden; background:#222; }
    #gameCanvas { width:100vw; height:100vh; display:block;}
    #hud { position:fixed;top:0;left:0;width:100%;color:#fff;font-size:2em;font-family:sans-serif;padding:10px;text-shadow:2px 2px #222;z-index:2;}
    #hud span { font-weight:bold;}
    #gameover {position:fixed;top:40%;left:0;width:100%;text-align:center;color:#ff4040;font-size:2.5em;display:none;z-index:9;}
    button {font-size:1em;padding:12px 28px;margin-top:1em;}
  </style>
</head>
<body>
  <div id="hud">Score: <span id="score">0</span></div>
  <div id="gameover"></div>
  <canvas id="gameCanvas"></canvas>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/Oimo.js"></script>
  <script>
    // ------ Babylon.js scene setup ------
    const canvas = document.getElementById("gameCanvas");
    const engine = new BABYLON.Engine(canvas, true);
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.14, 0.16, 0.22);

    // Camera
    const camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0,6,-10), scene);
    camera.radius = 10;
    camera.heightOffset = 5.5;
    camera.rotationOffset = 0;
    camera.cameraAcceleration = 0.12;
    camera.maxCameraSpeed = 12;
    camera.attachControl(canvas, true);

    // Light
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

    // Physics
    scene.enablePhysics(new BABYLON.Vector3(0, 0, 0), new BABYLON.OimoJSPlugin());

    // ----- Lanes -----
    const LANES = [-2,0,2];
    const LANE_SPEEDS = [1.3, 1.1, 1.0];
    const BASE_SPEED = 0.23;

    // Road
    const road = BABYLON.MeshBuilder.CreateBox("road", {width:7.5, height:0.1, depth:44}, scene);
    road.position.y = -0.11;
    road.material = new BABYLON.StandardMaterial("roadmat", scene);
    road.material.diffuseColor = new BABYLON.Color3(0.22,0.22,0.22);

    // Lane dashes
    for(let l of [-1,1]) {
      for(let i=0;i<18;++i) {
        const dash = BABYLON.MeshBuilder.CreateBox("dash", {width:0.13, height:0.02, depth:1.7}, scene);
        dash.position.x = l;
        dash.position.y = 0.05;
        dash.position.z = i*2.4-18;
        dash.material = new BABYLON.StandardMaterial("dashmat", scene);
        dash.material.diffuseColor = BABYLON.Color3.White();
      }
    }

    // Trees
    for(let side of [-3.5,3.5]){
      for(let i=0;i<13;i++){
        const tree = BABYLON.MeshBuilder.CreateCylinder("tree", {diameter:0.38,height:1.7,tessellation:6}, scene);
        tree.position.x = side + (Math.random()-0.5)*0.7;
        tree.position.y = 0.85;
        tree.position.z = i*3.4-14+Math.random();
        const green = new BABYLON.StandardMaterial("leaves", scene);
        green.diffuseColor = new BABYLON.Color3(0.15+Math.random()*0.2,0.6,0.18);
        tree.material = green;
      }
    }

    // ----- Player car -----
    let playerLane = 1;
    let playerZ = -10;
    const player = BABYLON.MeshBuilder.CreateBox("player", {width:0.7, height:0.35, depth:1.3}, scene);
    player.position.set(LANES[playerLane],0.21,playerZ);
    const playerMat = new BABYLON.StandardMaterial("playermat", scene);
    playerMat.diffuseColor = new BABYLON.Color3(1,0.53,0.01);
    player.material = playerMat;

    // Physics impostor (AABB only, simple)
    player.physicsImpostor = new BABYLON.PhysicsImpostor(player, BABYLON.PhysicsImpostor.BoxImpostor, {mass:1,restitution:0.01}, scene);

    camera.lockedTarget = player;

    // ----- Obstacles & Traffic -----
    let vehicles = [];
    let nextSpawnZ = 6;
    function spawnVehicle(type, lane, z){
      let mesh, mat;
      if(type==="beer"){
        mesh = BABYLON.MeshBuilder.CreateBox("beer", {width:0.85, height:0.48, depth:2.0}, scene);
        mat = new BABYLON.StandardMaterial("beer", scene);
        mat.diffuseColor = new BABYLON.Color3(0.97,0.86,0.4);
      } else if(type==="cop"){
        mesh = BABYLON.MeshBuilder.CreateBox("cop", {width:0.8, height:0.37, depth:1.45}, scene);
        mat = new BABYLON.StandardMaterial("cop", scene);
        mat.diffuseColor = new BABYLON.Color3(0.17,0.34,0.88);
      } else {
        mesh = BABYLON.MeshBuilder.CreateBox("car", {width:0.67, height:0.32, depth:1.17}, scene);
        mat = new BABYLON.StandardMaterial("car", scene);
        const c = Math.random();
        mat.diffuseColor = new BABYLON.Color3(0.5+c*0.5,0.22+c*0.3,0.22+(1-c)*0.5);
      }
      mesh.material = mat;
      mesh.position.set(LANES[lane], mesh.scaling.y/2 + 0.16, z);
      mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass:2}, scene);
      return {type, lane, mesh, z, speed: LANE_SPEEDS[lane]*BASE_SPEED*(type==="cop"?1.65:type==="beer"?0.7:1)};
    }

    // Controls: Keyboard + swipe
    function setLane(lane){
      playerLane = Math.max(0, Math.min(2, lane));
      player.position.x = LANES[playerLane];
    }
    window.addEventListener('keydown', e => {
      if(e.key==="ArrowLeft") setLane(playerLane-1);
      if(e.key==="ArrowRight") setLane(playerLane+1);
    });

    // Touch/swipe for mobile
    let touchX = null;
    canvas.addEventListener("touchstart", e=>{touchX = e.touches[0].clientX;});
    canvas.addEventListener("touchend", e=>{
      if(touchX){
        let dx = e.changedTouches[0].clientX - touchX;
        if(Math.abs(dx)>30){
          if(dx>0) setLane(playerLane+1);
          else setLane(playerLane-1);
        }
        touchX = null;
      }
    });

    // ------ Main Loop ------
    let score=0, running=true, lastScoreZ = playerZ;
    function spawnCluster(){
      // Randomly fill lanes with cars, beer trucks, and sometimes a cop
      let copHere = Math.random()<0.17, copLane = Math.floor(Math.random()*3);
      for(let l=0;l<3;l++){
        if(copHere && l===copLane){
          vehicles.push(spawnVehicle("cop",l,nextSpawnZ));
        } else if(Math.random()<0.25){
          vehicles.push(spawnVehicle(Math.random()<0.15?"beer":"car",l,nextSpawnZ));
        }
      }
      nextSpawnZ += 3.1 + Math.random()*1.8;
    }

    // ------ Game Loop ------
    engine.runRenderLoop(()=>{
      if(!running) return;
      // Spawn new traffic as you move forward
      while(nextSpawnZ < player.position.z + 22){
        spawnCluster();
      }
      // Move all cars toward player
      for(let v of vehicles){
        v.mesh.position.z -= v.speed;
      }
      // Remove vehicles behind you
      vehicles = vehicles.filter(v=>{
        if(v.mesh.position.z < player.position.z-5){
          v.mesh.dispose();
          return false;
        }
        return true;
      });
      // Score: Add every time you pass some distance
      if(player.position.z - lastScoreZ > 1.6){
        score++;
        lastScoreZ = player.position.z;
        document.getElementById('score').textContent = score;
      }

      // Collision detection
      for(let v of vehicles){
        if(Math.abs(player.position.x-v.mesh.position.x)<0.7 && Math.abs(player.position.z-v.mesh.position.z)<1.1){
          if(v.type==='beer'){
            score+=5;
            document.getElementById('score').textContent = score;
            v.mesh.dispose();
            v.mesh.position.z = -999;
          } else {
            running = false;
            player.material.diffuseColor = new BABYLON.Color3(1,0.1,0.1);
            document.getElementById('gameover').style.display='block';
            document.getElementById('gameover').innerHTML = `
              ðŸš¨ <b>CRASHED!</b> ðŸš¨<br>Final Score: ${score}<br>
              <button onclick="location.reload()">Restart</button>
            `;
          }
        }
      }
      // Move player forward (always)
      player.position.z += BASE_SPEED*1.08;
      camera.target.z = player.position.z+3.2;
      camera.position.z = player.position.z-8;

      scene.render();
    });

    window.addEventListener('resize', ()=>engine.resize());
  </script>
</body>
</html>