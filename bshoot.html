<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Basketball Timing Game (Knicks & Sweet Spot)</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; overflow: hidden; background: #1a1a1a; }
    canvas { display: block; }
    #retroUI {
      position: absolute;
      top: 10px; left: 0; width: 100vw; z-index: 10; text-align: center; pointer-events: none;
    }
    .panel {
      display: inline-block;
      padding: 12px 0;
      width: 46vw; min-width: 120px; max-width: 180px;
      border: 4px solid #00ff75;
      border-radius: 10px;
      background: #18191b;
      color: #ffeb59;
      font-family: 'Press Start 2P', monospace;
      font-size: 1.2em;
      margin: 0 1vw;
      box-shadow: 0 2px 10px #2f8a;
      text-shadow: 2px 2px 0 #000, 0 0 12px #fff82e;
      letter-spacing: 1px;
    }
    #instructions {
      color: #fff0b8;
      background: #0956ab;
      border: 3px solid #fff048;
      margin: 14px auto 0 auto;
      border-radius: 7px;
      font-size: 1em;
      width: 88vw; max-width: 340px;
      padding: 9px 0 9px 0;
      box-shadow: 0 2px 8px #2746ac;
      text-shadow: 1px 1px 0 #033b64;
      text-align: center;
    }
    #metersUI {
      position: absolute;
      left: 0; top: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 5;
    }
    #powerBarCanvas {
      position: absolute;
      left: 50%; top: 73vh;
      width: 76vw; min-width: 110px; max-width: 390px;
      height: 54px;
      margin-left: -38vw;
      z-index: 6;
      background: transparent;
      pointer-events: none;
    }
    #feedbackText {
      position: absolute;
      top: 64vh; left: 0; width: 100vw;
      text-align: center;
      font-family: 'Press Start 2P', monospace;
      font-size: 1.2em;
      color: #fff;
      text-shadow: 2px 2px 0 #000, 0 0 14px #006BB6;
      opacity: 0;
      pointer-events: none;
      z-index: 20;
      transition: opacity 0.2s;
      user-select: none;
    }
  </style>
</head>
<body>
  <div id="retroUI">
    <div class="panel">SCORE:<br><span id="score">0</span></div>
    <div class="panel">STREAK:<br><span id="streak">0</span></div>
    <div id="instructions">
      TAP ONCE TO START<br>TAP AGAIN TO STOP IN THE YELLOW "SWEET SPOT"!
    </div>
  </div>
  <div id="metersUI">
    <canvas id="powerBarCanvas" width="340" height="54"></canvas>
  </div>
  <div id="feedbackText"></div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
    // --- UI refs ---
    const scoreDisplay = document.getElementById("score");
    const streakDisplay = document.getElementById("streak");
    const powerCanvas = document.getElementById("powerBarCanvas");
    const powerCtx = powerCanvas.getContext("2d");
    const feedbackText = document.getElementById("feedbackText");
    const instructions = document.getElementById("instructions");

    // --- Three.js setup ---
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(74, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Lighting ---
    let light = new THREE.DirectionalLight(0xffffff, 2.1);
    light.position.set(6, 11, 8);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x6e7ab3, 0.5));

    // --- Wood Court w/ simple lines ---
    let courtGroup = new THREE.Group();
    // Court
    let woodCourt = new THREE.Mesh(
      new THREE.PlaneGeometry(36, 35),
      new THREE.MeshPhongMaterial({
        color: 0xb97a57,
        shininess: 58,
        specular: 0xffffff,
        reflectivity: 0.17
      })
    );
    woodCourt.rotation.x = -Math.PI / 2;
    woodCourt.position.y = 0.005;
    courtGroup.add(woodCourt);
    // Paint/Key (rectangle)
    let key = new THREE.Mesh(
      new THREE.BoxGeometry(3.6, 0.01, 7),
      new THREE.MeshPhongMaterial({ color: 0xf4e9d0 })
    );
    key.position.set(0, 0.011, -8.5);
    courtGroup.add(key);
    // Free throw circle
    let freeThrow = new THREE.Mesh(
      new THREE.TorusGeometry(1.7, 0.035, 16, 60),
      new THREE.MeshPhongMaterial({ color: 0xf4e9d0 })
    );
    freeThrow.position.set(0, 0.012, -5.2);
    freeThrow.rotation.x = -Math.PI/2;
    courtGroup.add(freeThrow);
    // Center circle
    let centerCircle = new THREE.Mesh(
      new THREE.TorusGeometry(2.2, 0.05, 16, 60),
      new THREE.MeshPhongMaterial({ color: 0xf4e9d0 })
    );
    centerCircle.position.set(0, 0.012, 0);
    centerCircle.rotation.x = -Math.PI/2;
    courtGroup.add(centerCircle);
    scene.add(courtGroup);

    // --- Knicks Crowd (random) ---
    function makeKnicksCrowd() {
      const group = new THREE.Group();
      let crowdColors = [0x006BB6, 0xF58426, 0xffffff];
      let yStart = 4.5, z = -13.7, crowdRows = 7, perRow = 20, w = 0.83, h = 1.11, d = 0.23;
      for (let row = 0; row < crowdRows; row++) {
        for (let i = 0; i < perRow; i++) {
          let color = crowdColors[Math.floor(Math.random()*crowdColors.length)];
          let box = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            new THREE.MeshPhongMaterial({ color: color })
          );
          box.position.set(
            -8.5 + (i * 0.87) + ((row % 2) * 0.44),
            yStart + (row * 1.01) + (Math.random()*0.13),
            z - (row * 0.8)
          );
          group.add(box);
        }
      }
      return group;
    }
    scene.add(makeKnicksCrowd());

    // --- Hoop, Rim, Net, Backboard, Post ---
    const post = new THREE.Mesh(
      new THREE.CylinderGeometry(0.18, 0.24, 7.7, 18),
      new THREE.MeshPhongMaterial({ color: 0xb8b8b8 })
    );
    post.position.set(0, 1.9, -12.65);
    scene.add(post);

    // Glass backboard
    const backboard = new THREE.Mesh(
      new THREE.BoxGeometry(3.2, 2, 0.14),
      new THREE.MeshPhongMaterial({
        color: 0xffffff, transparent: true, opacity: 0.88
      })
    );
    backboard.position.set(0, 5, -12);
    scene.add(backboard);

    // Rim
    const rim = new THREE.Mesh(
      new THREE.TorusGeometry(0.7, 0.075, 16, 32),
      new THREE.MeshPhongMaterial({ color: 0xf58426 })
    );
    rim.position.set(0, 4.18, -11.5);
    rim.rotation.x = Math.PI / 2;
    scene.add(rim);

    // Net (faked with thin torus "loops")
    for(let n=0;n<8;n++){
      let netLoop = new THREE.Mesh(
        new THREE.TorusGeometry(0.62, 0.025, 7, 16, Math.PI/1.5),
        new THREE.MeshPhongMaterial({ color: 0xffffff })
      );
      netLoop.position.set(
        0.68*Math.cos((Math.PI*2/8)*n),
        3.97,
        -11.5+0.68*Math.sin((Math.PI*2/8)*n)
      );
      netLoop.rotation.x = Math.PI/2;
      netLoop.rotation.z = (Math.PI*2/8)*n;
      scene.add(netLoop);
    }

    // Rim collision plane
    const rimPlane = { z: -11.5, y: 4.18, r: 0.72 };

    // --- Ball ---
    const ballGeometry = new THREE.SphereGeometry(0.31, 32, 32);
    const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xff9900 });
    const ball = new THREE.Mesh(ballGeometry, ballMaterial);
    scene.add(ball);

    // --- Game State ---
    let velocity = new THREE.Vector3();
    let isShot = false;
    let powerMode = false;
    let powerLevel = 0;      // 0-1
    let score = 0, streak = 0;
    let awaitingPower = false;

    // --- Power Meter ---
    let sweetSpotMin = 0.54, sweetSpotMax = 0.76; // Where to hit for "swish" (in fraction, 0-1)
    let powerAnim = 0.2, powerDir = 1;
    let powerActive = false;

    function drawPowerBar(power) {
      powerCtx.clearRect(0,0,powerCanvas.width,powerCanvas.height);
      let w = powerCanvas.width-38, h = 22, x = 19, y = 24;
      // Bar
      powerCtx.save();
      powerCtx.strokeStyle = "#fff048";
      powerCtx.lineWidth = 6;
      powerCtx.strokeRect(x, y, w, h);
      // SWEET SPOT
      let smin = x + w * sweetSpotMin;
      let smax = x + w * sweetSpotMax;
      powerCtx.fillStyle = "#ffe96b";
      powerCtx.globalAlpha = 0.70;
      powerCtx.fillRect(smin, y, smax-smin, h);
      powerCtx.globalAlpha = 1.0;
      // Bar fill
      let grad = powerCtx.createLinearGradient(x, y, x+w, y+h);
      grad.addColorStop(0, "#00ff75");
      grad.addColorStop(0.5, "#fff048");
      grad.addColorStop(1, "#ff5858");
      powerCtx.fillStyle = grad;
      powerCtx.fillRect(x, y, w*power, h);
      // Dot
      let px = x + w*power;
      powerCtx.beginPath();
      powerCtx.arc(px, y+h/2, 16, 0, 2*Math.PI);
      powerCtx.fillStyle = "#fff048";
      powerCtx.shadowBlur = 7;
      powerCtx.shadowColor = "#00ff75";
      powerCtx.fill();
      powerCtx.restore();
      powerCtx.font = '15px "Press Start 2P", monospace';
      powerCtx.fillStyle = "#0036cc";
      powerCtx.textAlign = "center";
      powerCtx.fillText("POWER", powerCanvas.width/2, 20);
      // SWEET SPOT label
      powerCtx.font = '11px "Press Start 2P", monospace';
      powerCtx.fillStyle = "#222";
      powerCtx.fillText("SWEET SPOT!", (smin+smax)/2, y+h-2);
    }

    // --- Ball Reset ---
    function resetBall(miss = false) {
      setTimeout(() => {
        ball.position.set(0, 1.5, 2);
        velocity.set(0, 0, 0);
        isShot = false;
        powerMode = false;
        awaitingPower = false;
        showUI();
      }, 620);
    }

    // --- Main Shot Logic ---
    function takeShot(powerValue) {
      // Clamp power for fun: "swish" in sweet spot, almost always in, others can bounce out
      let swish = (powerValue >= sweetSpotMin && powerValue <= sweetSpotMax);
      // All shots aimed at hoop
      let baseZ = -0.185 - 0.12*powerValue;
      let baseY = 0.12 + 0.19*powerValue;
      velocity.set(0, baseY, baseZ);
      isShot = true;
      powerMode = false;
      awaitingPower = false;
      hideUI();
      // Show feedback
      if(swish){
        showFeedback("SWISH!", "#f6ff73");
      } else if (Math.abs(powerValue - (sweetSpotMin+sweetSpotMax)/2) < 0.11) {
        showFeedback("IN!", "#fff");
      } else {
        showFeedback("BRICK!", "#F58426");
      }
    }

    // --- Backboard Physics ---
    function checkBackboardCollision() {
      const bb = { z: -12, x1: -1.6, x2: 1.6, y1: 4, y2: 6 };
      if (velocity.z <= 0) return;
      if (
        ball.position.z < bb.z + 0.15 &&
        ball.position.z > bb.z - 0.21 &&
        ball.position.x > bb.x1 && ball.position.x < bb.x2 &&
        ball.position.y > bb.y1 && ball.position.y < bb.y2
      ) {
        velocity.z *= -0.62;
        velocity.y *= 0.82;
        ball.position.z = bb.z + 0.16;
      }
    }

    // --- Scoring ---
    function checkScore() {
      if (
        ball.position.z < rimPlane.z + 0.11 && ball.position.z > rimPlane.z - 0.20 &&
        ball.position.y < rimPlane.y + 0.39 && ball.position.y > rimPlane.y - 0.34 &&
        Math.abs(ball.position.x) < rimPlane.r &&
        velocity.y < 0
      ) {
        score++;
        streak++;
        scoreDisplay.textContent = score;
        streakDisplay.textContent = streak;
        velocity.y = -0.05 - Math.random() * 0.014;
        velocity.z = 0;
        setTimeout(resetBall, 600);
        isShot = true;
      }
    }

    // --- Rim bounce ---
    function checkRimBounce() {
      if (
        Math.abs(ball.position.z - rimPlane.z) < 0.11 &&
        ball.position.y < rimPlane.y + 0.25 &&
        Math.abs(ball.position.x) < rimPlane.r + 0.13 &&
        velocity.y < 0
      ) {
        velocity.y *= -0.45;
        velocity.x *= 0.34;
        velocity.z *= 0.74;
      }
    }

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);

      if (powerActive && awaitingPower && !isShot) {
        // Animate power meter
        powerAnim += 0.0092 * powerDir;
        if (powerAnim > 1) { powerAnim = 1; powerDir = -1; }
        if (powerAnim < 0.19) { powerAnim = 0.19; powerDir = 1; }
        drawPowerBar(powerAnim);
        powerLevel = powerAnim;
      } else {
        powerCtx.clearRect(0,0,powerCanvas.width,powerCanvas.height);
      }

      // Ball physics
      if (isShot) {
        velocity.y -= 0.008;
        ball.position.add(velocity);
        checkScore();
        checkRimBounce();
        checkBackboardCollision();
        if (ball.position.y < 0.14 || ball.position.z < -15) {
          showFeedback("MISS", "#F58426");
          streak = 0;
          streakDisplay.textContent = streak;
          resetBall(true);
        }
      }
      renderer.render(scene, camera);
    }

    // --- Feedback text ---
    let feedbackTimeout = null;
    function showFeedback(txt, color="#fff") {
      feedbackText.textContent = txt;
      feedbackText.style.color = color;
      feedbackText.style.opacity = 1;
      clearTimeout(feedbackTimeout);
      feedbackTimeout = setTimeout(()=>{feedbackText.style.opacity=0}, 1000);
    }

    // --- UI Show/Hide for clarity when shot is in air
    function hideUI() {
      powerCanvas.style.opacity = "0";
      document.getElementById("retroUI").style.opacity = "0.7";
      instructions.style.opacity = "0";
    }
    function showUI() {
      powerCanvas.style.opacity = "1";
      document.getElementById("retroUI").style.opacity = "1";
      instructions.style.opacity = "1";
    }

    // --- Tap/Click Handling ---
    function tap() {
      if (isShot) return;
      if (!awaitingPower) {
        awaitingPower = true;
        powerActive = true;
        powerAnim = Math.random()*0.15+0.22;
        powerDir = 1;
      } else {
        awaitingPower = false;
        powerActive = false;
        takeShot(powerLevel);
      }
    }
    window.addEventListener("mousedown", tap);
    window.addEventListener("touchstart", function(e){ e.preventDefault(); tap(); }, {passive:false});

    // --- Camera ---
    function setCamera() {
      if(window.innerHeight > window.innerWidth){
        camera.position.set(0, 2.2, 6.6);
        camera.lookAt(0, 4.5, -11.5);
      } else {
        camera.position.set(0, 1.85, 7.8);
        camera.lookAt(0, 4.2, -11.5);
      }
    }
    setCamera();

    // --- Responsive ---
    function resizeUI() {
      setTimeout(()=>{
        powerCanvas.width = Math.floor(window.innerWidth * 0.76);
        if (powerCanvas.width > 390) powerCanvas.width = 390;
        powerCanvas.height = 54;
      }, 10);
    }
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      setCamera();
      resizeUI();
    });

    // --- Start game ---
    resizeUI();
    resetBall();
    animate();
  </script>
</body>
</html>