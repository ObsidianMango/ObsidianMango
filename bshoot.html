<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tap-Timing Basketball (Knicks & Wood Edition)</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; overflow: hidden; background: #222227; }
    canvas { display: block; }
    #retroUI {
      position: absolute;
      top: 14px; left: 0; width: 100vw; z-index: 10; text-align: center; pointer-events: none;
    }
    .panel {
      display: inline-block;
      padding: 14px 0;
      width: 46vw; min-width: 140px; max-width: 200px;
      border: 4px solid #00ff75;
      border-radius: 10px;
      background: #17191b;
      color: #ffeb59;
      font-family: 'Press Start 2P', monospace;
      font-size: 1.25em;
      margin: 0 1vw;
      box-shadow: 0 2px 10px #2f8a;
      text-shadow: 2px 2px 0 #000, 0 0 12px #fff82e;
      letter-spacing: 1px;
    }
    #instructions {
      color: #fff0b8;
      background: #72297e;
      border: 3px solid #fff048;
      margin: 12px auto 0 auto;
      border-radius: 7px;
      font-size: 1em;
      width: 88vw; max-width: 340px;
      padding: 10px 0 10px 0;
      box-shadow: 0 2px 8px #7006;
      text-shadow: 1px 1px 0 #470c6a;
      text-align: center;
    }
    #metersUI {
      position: absolute;
      left: 0; top: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 5;
    }
    .meterPanel {
      position: absolute;
      left: 50%;
      transform: translateX(-50%);
      font-family: 'Press Start 2P', monospace;
      color: #fff048;
      text-shadow: 1px 1px 0 #000;
      pointer-events: none;
    }
    #aimArrowCanvas {
      top: 63vh;
      width: 68vw; min-width: 110px; max-width: 320px;
      height: 78px;
      margin-left: -34vw;
      z-index: 6;
      background: transparent;
    }
    #powerBarCanvas {
      top: 73vh;
      width: 68vw; min-width: 110px; max-width: 320px;
      height: 44px;
      margin-left: -34vw;
      z-index: 6;
      background: transparent;
    }
    @media (orientation:landscape) {
      #aimArrowCanvas, #powerBarCanvas {
        top: 68vh;
      }
      #powerBarCanvas {
        top: 80vh;
      }
    }
  </style>
</head>
<body>
  <div id="retroUI">
    <div class="panel">SCORE:<br><span id="score">0</span></div>
    <div class="panel">STREAK:<br><span id="streak">0</span></div>
    <div id="instructions">
      TAP ONCE TO AIM<br>TAP AGAIN TO SHOOT<br>HIT HIGH STREAKS!
    </div>
  </div>
  <!-- Aim and Power Meter UI -->
  <div id="metersUI">
    <canvas id="aimArrowCanvas" width="300" height="78" class="meterPanel"></canvas>
    <canvas id="powerBarCanvas" width="300" height="44" class="meterPanel"></canvas>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
    // --- UI refs ---
    const scoreDisplay = document.getElementById("score");
    const streakDisplay = document.getElementById("streak");
    const aimCanvas = document.getElementById("aimArrowCanvas");
    const aimCtx = aimCanvas.getContext("2d");
    const powerCanvas = document.getElementById("powerBarCanvas");
    const powerCtx = powerCanvas.getContext("2d");
    const retroUI = document.getElementById("retroUI");
    const instructions = document.getElementById("instructions");

    // --- Three.js setup ---
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(74, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Lighting ---
    let light = new THREE.DirectionalLight(0xffffff, 2);
    light.position.set(6, 11, 8);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x4c4c7a));

    // --- Wood Court (Brown, shiny) ---
    let woodCourt = new THREE.Mesh(
      new THREE.PlaneGeometry(36, 35),
      new THREE.MeshPhongMaterial({
        color: 0xb97a57,
        shininess: 58,
        specular: 0xffffff,
        reflectivity: 0.17
      })
    );
    woodCourt.rotation.x = -Math.PI / 2;
    woodCourt.position.y = 0.005; // Tiny bit above zero for no z-fighting
    scene.add(woodCourt);

    // --- Knicks Crowd (checkerboard of blue, orange, white) ---
    function makeKnicksCrowd() {
      const group = new THREE.Group();
      // Knicks blue and orange, with some white
      let crowdColors = [
        0x006BB6, // Knicks Blue
        0xF58426, // Knicks Orange
        0xffffff, // White
      ];
      let yStart = 4.5, z = -13.5, crowdRows = 7, perRow = 18, w = 0.86, h = 1.15, d = 0.22;
      for (let row = 0; row < crowdRows; row++) {
        for (let i = 0; i < perRow; i++) {
          let checker = ((i + row) % 3);
          let box = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            new THREE.MeshPhongMaterial({ color: crowdColors[checker] })
          );
          box.position.set(
            -7.7 + (i * 0.90) + ((row % 2) * 0.44),
            yStart + (row * 1.04),
            z - (row * 0.7)
          );
          group.add(box);
        }
      }
      return group;
    }
    scene.add(makeKnicksCrowd());

    // --- Hoop, Rim, Backboard ---
    const backboard = new THREE.Mesh(
      new THREE.BoxGeometry(3.2, 2, 0.13),
      new THREE.MeshPhongMaterial({ color: 0xffffff })
    );
    backboard.position.set(0, 5, -12);
    scene.add(backboard);

    const rim = new THREE.Mesh(
      new THREE.TorusGeometry(0.7, 0.07, 14, 32),
      new THREE.MeshPhongMaterial({ color: 0xff4a3d })
    );
    rim.position.set(0, 4.18, -11.5);
    rim.rotation.x = Math.PI / 2;
    scene.add(rim);

    // Rim collision plane
    const rimPlane = { z: -11.5, y: 4.18, r: 0.66 };

    // --- Ball ---
    const ballGeometry = new THREE.SphereGeometry(0.31, 32, 32);
    const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xff9900 });
    const ball = new THREE.Mesh(ballGeometry, ballMaterial);
    scene.add(ball);

    // --- Game State ---
    let velocity = new THREE.Vector3();
    let isShot = false;
    let aiming = false;
    let powerMode = false;
    let aimAngle = 0;        // radians
    let powerLevel = 0;      // 0-1
    let score = 0, streak = 0;

    // --- UI meters ---
    function drawAimArrow(angle) {
      aimCtx.clearRect(0,0,aimCanvas.width,aimCanvas.height);
      let centerX = aimCanvas.width/2, centerY = aimCanvas.height-12;
      let arrowLen = aimCanvas.height * 0.68, tipSize = 14;
      let tipX = centerX + arrowLen * Math.sin(angle);
      let tipY = centerY - arrowLen * Math.cos(angle);
      aimCtx.save();
      aimCtx.strokeStyle = "#fff048";
      aimCtx.lineWidth = 8;
      aimCtx.shadowColor = "#00ff75";
      aimCtx.shadowBlur = 9;
      aimCtx.beginPath();
      aimCtx.moveTo(centerX, centerY);
      aimCtx.lineTo(tipX, tipY);
      aimCtx.stroke();
      aimCtx.restore();
      aimCtx.beginPath();
      aimCtx.arc(centerX, centerY, 12, 0, 2*Math.PI);
      aimCtx.fillStyle = "#00ff75";
      aimCtx.shadowBlur = 2;
      aimCtx.fill();
      aimCtx.beginPath();
      aimCtx.arc(tipX, tipY, tipSize, 0, 2*Math.PI);
      aimCtx.fillStyle = "#ff5858";
      aimCtx.fill();
      aimCtx.font = '14px "Press Start 2P", monospace';
      aimCtx.fillStyle = "#fff";
      aimCtx.textAlign = "center";
      aimCtx.fillText("AIM", centerX, 22);
    }

    function drawPowerBar(power) {
      powerCtx.clearRect(0,0,powerCanvas.width,powerCanvas.height);
      let w = powerCanvas.width-50, h = 18, x = 25, y = 22;
      powerCtx.save();
      powerCtx.strokeStyle = "#fff048";
      powerCtx.lineWidth = 5;
      powerCtx.strokeRect(x, y, w, h);
      let grad = powerCtx.createLinearGradient(x, y, x+w, y+h);
      grad.addColorStop(0, "#00ff75");
      grad.addColorStop(0.6, "#fff048");
      grad.addColorStop(1, "#ff5858");
      powerCtx.fillStyle = grad;
      powerCtx.fillRect(x, y, w*power, h);
      let px = x + w*power;
      powerCtx.beginPath();
      powerCtx.arc(px, y+h/2, 13, 0, 2*Math.PI);
      powerCtx.fillStyle = "#fff048";
      powerCtx.shadowBlur = 7;
      powerCtx.shadowColor = "#00ff75";
      powerCtx.fill();
      powerCtx.restore();
      powerCtx.font = '14px "Press Start 2P", monospace';
      powerCtx.fillStyle = "#fff";
      powerCtx.textAlign = "center";
      powerCtx.fillText("POWER", powerCanvas.width/2, 20);
    }

    // --- Ball Reset ---
    function resetBall(miss = false) {
      setTimeout(() => {
        ball.position.set(0, 1.5, 2);
        velocity.set(0, 0, 0);
        isShot = false;
        aiming = true;
        powerMode = false;
        aimAngle = 0;
        if (miss) streak = 0;
        streakDisplay.textContent = streak;
        showUI();
      }, 520);
    }

    // --- Main Shot Logic ---
    function takeShot() {
      let maxAim = Math.PI/17; // much smaller angle for easier aiming
      let dirX = Math.sin(aimAngle) * 0.61;
      let force = 0.11 + 0.23*powerLevel;
      velocity.set(dirX, force + 0.10, -0.17 - 0.10*powerLevel);
      isShot = true;
      aiming = false;
      powerMode = false;
      hideUI();
    }

    // --- Backboard Physics ---
    function checkBackboardCollision() {
      // Front face of the backboard is at z = -12, size x = 3.2, y = 2.0, center at (0, 5, -12)
      const bb = { z: -12, x1: -1.6, x2: 1.6, y1: 4, y2: 6 };
      // If moving forward, don't process
      if (velocity.z <= 0) return;
      // Did we just cross the backboard front face?
      if (
        ball.position.z < bb.z + 0.15 && // a little padding
        ball.position.z > bb.z - 0.21 &&
        ball.position.x > bb.x1 && ball.position.x < bb.x2 &&
        ball.position.y > bb.y1 && ball.position.y < bb.y2
      ) {
        // Bounce off: reflect z velocity, dampen a bit, add a bit of random side spin
        velocity.z *= -0.61;
        velocity.x += (Math.random()-0.5)*0.055;
        velocity.y *= 0.83;
        // Push ball out so it doesn't get stuck
        ball.position.z = bb.z + 0.17;
      }
    }

    // --- Scoring ---
    function checkScore() {
      if (
        ball.position.z < rimPlane.z + 0.10 && ball.position.z > rimPlane.z - 0.17 &&
        ball.position.y < rimPlane.y + 0.33 && ball.position.y > rimPlane.y - 0.29 &&
        Math.abs(ball.position.x) < rimPlane.r &&
        velocity.y < 0
      ) {
        score++;
        streak++;
        scoreDisplay.textContent = score;
        streakDisplay.textContent = streak;
        velocity.y = -0.04 - Math.random() * 0.012;
        velocity.z = 0;
        setTimeout(resetBall, 600);
        isShot = true;
      }
    }

    // --- Animation Loop ---
    let aimAnimAngle = 0, aimDir = 1;
    let powerAnim = 0, powerDir = 1;
    function animate() {
      requestAnimationFrame(animate);

      // Aim UI (MUCH slower and smaller angle)
      if (aiming && !isShot) {
        let maxAim = Math.PI/17;
        aimAnimAngle += 0.0082 * aimDir;
        if (aimAnimAngle > maxAim) { aimAnimAngle = maxAim; aimDir = -1; }
        if (aimAnimAngle < -maxAim) { aimAnimAngle = -maxAim; aimDir = 1; }
        drawAimArrow(aimAnimAngle);
        aimAngle = aimAnimAngle;
        powerCtx.clearRect(0,0,powerCanvas.width,powerCanvas.height);
      }
      // Power UI (MUCH slower)
      else if (powerMode && !isShot) {
        powerAnim += 0.0083 * powerDir;
        if (powerAnim > 1) { powerAnim = 1; powerDir = -1; }
        if (powerAnim < 0.24) { powerAnim = 0.24; powerDir = 1; }
        drawPowerBar(powerAnim);
        powerLevel = powerAnim;
        aimCtx.clearRect(0,0,aimCanvas.width,aimCanvas.height);
      }
      // Hide meters when ball is in flight
      else {
        aimCtx.clearRect(0,0,aimCanvas.width,aimCanvas.height);
        powerCtx.clearRect(0,0,powerCanvas.width,powerCanvas.height);
      }

      // Ball physics
      if (isShot) {
        velocity.y -= 0.008;
        ball.position.add(velocity);
        checkScore();
        checkBackboardCollision();
        // Rim "bounce"
        if (
          Math.abs(ball.position.z - rimPlane.z) < 0.10 &&
          ball.position.y < rimPlane.y + 0.2 &&
          Math.abs(ball.position.x) < rimPlane.r + 0.13 &&
          velocity.y < 0
        ) {
          velocity.y *= -0.44;
          velocity.x *= 0.42;
          velocity.z *= 0.7;
        }
        // Miss
        if (ball.position.y < 0.17 || ball.position.z < -15) {
          resetBall(true);
        }
      }
      renderer.render(scene, camera);
    }

    // --- UI Show/Hide for clarity when shot is in air
    function hideUI() {
      aimCanvas.style.opacity = "0";
      powerCanvas.style.opacity = "0";
      retroUI.style.opacity = "0.7";
      instructions.style.opacity = "0";
    }
    function showUI() {
      aimCanvas.style.opacity = "1";
      powerCanvas.style.opacity = "1";
      retroUI.style.opacity = "1";
      instructions.style.opacity = "1";
    }

    // --- Tap/Click Handling (Portrait UX) ---
    function tap() {
      if (!aiming && !powerMode && !isShot) {
        aiming = true;
        aimAnimAngle = 0;
        aimDir = 1;
        showUI();
      } else if (aiming && !powerMode) {
        aiming = false;
        powerMode = true;
        powerAnim = 0.28 + Math.random()*0.12;
        powerDir = 1;
      } else if (powerMode && !isShot) {
        powerMode = false;
        takeShot();
      }
    }
    window.addEventListener("mousedown", tap);
    window.addEventListener("touchstart", function(e){ e.preventDefault(); tap(); }, {passive:false});

    // --- Camera ---
    function setCamera() {
      if(window.innerHeight > window.innerWidth){
        camera.position.set(0, 2.5, 6.4);
        camera.lookAt(0, 4.5, -11.5);
      } else {
        camera.position.set(0, 2.1, 7.4);
        camera.lookAt(0, 4.2, -11.5);
      }
    }
    setCamera();

    // --- Responsive ---
    function resizeUI() {
      setTimeout(()=>{
        aimCanvas.width = Math.floor(window.innerWidth * 0.68);
        powerCanvas.width = Math.floor(window.innerWidth * 0.68);
        if (aimCanvas.width > 340) aimCanvas.width = 340;
        if (powerCanvas.width > 340) powerCanvas.width = 340;
        aimCanvas.height = 78;
        powerCanvas.height = 44;
      }, 10);
    }
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      setCamera();
      resizeUI();
    });

    // --- Start game ---
    resizeUI();
    resetBall();
    aiming = true;
    animate();
  </script>
</body>
</html>