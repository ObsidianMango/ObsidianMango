<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pop-A-Shot All-Star</title>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
  <style>
    body { margin: 0; overflow: hidden; background: #191715; }
    canvas { display: block; }
    #retroUI {
      position: absolute;
      top: 10px; left: 0; width: 100vw; z-index: 10; text-align: center; pointer-events: none;
    }
    .panel {
      display: inline-block;
      padding: 12px 0;
      width: 43vw; min-width: 90px; max-width: 160px;
      border: 4px solid #00ff75;
      border-radius: 9px;
      background: #222014;
      color: #ffeb59;
      font-family: 'Press Start 2P', monospace;
      font-size: 1em;
      margin: 0 1vw;
      box-shadow: 0 2px 10px #2f8a;
      text-shadow: 2px 2px 0 #000, 0 0 12px #fff82e;
      letter-spacing: 1px;
    }
    #instructions {
      color: #fff0b8;
      background: #0956ab;
      border: 3px solid #fff048;
      margin: 14px auto 0 auto;
      border-radius: 7px;
      font-size: 0.9em;
      width: 88vw; max-width: 330px;
      padding: 8px 0 8px 0;
      box-shadow: 0 2px 8px #2746ac;
      text-shadow: 1px 1px 0 #033b64;
      text-align: center;
    }
    #metersUI {
      position: absolute;
      left: 0; top: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 5;
    }
    #powerBarCanvas {
      position: absolute;
      left: 50%; top: 73vh;
      width: 76vw; min-width: 110px; max-width: 390px;
      height: 54px;
      margin-left: -38vw;
      z-index: 6;
      background: transparent;
      pointer-events: none;
    }
    .score-pop {
      position: absolute;
      font-family: 'Press Start 2P', monospace;
      font-size: 2.5em;
      font-weight: bold;
      color: #fff849;
      text-shadow:
        -3px -3px 8px #2d008a,  3px 3px 8px #F58426,
        0 0 20px #fff, 0 0 6px #00ff75,
        3px 0px 0px #191715, -3px 0px 0px #191715,
        0px 3px 0px #191715, 0px -3px 0px #191715;
      padding: 0.06em 0.25em;
      border-radius: 10px;
      border: 3px solid #fff;
      pointer-events: none;
      opacity: 0;
      z-index: 99;
      animation: popFade 1.15s forwards;
      user-select: none;
    }
    @keyframes popFade {
      0%   { transform: translateY(25px) scale(1.1); opacity: 0.95;}
      60%  { transform: translateY(-14px) scale(1.05); opacity: 1;}
      90%  { transform: translateY(-36px) scale(0.96); opacity: 0.9;}
      100% { transform: translateY(-54px) scale(0.95); opacity: 0;}
    }
  </style>
</head>
<body>
  <div id="retroUI">
    <div class="panel">SCORE:<br><span id="score">0</span></div>
    <div class="panel">STREAK:<br><span id="streak">0</span></div>
    <div id="instructions">
      TAP TO START POWER<br>TAP AGAIN IN YELLOW "SWEET SPOT" TO SHOOT!
    </div>
  </div>
  <div id="metersUI">
    <canvas id="powerBarCanvas" width="340" height="54"></canvas>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.min.js"></script>
  <script>
    // --- UI refs ---
    const scoreDisplay = document.getElementById("score");
    const streakDisplay = document.getElementById("streak");
    const powerCanvas = document.getElementById("powerBarCanvas");
    const powerCtx = powerCanvas.getContext("2d");

    // --- Three.js setup ---
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(73, window.innerWidth/window.innerHeight, 0.1, 1000);
    let renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // --- Lighting ---
    let light = new THREE.DirectionalLight(0xffffff, 2.3);
    light.position.set(6, 12, 7);
    scene.add(light);
    scene.add(new THREE.AmbientLight(0x6e7ab3, 0.52));

    // --- Realistic Wood Court ---
    let courtGroup = new THREE.Group();
    for(let x=-7; x<=7; x++){
      for(let z=-10; z<=15; z+=2){
        let stripe = new THREE.Mesh(
          new THREE.PlaneGeometry(1.06, 2.01),
          new THREE.MeshPhongMaterial({
            color: (x+z)%2===0 ? 0xd0b183 : 0xb08d57, shininess: 65, reflectivity: 0.21
          })
        );
        stripe.position.set(x*1.06, 0.012, z);
        stripe.rotation.x = -Math.PI/2;
        courtGroup.add(stripe);
      }
    }
    let key = new THREE.Mesh(
      new THREE.BoxGeometry(3.6, 0.01, 7),
      new THREE.MeshPhongMaterial({ color: 0xf6f2db })
    );
    key.position.set(0, 0.014, -8.5);
    courtGroup.add(key);
    let freeThrow = new THREE.Mesh(
      new THREE.TorusGeometry(1.7, 0.031, 12, 60),
      new THREE.MeshPhongMaterial({ color: 0xf6f2db })
    );
    freeThrow.position.set(0, 0.016, -5.2);
    freeThrow.rotation.x = -Math.PI/2;
    courtGroup.add(freeThrow);
    let centerCircle = new THREE.Mesh(
      new THREE.TorusGeometry(2.2, 0.034, 12, 60),
      new THREE.MeshPhongMaterial({ color: 0xf6f2db })
    );
    centerCircle.position.set(0, 0.016, 0);
    centerCircle.rotation.x = -Math.PI/2;
    courtGroup.add(centerCircle);
    scene.add(courtGroup);

    // --- Knicks Crowd (random) ---
    function makeKnicksCrowd() {
      const group = new THREE.Group();
      let crowdColors = [0x006BB6, 0xF58426, 0xffffff];
      let yStart = 4.7, z = -13.7, crowdRows = 8, perRow = 22, w = 0.8, h = 1.09, d = 0.22;
      for (let row = 0; row < crowdRows; row++) {
        for (let i = 0; i < perRow; i++) {
          let color = crowdColors[Math.floor(Math.random()*crowdColors.length)];
          let box = new THREE.Mesh(
            new THREE.BoxGeometry(w, h, d),
            new THREE.MeshPhongMaterial({ color: color })
          );
          box.position.set(
            -9 + (i * 0.85) + ((row % 2) * 0.40),
            yStart + (row * 1.01) + (Math.random()*0.17),
            z - (row * 0.82)
          );
          group.add(box);
        }
      }
      return group;
    }
    scene.add(makeKnicksCrowd());

    // --- More Realistic Post, Glass Backboard, Rim ---
    const post = new THREE.Mesh(
      new THREE.CylinderGeometry(0.11, 0.13, 8, 18),
      new THREE.MeshPhongMaterial({ color: 0xa7a7a7 })
    );
    post.position.set(0, 2.12, -12.7);
    scene.add(post);

    // Glass backboard
    const backboard = new THREE.Mesh(
      new THREE.BoxGeometry(3.1, 1.89, 0.13),
      new THREE.MeshPhongMaterial({
        color: 0xffffff, transparent: true, opacity: 0.89
      })
    );
    backboard.position.set(0, 5, -12);
    scene.add(backboard);

    // Rim
    const rim = new THREE.Mesh(
      new THREE.TorusGeometry(0.75, 0.08, 16, 32),
      new THREE.MeshPhongMaterial({ color: 0xF58426 })
    );
    rim.position.set(0, 4.18, -11.5);
    rim.rotation.x = Math.PI / 2;
    scene.add(rim);

    // Net (realistic mesh: a white open cylinder just under rim)
    const netGeo = new THREE.CylinderGeometry(0.74, 0.55, 0.58, 16, 1, true);
    const netMat = new THREE.MeshPhongMaterial({
      color: 0xffffff, wireframe: true, opacity: 0.85, transparent: true
    });
    const net = new THREE.Mesh(netGeo, netMat);
    net.position.set(0, 3.89, -11.5);
    scene.add(net);

    // Rim collision plane
    const rimPlane = { z: -11.5, y: 4.18, r: 0.78 };

    // --- Ball ---
    const ballGeometry = new THREE.SphereGeometry(0.31, 32, 32);
    const ballMaterial = new THREE.MeshPhongMaterial({ color: 0xff9900 });
    const ball = new THREE.Mesh(ballGeometry, ballMaterial);
    scene.add(ball);

    // --- Game State ---
    let velocity = new THREE.Vector3();
    let isShot = false;
    let powerMode = false;
    let powerLevel = 0;      // 0-1
    let score = 0, streak = 0;
    let awaitingPower = false;
    let scoredLastShot = false;
    let fallingThrough = false;
    let inNet = false;
    let floorBounce = false;

    // --- Power Meter ---
    let sweetSpotMin = 0.57, sweetSpotMax = 0.76;
    let powerAnim = 0.23, powerDir = 1;
    let powerActive = false;

    // --- Score Pop ---
    let scorePopSide = 1; // alternate left/right

    function spawnScorePop(pts) {
      let div = document.createElement('div');
      div.className = 'score-pop';
      div.textContent = pts > 1 ? '+2' : '+1';
      div.style.opacity = "1";
      // Alternate position
      let baseY = window.innerHeight * 0.33;
      let left = scorePopSide > 0 ? '65vw' : '15vw';
      div.style.left = left;
      div.style.top = baseY + 'px';
      div.style.borderColor = pts > 1 ? "#00ff75" : "#fff";
      div.style.color = pts > 1 ? "#00ffdc" : "#fff849";
      document.body.appendChild(div);
      setTimeout(()=>{div.style.opacity=0}, 800);
      setTimeout(()=>{if(div.parentNode)div.parentNode.removeChild(div);}, 1300);
      scorePopSide *= -1;
    }

    function drawPowerBar(power) {
      powerCtx.clearRect(0,0,powerCanvas.width,powerCanvas.height);
      let w = powerCanvas.width-38, h = 22, x = 19, y = 24;
      powerCtx.save();
      powerCtx.strokeStyle = "#fff048";
      powerCtx.lineWidth = 6;
      powerCtx.strokeRect(x, y, w, h);
      // SWEET SPOT
      let smin = x + w * sweetSpotMin;
      let smax = x + w * sweetSpotMax;
      powerCtx.fillStyle = "#ffe96b";
      powerCtx.globalAlpha = 0.67;
      powerCtx.fillRect(smin, y, smax-smin, h);
      powerCtx.globalAlpha = 1.0;
      // Bar fill
      let grad = powerCtx.createLinearGradient(x, y, x+w, y+h);
      grad.addColorStop(0, "#00ff75");
      grad.addColorStop(0.5, "#fff048");
      grad.addColorStop(1, "#ff5858");
      powerCtx.fillStyle = grad;
      powerCtx.fillRect(x, y, w*power, h);
      // Dot
      let px = x + w*power;
      powerCtx.beginPath();
      powerCtx.arc(px, y+h/2, 16, 0, 2*Math.PI);
      powerCtx.fillStyle = "#fff048";
      powerCtx.shadowBlur = 7;
      powerCtx.shadowColor = "#00ff75";
      powerCtx.fill();
      powerCtx.restore();
      powerCtx.font = '15px "Press Start 2P", monospace';
      powerCtx.fillStyle = "#0036cc";
      powerCtx.textAlign = "center";
      powerCtx.fillText("POWER", powerCanvas.width/2, 20);
      // SWEET SPOT label
      powerCtx.font = '11px "Press Start 2P", monospace';
      powerCtx.fillStyle = "#222";
      powerCtx.fillText("SWEET SPOT!", (smin+smax)/2, y+h-2);
    }

    // --- Ball Reset ---
    function resetBall(miss = false) {
      setTimeout(() => {
        ball.position.set(0, 1.5, 2);
        velocity.set(0, 0, 0);
        isShot = false;
        powerMode = false;
        awaitingPower = false;
        scoredLastShot = false;
        fallingThrough = false;
        inNet = false;
        floorBounce = false;
        showUI();
      }, 730);
    }

    // --- Main Shot Logic ---
    function takeShot(powerValue) {
      let swish = (powerValue >= sweetSpotMin && powerValue <= sweetSpotMax);
      let baseZ = -0.183 - 0.121*powerValue;
      let baseY = 0.12 + 0.182*powerValue;
      velocity.set(0, baseY, baseZ);
      isShot = true;
      powerMode = false;
      awaitingPower = false;
      hideUI();
      // Scoring
      let pts = 1;
      if(swish){
        if(streak >= 2) pts = 2;
        streak++;
        showFeedback(pts > 1 ? "DOUBLE! SWISH!" : "SWISH!", "#f6ff73");
      } else if (Math.abs(powerValue - (sweetSpotMin+sweetSpotMax)/2) < 0.14) {
        streak++;
        showFeedback("IN!", "#fff");
      } else {
        streak = 0;
        showFeedback("BRICK!", "#F58426");
      }
      if(streak > 0) {
        score += pts;
        scoreDisplay.textContent = score;
        streakDisplay.textContent = streak;
        scoredLastShot = pts;
      } else {
        scoredLastShot = 0;
      }
    }

    // --- Backboard Physics ---
    function checkBackboardCollision() {
      const bb = { z: -12, x1: -1.58, x2: 1.58, y1: 3.95, y2: 5.93 };
      if (velocity.z <= 0) return;
      if (
        ball.position.z < bb.z + 0.15 &&
        ball.position.z > bb.z - 0.21 &&
        ball.position.x > bb.x1 && ball.position.x < bb.x2 &&
        ball.position.y > bb.y1 && ball.position.y < bb.y2
      ) {
        velocity.z *= -0.65;
        velocity.y *= 0.83;
        ball.position.z = bb.z + 0.15;
      }
    }

    // --- Rim bounce ---
    function checkRimBounce() {
      if (
        Math.abs(ball.position.z - rimPlane.z) < 0.12 &&
        ball.position.y < rimPlane.y + 0.26 &&
        Math.abs(ball.position.x) < rimPlane.r + 0.13 &&
        velocity.y < 0
      ) {
        velocity.y *= -0.45;
        velocity.x *= 0.32;
        velocity.z *= 0.74;
      }
    }

    // --- Animate Ball Dropping Through Net and Floor Bounce ---
    function updateBallPhysics() {
      velocity.y -= 0.008;
      ball.position.add(velocity);

      // Detect ball falling through net after score
      if (scoredLastShot && !fallingThrough && ball.position.y < 3.7 && ball.position.z < -11.3 && ball.position.z > -11.7) {
        fallingThrough = true;
        inNet = true;
        // Give it a little extra drop through the net
        velocity.set(
          (Math.random() - 0.5) * 0.01,
          -0.07 - Math.random()*0.02,
          -0.015 + (Math.random()-0.5)*0.012
        );
      }
      // After it falls through, hit ground and bounce
      if (fallingThrough && !floorBounce && ball.position.y <= 0.32) {
        velocity.y *= -0.47;
        velocity.x *= 0.77;
        velocity.z *= 0.85;
        floorBounce = true;
        ball.position.y = 0.32;
      }
      // Let it bounce and roll, reset when almost still
      if (floorBounce && Math.abs(velocity.y) < 0.015 && ball.position.y <= 0.35) {
        velocity.set(0,0,0);
        setTimeout(resetBall, 500);
      }
      // Out of bounds or miss
      if (ball.position.y < 0.11 || ball.position.z < -15) {
        streak = 0;
        streakDisplay.textContent = streak;
        resetBall(true);
      }
    }

    // --- Scoring Animation/Reset ---
    function checkScore() {
      // Score detection (ball passing downward through rim area)
      if (
        !scoredLastShot &&
        ball.position.z < rimPlane.z + 0.12 && ball.position.z > rimPlane.z - 0.21 &&
        ball.position.y < rimPlane.y + 0.39 && ball.position.y > rimPlane.y - 0.34 &&
        Math.abs(ball.position.x) < rimPlane.r &&
        velocity.y < 0
      ) {
        if(scoredLastShot){
          spawnScorePop(scoredLastShot);
        }
      }
    }

    // --- Feedback text ---
    let feedbackTimeout = null;
    function showFeedback(txt, color="#fff") {
      // Don't show "MISS" if it's a falling ball
      if (txt==="MISS" && scoredLastShot) return;
      let feedbackText = document.getElementById("feedbackText");
      feedbackText.textContent = txt;
      feedbackText.style.color = color;
      feedbackText.style.opacity = 1;
      clearTimeout(feedbackTimeout);
      feedbackTimeout = setTimeout(()=>{feedbackText.style.opacity=0}, 1000);
    }

    // --- UI Show/Hide for clarity when shot is in air
    function hideUI() {
      powerCanvas.style.opacity = "0";
      document.getElementById("retroUI").style.opacity = "0.7";
      instructions.style.opacity = "0";
    }
    function showUI() {
      powerCanvas.style.opacity = "1";
      document.getElementById("retroUI").style.opacity = "1";
      instructions.style.opacity = "1";
    }

    // --- Tap/Click Handling ---
    function tap() {
      if (isShot) return;
      if (!awaitingPower) {
        awaitingPower = true;
        powerActive = true;
        powerAnim = Math.random()*0.13+0.23;
        powerDir = 1;
      } else {
        awaitingPower = false;
        powerActive = false;
        takeShot(powerLevel);
      }
    }
    window.addEventListener("mousedown", tap);
    window.addEventListener("touchstart", function(e){ e.preventDefault(); tap(); }, {passive:false});

    // --- Camera ---
    function setCamera() {
      if(window.innerHeight > window.innerWidth){
        camera.position.set(0, 2.1, 6.5);
        camera.lookAt(0, 4.45, -11.5);
      } else {
        camera.position.set(0, 1.7, 7.9);
        camera.lookAt(0, 4.1, -11.5);
      }
    }
    setCamera();

    // --- Responsive ---
    function resizeUI() {
      setTimeout(()=>{
        powerCanvas.width = Math.floor(window.innerWidth * 0.76);
        if (powerCanvas.width > 390) powerCanvas.width = 390;
        powerCanvas.height = 54;
      }, 10);
    }
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      setCamera();
      resizeUI();
    });

    // --- Animation Loop ---
    function animate() {
      requestAnimationFrame(animate);
      if (powerActive && awaitingPower && !isShot) {
        powerAnim += 0.0092 * powerDir;
        if (powerAnim > 1) { powerAnim = 1; powerDir = -1; }
        if (powerAnim < 0.18) { powerAnim = 0.18; powerDir = 1; }
        drawPowerBar(powerAnim);
        powerLevel = powerAnim;
      } else {
        powerCtx.clearRect(0,0,powerCanvas.width,powerCanvas.height);
      }
      if (isShot) {
        updateBallPhysics();
        checkScore();
        checkRimBounce();
        checkBackboardCollision();
      }
      renderer.render(scene, camera);
    }

    // --- Start game ---
    resizeUI();
    resetBall();
    animate();
  </script>
</body>
</html>