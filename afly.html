<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>✈️ Sky — Catapult Bomb + Bomb‑Cam</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
  #c{position:fixed;inset:0;width:100dvw;height:100dvh;display:block;touch-action:manipulation}
  #ui{position:fixed;inset:0;pointer-events:none}
  .stick-wrap{position:absolute;left:2.5vw;bottom:4vh;width:26vw;height:26vw;max-width:210px;max-height:210px;border-radius:50%;background:radial-gradient(rgba(255,255,255,.08),rgba(255,255,255,.03) 60%,transparent 61%);backdrop-filter:blur(2px);pointer-events:auto;touch-action:none;z-index:3}
  .stick{position:absolute;inset:0;margin:auto;width:32%;height:32%;border-radius:50%;background:radial-gradient(rgba(255,255,255,.25),rgba(255,255,255,.1));box-shadow:0 0 10px rgba(255,255,255,.25) inset}
  .throttle{position:absolute;right:3vw;bottom:4vh;width:48px;height:44vh;max-height:340px;border-radius:30px;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));backdrop-filter:blur(2px);pointer-events:auto;touch-action:none;display:flex;align-items:center;justify-content:center;z-index:3}
  .rail{position:absolute;width:6px;height:80%;background:rgba(255,255,255,.15);border-radius:4px}
  .nub{position:absolute;width:40px;height:40px;border-radius:50%;background:radial-gradient(rgba(255,255,255,.25),rgba(255,255,255,.1));left:4px;right:4px;margin:auto;box-shadow:0 0 10px rgba(255,255,255,.25) inset}
  .label{position:absolute;top:6px;left:10px;color:#ddd;font-size:12px;letter-spacing:.08em;text-transform:uppercase;opacity:.75;pointer-events:none}
  .perf{position:fixed;top:8px;right:10px;color:#9ae6ff;font-size:12px;opacity:.8}
  .hint{position:fixed;top:8px;left:10px;color:#ddd;font-size:12px;opacity:.7}
  .gear{position:fixed;left:50%;transform:translateX(-50%);bottom:10px;color:#ddd;font-size:12px;opacity:.75}
  .hud{position:fixed;top:8px;left:50%;transform:translateX(-50%);color:#fff;font-size:13px;letter-spacing:.08em;background:rgba(0,0,0,.25);padding:6px 10px;border-radius:10px;backdrop-filter:blur(4px)}
  /* SMALL, TOP-CENTER bomb buttons (no interference) */
  .bombPanel{position:fixed;left:50%;top:52px;transform:translateX(-50%);display:flex;gap:8px;pointer-events:auto;z-index:2}
  .bomb{width:56px;height:56px;border:0;border-radius:50%;font-weight:800;letter-spacing:.08em;color:#fff;font-size:11px;line-height:1;touch-action:manipulation}
  .bomb.drop{background:linear-gradient(180deg,#ff4b4b,#c71e1e);box-shadow:0 6px 18px rgba(255,75,75,.35)}
  .bomb.follow{background:linear-gradient(180deg,#4b8bff,#1e42c7);box-shadow:0 6px 18px rgba(75,139,255,.35)}
  .bomb:active{transform:scale(.96)}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div class="hint">3‑finger tap: pause · B/SPACE: drop · F: bomb‑cam · Double‑tap screen: drop</div>
  <div class="perf" id="fps">—</div>
  <div class="hud" id="hud">Score 0 · Towns 0/0</div>
  <div class="stick-wrap" id="joy"><div class="stick" id="stick"></div></div>
  <div class="throttle" id="throttle"><div class="label">THROTTLE</div><div class="rail"></div><div class="nub" id="nub"></div></div>
  <div class="gear" id="gearLabel">—</div>
  <div class="bombPanel">
    <button class="bomb drop" id="dropBtn" aria-label="Drop bomb">DROP</button>
    <button class="bomb follow" id="followBtn" aria-label="Drop & follow bomb">CAM</button>
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
import { ImprovedNoise } from "https://unpkg.com/three@0.165.0/examples/jsm/math/ImprovedNoise.js";

/* ---------- Renderer / Scene ---------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:false, powerPreference:'high-performance', alpha:false});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x99bbdd, 0.0010);

const camera = new THREE.PerspectiveCamera(65, 1, 0.6, 20000);
function sizeRendererToCanvas(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  renderer.setSize(w, h, false);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
sizeRendererToCanvas();
addEventListener('resize', sizeRendererToCanvas);
if (window.visualViewport) visualViewport.addEventListener('resize', sizeRendererToCanvas);

scene.add(new THREE.HemisphereLight(0x99c6ff, 0x223344, 0.85));
const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(200,400,100); scene.add(dir);

/* ---------- Sky Dome ---------- */
const skyGeo = new THREE.SphereGeometry(12000, 32, 16);
const skyMat = new THREE.ShaderMaterial({
  side:THREE.BackSide,
  uniforms:{ top:{value:new THREE.Color(0x88b8ff)}, bottom:{value:new THREE.Color(0xe8f4ff)}, sunDir:{value:new THREE.Vector3(0.4,0.9,0.1)}, t:{value:0} },
  vertexShader:`varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
  fragmentShader:`varying vec3 vPos; uniform vec3 top,bottom,sunDir; uniform float t;
    float h(vec2 p){return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);}
    float n(vec2 p){vec2 i=floor(p),f=fract(p);float a=h(i),b=h(i+vec2(1,0)),c=h(i+vec2(0,1)),d=h(i+vec2(1,1));vec2 u=f*f*(3.-2.*f);
      return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y;}
    void main(){ vec3 p=normalize(vPos); float yy=max(p.y,0.); vec3 grad=mix(bottom,top,pow(yy,.65));
      float s=max(dot(p,normalize(sunDir)),0.); vec3 sun=vec3(1.,.95,.85)*pow(s,16.);
      float clouds=smoothstep(.55,.75,n(p.xz*.35+t*.02));
      gl_FragColor=vec4(grad + sun + clouds*.07,1.); }`
});
scene.add(new THREE.Mesh(skyGeo, skyMat));

/* ---------- Ship ---------- */
function buildShip(){
  const g = new THREE.Group();
  const matA = new THREE.MeshStandardMaterial({color:0x7bd3ff, metalness:0.2, roughness:0.5, flatShading:true});
  const matB = new THREE.MeshStandardMaterial({color:0x125e84, metalness:0.4, roughness:0.4, flatShading:true});
  const matC = new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.1, roughness:0.2, emissive:0x224455, emissiveIntensity:0.08, flatShading:true});

  const hull = new THREE.Mesh(new THREE.CapsuleGeometry(3.4,6.0,6,14), matA); hull.rotation.x=Math.PI/2; g.add(hull);
  const keel = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.6,7), matB); keel.position.set(0,-1.4,0); g.add(keel);
  const wing = new THREE.Mesh(new THREE.BoxGeometry(10,0.3,2.0), matB); wing.position.set(0,0.2,-0.5); g.add(wing);
  const fin  = new THREE.Mesh(new THREE.ConeGeometry(1.2,3.2,4), matB); fin.position.set(0,0,5.8); fin.rotation.x=Math.PI; g.add(fin);
  const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6,16,16), new THREE.MeshBasicMaterial({color:0x88ddff})); glow.position.set(0,0,-4.8); g.add(glow);

  const gearGroup = new THREE.Group();
  const legG = new THREE.CylinderGeometry(0.12,0.12,3.0,8);
  function mkLeg(x){
    const leg = new THREE.Mesh(legG, matC);
    leg.position.set(x,-2.4,0.6);
    const foot = new THREE.Mesh(new THREE.BoxGeometry(1.0,0.22,1.4), matC);
    foot.position.set(0,-1.6,0.15);
    const tip = new THREE.Mesh(new THREE.SphereGeometry(0.1,10,10), new THREE.MeshBasicMaterial({color:0xffee66}));
    tip.position.set(0,-1.6,0.6);
    foot.add(tip);
    leg.add(foot);
    return leg;
  }
  gearGroup.add(mkLeg(-2.2), mkLeg(2.2), mkLeg(0));
  gearGroup.visible=false; g.add(gearGroup);

  const floatGroup = new THREE.Group();
  const pont = new THREE.CapsuleGeometry(0.6,3.2,4,8);
  const left = new THREE.Mesh(pont, matC); left.rotation.z=Math.PI/2; left.position.set(-5.2,-1.0,0.2);
  const right = left.clone(); right.position.x*=-1;
  floatGroup.add(left,right); floatGroup.visible=false; g.add(floatGroup);

  g.userData = {gearGroup, floatGroup};
  g.traverse(o=>{o.castShadow=false;o.receiveShadow=false});
  return g;
}
const ship = buildShip();
scene.add(ship);

/* ---------- Controls ---------- */
const joyWrap = document.getElementById('joy'), stick = document.getElementById('stick');
const throttleEl = document.getElementById('throttle'), nub = document.getElementById('nub');
const gearLabel = document.getElementById('gearLabel');
const dropBtn = document.getElementById('dropBtn');
const followBtn = document.getElementById('followBtn');
const hud = document.getElementById('hud');

let joyActive=false, joyDx=0, joyDy=0;
let throttle=0.5;
const joyRect = ()=> joyWrap.getBoundingClientRect();
joyWrap.addEventListener('pointerdown', ()=>{ joyActive=true; stick.style.transition='none'; });
addEventListener('pointermove', e=>{
  if(!joyActive) return;
  const r=joyRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
  const dx=e.clientX-cx, dy=e.clientY-cy, max=r.width*0.35;
  const d=Math.min(Math.hypot(dx,dy),max), a=Math.atan2(dy,dx);
  joyDx=Math.cos(a)*d/max; joyDy=Math.sin(a)*d/max;
  stick.style.transform=`translate(${joyDx*max}px,${joyDy*max}px)`;
},{passive:false});
addEventListener('pointerup', ()=>{ joyActive=false; joyDx=joyDy=0; stick.style.transition='transform 120ms ease-out'; stick.style.transform='translate(0,0)'; });

function throttleRect(){ return throttleEl.getBoundingClientRect(); }
function setThrottleFrom(y){
  const r=throttleRect(), pad=r.height*0.1;
  const clamped=Math.max(r.top+pad, Math.min(y, r.bottom-pad));
  throttle = 1 - (clamped-(r.top+pad))/((r.height-pad*2));
  throttle = Math.max(0, Math.min(1, throttle));
  const track=r.height*0.8, yPos=r.top+(1-throttle)*track+(r.height-track)/2-20;
  nub.style.top=(yPos-r.top)+'px';
}
throttleEl.addEventListener('pointerdown', e=>{ throttleEl.setPointerCapture(e.pointerId); setThrottleFrom(e.clientY); });
throttleEl.addEventListener('pointermove', e=>{ if(e.pressure===0) return; setThrottleFrom(e.clientY); });

/* Pause: 3-finger tap */
let paused=false, touchCount=0, touchTimer=0;
addEventListener('touchstart', e=>{ touchCount=e.touches.length; clearTimeout(touchTimer); touchTimer=setTimeout(()=>{ if(touchCount>=3) paused=!paused; },120); }, {passive:true});

/* Keyboard + bomb buttons (both launch out the FRONT) */
addEventListener('keydown', (e)=>{
  if(e.code==='Space' || e.code==='KeyB') dropBomb(false);
  if(e.code==='KeyF') dropBomb(true);
});
dropBtn.addEventListener('click', ()=> dropBomb(false), {passive:true});
followBtn.addEventListener('click', ()=> dropBomb(true), {passive:true});

/* ---------- Double‑tap anywhere to drop (prevent iOS zoom) ---------- */
let lastTapT = 0;
function onCanvasTouchStart(e){
  const now = performance.now();
  if(now - lastTapT < 280){
    // double tap
    e.preventDefault(); // block double‑tap zoom
    dropBomb(false);
    lastTapT = 0;
  }else{
    lastTapT = now;
  }
}
canvas.addEventListener('touchstart', onCanvasTouchStart, {passive:false});

/* ---------- Terrain (chunked) + Towns ---------- */
const seed=12345, noise=new ImprovedNoise();
function n2(x,y,scale=1){ return noise.noise(x/scale, y/scale, seed)*0.5+0.5; }

const CHUNK_SIZE=240, RES=48, LOAD_RADIUS=5;
const pool=[], chunks=new Map();

const terrainMat=new THREE.MeshStandardMaterial({flatShading:true,vertexColors:true,metalness:0,roughness:1});

function sampleHeight(wx,wz){
  const continent=n2(wx*0.6, wz*0.6, 1400);
  const ridges   =n2(wx, wz, 320);
  const detail   =n2(wx*3.7, wz*3.7, 90);
  let h = continent*0.55 + ridges*0.35 + detail*0.10;
  h = (h*1.15) - 0.35;
  return h*120;
}
function sampleClimate(wx,wz){
  const temp=n2(wx+10000, wz-5000, 1800);
  const wet =n2(wx-7000,  wz+3000, 1000);
  const hRaw=((n2(wx*0.6,wz*0.6,1400)*0.55 + n2(wx,wz,320)*0.35 + n2(wx*3.7,wz*3.7,90)*0.10)*1.15)-0.35;
  return {temp,wet,hRaw};
}
function biomeColor(h,t,w){
  if(h<0.47) return new THREE.Color().setHSL(0.58,0.45,0.45);
  if(h<0.50) return new THREE.Color(0xbedee8);
  if(h>0.82) return new THREE.Color(0xf0f2f2);
  if(t<0.35 && h>0.68) return new THREE.Color(0xd9e6f0);
  if(t>0.7 && w<0.35) return new THREE.Color(0xd9c58f);
  if(w>0.7 && t>0.5) return new THREE.Color(0x1c6b3a);
  if(w>0.55) return new THREE.Color(0x2e8f4f);
  return new THREE.Color(0x77b55a);
}

function makeChunk(ix,iz){
  let geom=pool.pop();
  if(!geom){ geom=new THREE.PlaneGeometry(CHUNK_SIZE,CHUNK_SIZE,RES,RES); geom.rotateX(-Math.PI/2); }
  const pos=geom.attributes.position.array;
  const color=new Float32Array((RES+1)*(RES+1)*3);
  const worldX0=ix*CHUNK_SIZE, worldZ0=iz*CHUNK_SIZE;
  for(let z=0; z<=RES; z++){
    for(let x=0; x<=RES; x++){
      const i=(z*(RES+1)+x), p=i*3;
      const wx=worldX0+(x/RES-0.5)*CHUNK_SIZE;
      const wz=worldZ0+(z/RES-0.5)*CHUNK_SIZE;
      const elev=sampleHeight(wx,wz);
      pos[p+1]=elev;
      const {temp,wet,hRaw}=sampleClimate(wx,wz);
      const c=biomeColor(hRaw+0.35,temp,wet);
      color[p]=c.r;color[p+1]=c.g;color[p+2]=c.b;
    }
  }
  geom.setAttribute('color', new THREE.BufferAttribute(color,3));
  geom.computeVertexNormals();
  const mesh=new THREE.Mesh(geom,terrainMat);
  mesh.position.set(worldX0,0,worldZ0);
  mesh.matrixAutoUpdate=false; mesh.updateMatrix();
  mesh.userData={ix,iz};
  return mesh;
}
const key=(ix,iz)=>ix+','+iz;
const toCreate=[];
function queueChunk(ix,iz,priority=0){ toCreate.push({ix,iz,priority}); }
function pumpCreate(budgetMs=9){
  toCreate.sort((a,b)=> b.priority - a.priority);
  const start=performance.now();
  while(toCreate.length && (performance.now()-start)<budgetMs){
    const {ix,iz}=toCreate.shift();
    const k=key(ix,iz);
    if(chunks.has(k)) continue;
    const m=makeChunk(ix,iz); scene.add(m); chunks.set(k,m);
    ensureTownFor(ix,iz);
  }
}
function updateChunks(px,pz,forward){
  const cx=Math.floor(px/CHUNK_SIZE);
  const cz=Math.floor(pz/CHUNK_SIZE);
  for(let dz=-LOAD_RADIUS; dz<=LOAD_RADIUS; dz++){
    for(let dx=-LOAD_RADIUS; dx<=LOAD_RADIUS; dx++){
      const ix=cx+dx, iz=cz+dz, k=key(ix,iz);
      if(chunks.has(k)) continue;
      const center=new THREE.Vector3(ix*CHUNK_SIZE,0,iz*CHUNK_SIZE);
      const rel=center.sub(new THREE.Vector3(px,0,pz));
      const prio = rel.normalize().dot(forward||new THREE.Vector3(0,0,-1))*100 - rel.length()/1000;
      queueChunk(ix,iz, prio);
    }
  }
  for(const [k,m] of chunks){
    const {ix,iz}=m.userData;
    if(Math.abs(ix-cx)>LOAD_RADIUS+1 || Math.abs(iz-cz)>LOAD_RADIUS+1){
      scene.remove(m); m.geometry.attributes.color?.dispose?.(); pool.push(m.geometry); chunks.delete(k);
      removeTown(ix,iz);
    }
  }
}

/* ---------- Towns ---------- */
const townGroups = new Map();
let totalBuildings=0, destroyedBuildings=0;

function rngFor(ix,iz){
  let s = (ix*73856093) ^ (iz*19349663) ^ 0x9e3779b9;
  return ()=>{ s ^= s<<13; s ^= s>>>17; s ^= s<<5; return (s>>>0)/4294967295; };
}
const houseGeo = new THREE.BoxGeometry(1,1,1);
const roofGeo  = new THREE.ConeGeometry(0.75,0.6,4);
const wallMat  = new THREE.MeshStandardMaterial({color:0xdad3c8, metalness:0, roughness:1, flatShading:true});
const roofMat  = new THREE.MeshStandardMaterial({color:0xa33a2a, metalness:0.1, roughness:0.9, flatShading:true});
const plazaMat = new THREE.MeshStandardMaterial({color:0xc9c2b3, metalness:0, roughness:1, flatShading:true});

function ensureTownFor(ix,iz){
  const k=key(ix,iz);
  if(townGroups.has(k)) return;
  const rand=rngFor(ix,iz);
  if(rand()>0.35) return;
  const baseX = ix*CHUNK_SIZE + (rand()-0.5)*CHUNK_SIZE*0.6;
  const baseZ = iz*CHUNK_SIZE + (rand()-0.5)*CHUNK_SIZE*0.6;
  const h = sampleHeight(baseX, baseZ);
  const slope =
    Math.abs(sampleHeight(baseX+5,baseZ)-h) +
    Math.abs(sampleHeight(baseX-5,baseZ)-h) +
    Math.abs(sampleHeight(baseX,baseZ+5)-h) +
    Math.abs(sampleHeight(baseX,baseZ-5)-h);
  if(h<5 || slope>30) return;

  const g = new THREE.Group();
  g.position.set(baseX, h, baseZ);

  const plaza = new THREE.Mesh(new THREE.BoxGeometry(16,0.2,16), plazaMat);
  plaza.position.y = -0.1;
  g.add(plaza);

  const buildings=[];
  const rows=4, cols=4, spacing=3.8;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      if(rand()<0.12) continue;
      const bx = (c-(cols-1)/2)*spacing + (rand()-0.5)*0.4;
      const bz = (r-(rows-1)/2)*spacing + (rand()-0.5)*0.4;
      const baseH = 1.0 + Math.floor(rand()*3);
      const house = new THREE.Mesh(houseGeo, wallMat);
      house.scale.set(1.8, baseH, 1.8);
      house.position.set(bx, baseH/2, bz);
      const roof = new THREE.Mesh(roofGeo, roofMat);
      roof.rotation.y = Math.PI*0.25;
      roof.position.set(bx, baseH+0.3, bz);
      g.add(house, roof);
      buildings.push({pos:new THREE.Vector3(bx,0,bz), alive:true, meshes:[house,roof]});
    }
  }

  if(buildings.length===0) return;
  scene.add(g);
  townGroups.set(k, {group:g, buildings});
  totalBuildings += buildings.length;
}
function removeTown(ix,iz){
  const k = key(ix,iz);
  const t = townGroups.get(k);
  if(!t) return;
  scene.remove(t.group);
  townGroups.delete(k);
}

/* ---------- Bombs, Catapult Launch, Explosions, Bomb‑Cam ---------- */
const bombs = [];
const explosions = [];
const bombGeo = new THREE.SphereGeometry(0.35,12,12);
const bombMat = new THREE.MeshStandardMaterial({color:0x333333, metalness:0.4, roughness:0.6});
let bombCooldown=0;

let cameraMode='chase';
let bombCamTarget=null;
const camDesiredPos = new THREE.Vector3();
const camDesiredLook = new THREE.Vector3();

function dropBomb(follow){
  if(bombCooldown>0 || paused) return;
  const b = new THREE.Mesh(bombGeo, bombMat);
  const nose = new THREE.Vector3(0,-0.2,-5.0).applyMatrix4(ship.matrixWorld);
  b.position.copy(nose);

  const fwd = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion).normalize();
  const up = new THREE.Vector3(0,1,0);
  const right = new THREE.Vector3().crossVectors(fwd, up).normalize();

  // Launch OUT THE FRONT (catapult arc)
  const launchSpeed = 90 + state.speed*0.6;
  const sideJitter  = (Math.random()-0.5)*2.0;
  const initialVel = new THREE.Vector3()
    .addScaledVector(fwd, launchSpeed)
    .addScaledVector(right, sideJitter)
    .addScaledVector(up, -3.5)
    .addScaledVector(state.vel, 0.25);

  b.userData = {vel:initialVel, alive:true};
  scene.add(b);
  bombs.push(b);
  bombCooldown = 0.18;

  if(follow){
    cameraMode='bomb';
    bombCamTarget=b;
  }
}

function spawnExplosion(x,y,z){
  const count=140;
  const geo=new THREE.BufferGeometry();
  const pos=new Float32Array(count*3);
  const vel=new Float32Array(count*3);
  for(let i=0;i<count;i++){
    const a=Math.random()*Math.PI*2, u=Math.random()*2-1;
    const sr=Math.sqrt(1-u*u);
    const dir=new THREE.Vector3(sr*Math.cos(a), u, sr*Math.sin(a));
    pos[i*3+0]=x; pos[i*3+1]=y; pos[i*3+2]=z;
    vel[i*3+0]=dir.x*(2.5+Math.random()*4);
    vel[i*3+1]=dir.y*(3.5+Math.random()*5);
    vel[i*3+2]=dir.z*(2.5+Math.random()*4);
  }
  geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
  geo.setAttribute('velocity', new THREE.BufferAttribute(vel,3));
  const mat=new THREE.PointsMaterial({size:0.25, color:0xffaa55, transparent:true, opacity:1});
  const p=new THREE.Points(geo,mat);
  p.userData={life:1.2};
  scene.add(p);
  explosions.push(p);
}

function stepBombs(dt){
  if(bombCooldown>0) bombCooldown -= dt;
  const grav = 9.8;
  for(let i=bombs.length-1;i>=0;i--){
    const b = bombs[i];
    if(!b.userData.alive) continue;

    b.userData.vel.y -= grav*dt;
    b.position.addScaledVector(b.userData.vel, dt);

    const gy = sampleHeight(b.position.x, b.position.z);
    if(b.position.y <= gy+0.35){
      b.userData.alive=false;
      scene.remove(b);
      bombs.splice(i,1);
      spawnExplosion(b.position.x, gy+0.5, b.position.z);
      if(cameraMode==='bomb' && bombCamTarget===b){ cameraMode='chase'; bombCamTarget=null; }

      const radius=8.0;
      for(const [,t] of townGroups){
        const wp = new THREE.Vector3();
        for(const bld of t.buildings){
          if(!bld.alive) continue;
          wp.copy(bld.pos).applyMatrix4(t.group.matrixWorld);
          if(wp.distanceToSquared(new THREE.Vector3(b.position.x, gy, b.position.z)) < radius*radius){
            bld.alive=false;
            for(const m of bld.meshes) m.visible=false;
            state.score += 10;
            destroyedBuildings++;
          }
        }
      }
    }
  }
}

function stepExplosions(dt){
  for(let i=explosions.length-1;i>=0;i--){
    const p = explosions[i];
    const life = p.userData.life - dt;
    p.userData.life = life;
    const pos = p.geometry.attributes.position;
    const vel = p.geometry.attributes.velocity;
    for(let j=0;j<pos.count;j++){
      vel.array[j*3+1] -= 9.8*dt*0.6;
      pos.array[j*3+0] += vel.array[j*3+0]*dt;
      pos.array[j*3+1] += vel.array[j*3+1]*dt;
      pos.array[j*3+2] += vel.array[j*3+2]*dt;
    }
    pos.needsUpdate = true;
    p.material.opacity = Math.max(life/1.2,0);
    if(life<=0){
      scene.remove(p);
      p.geometry.dispose(); p.material.dispose();
      explosions.splice(i,1);
    }
  }
}

/* ---------- Flight & Camera ---------- */
const state={
  speed:0, heading:0, pitch:0, roll:0,
  pos:new THREE.Vector3(0,60,0),
  vel:new THREE.Vector3(0,0,-1),
  onGround:false, onWater:false, gearDown:false, floatDown:false,
  score:0
};
const tmpV=new THREE.Vector3();
const camLocalOffset = new THREE.Vector3(0, 8, -20);
const camLookLocal   = new THREE.Vector3(0, 2, -6);
const worldPos = new THREE.Vector3();
const worldLook = new THREE.Vector3();
let cameraInitialized=false;

function stepShip(dt){
  const turn=joyDx, lift=-joyDy;

  const targetSpd = THREE.MathUtils.lerp(0, 180, throttle);
  state.speed = THREE.MathUtils.damp(state.speed, targetSpd, 2.5, dt);

  const groundY = sampleHeight(state.pos.x, state.pos.z);
  const altitude = state.pos.y - Math.max(0, groundY);
  state.onWater = groundY < 0 && state.pos.y <= 1.2;
  state.onGround = groundY >= 0 && (state.pos.y - groundY) <= 1.2;

  state.gearDown = (!state.onWater) && (altitude < 12 || state.speed < 25);
  state.floatDown = state.onWater || (groundY<0 && (altitude < 14 || state.speed < 25));

  ship.userData.gearGroup.visible = state.gearDown;
  ship.userData.floatGroup.visible = state.floatDown;

  state.heading += turn * dt * THREE.MathUtils.lerp(0.9, 2.0, Math.max(throttle,0.15));
  const pitchTarget = lift*0.45 * (state.onGround||state.onWater ? 0.2 : 1.0);
  state.pitch = THREE.MathUtils.damp(state.pitch, pitchTarget, 6, dt);
  state.roll  = THREE.MathUtils.damp(state.roll, -turn*0.6, 6, dt);

  const ch=Math.cos(state.heading), sh=Math.sin(state.heading);
  const cp=Math.cos(state.pitch),  sp=Math.sin(state.pitch);
  state.vel.set(sh*cp, sp, -ch*cp).multiplyScalar(state.speed);

  if(!(state.onGround||state.onWater)){
    const liftFactor = THREE.MathUtils.clamp(cp*state.speed*0.002, 0, 1.2);
    state.vel.y += (liftFactor - 0.25) * 9.8 * dt;
  }
  state.pos.addScaledVector(state.vel, dt);

  if(state.onGround){
    state.pos.y = Math.max(state.pos.y, groundY+1.0);
    state.speed = THREE.MathUtils.damp(state.speed, 0, 6, dt);
    state.pos.y = THREE.MathUtils.damp(state.pos.y, groundY+1.0, 8, dt);
  } else if(state.onWater){
    state.pos.y = Math.max(state.pos.y, 0.9);
    state.pos.y += Math.sin(performance.now()*0.003 + (state.pos.x+state.pos.z)*0.01)*0.03;
    state.speed = THREE.MathUtils.damp(state.speed, 0, 4, dt);
  } else {
    if(state.pos.y < 2) state.pos.y = THREE.MathUtils.damp(state.pos.y, 2, 3, dt);
  }

  ship.position.copy(state.pos);
  const lookFwd = tmpV.copy(state.pos).add(state.vel.clone().multiplyScalar(0.12));
  ship.lookAt(lookFwd); ship.rotateZ(state.roll);

  if(cameraMode==='chase'){
    ship.updateMatrixWorld(true);
    worldPos.copy(camLocalOffset).applyMatrix4(ship.matrixWorld);
    worldLook.copy(camLookLocal).applyMatrix4(ship.matrixWorld);
    camDesiredPos.copy(worldPos);
    camDesiredLook.copy(worldLook);
  } else if(cameraMode==='bomb' && bombCamTarget){
    const v = bombCamTarget.userData.vel.clone();
    if(v.lengthSq()<1e-3) v.set(0,0.1,0);
    const back = v.clone().normalize().multiplyScalar(6.5);
    const up = new THREE.Vector3(0,1,0).multiplyScalar(2.2);
    camDesiredPos.copy(bombCamTarget.position).sub(back).add(up);
    camDesiredLook.copy(bombCamTarget.position).add(v.clone().normalize().multiplyScalar(2.0));
  }

  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
  updateChunks(state.pos.x, state.pos.z, forward);

  gearLabel.textContent = state.onWater ? 'FLOATS' : (state.gearDown ? 'GEAR' : '—');
}

/* ---------- Loop / HUD ---------- */
const fpsEl=document.getElementById('fps'); let fpsAcc=0,fpsCount=0,fpsT=0;
let last=performance.now()/1000;
function tick(){
  const now=performance.now()/1000; const dt=Math.min(now-last,1/30); last=now;
  pumpCreate(9);
  if(!paused){
    stepShip(dt);
    stepBombs(dt);
    stepExplosions(dt);
    skyMat.uniforms.t.value += dt;

    if(!cameraInitialized){ camera.position.copy(camDesiredPos); cameraInitialized=true; }
    camera.position.lerp(camDesiredPos, 0.12);
    camera.lookAt(camDesiredLook);

    renderer.render(scene,camera);
  }
  fpsAcc+=1/dt; fpsCount++; if(now-fpsT>0.5){ fpsEl.textContent=(fpsAcc/fpsCount|0)+' fps'; fpsAcc=0; fpsCount=0; fpsT=now; }
  hud.textContent = `Score ${state.score} · Towns ${destroyedBuildings}/${totalBuildings}`;
  requestAnimationFrame(tick);
}

/* ---------- Init ---------- */
(function init(){
  updateChunks(0,0,new THREE.Vector3(0,0,-1));
  camDesiredPos.set(0,70,20); camDesiredLook.set(0,60,0);
  requestAnimationFrame(tick);
  setTimeout(()=>{ const r=throttleRect(); setThrottleFrom(r.top + (1-throttle)*r.height*0.8 + 20); },0);
  // Prevent UI buttons from blocking controls area; they already sit top-center.
  ['touchmove','gesturestart'].forEach(evt=>addEventListener(evt,e=>{
    if(e.target.closest('.stick-wrap,.throttle,.bombPanel')) e.preventDefault();
  }, {passive:false}));
})();
</script>
</body>
</html>