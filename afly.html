<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>SkySea — Stable Chase Cam + Free-Look + Waves</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  #c{position:fixed;inset:0;width:100dvw;height:100dvh;display:block;touch-action:none} /* prevent iOS nav/scroll on canvas */

  #ui{position:fixed;inset:0;pointer-events:none}
  .stick-wrap{position:absolute;left:2.5vw;bottom:4vh;width:26vw;height:26vw;max-width:210px;max-height:210px;border-radius:50%;background:radial-gradient(rgba(255,255,255,.08),rgba(255,255,255,.03) 60%,transparent 61%);backdrop-filter:blur(2px);pointer-events:auto;touch-action:none}
  .stick{position:absolute;inset:0;margin:auto;width:32%;height:32%;border-radius:50%;background:radial-gradient(rgba(255,255,255,.25),rgba(255,255,255,.1));box-shadow:0 0 10px rgba(255,255,255,.25) inset}
  .throttle{position:absolute;right:3vw;bottom:4vh;width:48px;height:44vh;max-height:340px;border-radius:30px;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));backdrop-filter:blur(2px);pointer-events:auto;touch-action:none;display:flex;align-items:center;justify-content:center}
  .rail{position:absolute;width:6px;height:80%;background:rgba(255,255,255,.15);border-radius:4px}
  .nub{position:absolute;width:40px;height:40px;border-radius:50%;background:radial-gradient(rgba(255,255,255,.25),rgba(255,255,255,.1));left:4px;right:4px;margin:auto;box-shadow:0 0 10px rgba(255,255,255,.25) inset}
  .label{position:absolute;top:6px;left:10px;color:#ddd;font-size:12px;letter-spacing:.08em;text-transform:uppercase;opacity:.75;pointer-events:none}
  .perf{position:fixed;top:8px;right:10px;color:#9ae6ff;font-size:12px;opacity:.8}
  .hint{position:fixed;top:8px;left:10px;color:#ddd;font-size:12px;opacity:.7}
  .gear{position:fixed;left:50%;transform:translateX(-50%);bottom:10px;color:#ddd;font-size:12px;opacity:.75}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div class="hint">Swipe/tap canvas: free-look • Double-tap: reset • 3-finger: pause</div>
  <div class="perf" id="fps">—</div>
  <div class="stick-wrap" id="joy"><div class="stick" id="stick"></div></div>
  <div class="throttle" id="throttle"><div class="label">THROTTLE</div><div class="rail"></div><div class="nub" id="nub"></div></div>
  <div class="gear" id="gearLabel">—</div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
import { ImprovedNoise } from "https://unpkg.com/three@0.165.0/examples/jsm/math/ImprovedNoise.js";

/* ---------- Renderer / Scene ---------- */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:false, powerPreference:'high-performance', alpha:false});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x99bbdd, 0.0010);

const camera = new THREE.PerspectiveCamera(65, 1, 0.6, 20000);
function sizeRendererToCanvas(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  renderer.setSize(w, h, false);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
sizeRendererToCanvas();
addEventListener('resize', sizeRendererToCanvas);
if (window.visualViewport) visualViewport.addEventListener('resize', sizeRendererToCanvas);

scene.add(new THREE.HemisphereLight(0x99c6ff, 0x223344, 0.85));
const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(200,400,100); scene.add(dir);

/* ---------- Ship ---------- */
function buildShip(){
  const g = new THREE.Group();
  const matA = new THREE.MeshStandardMaterial({color:0x7bd3ff, metalness:0.2, roughness:0.5, flatShading:true});
  const matB = new THREE.MeshStandardMaterial({color:0x125e84, metalness:0.4, roughness:0.4, flatShading:true});
  const matC = new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.1, roughness:0.2, emissive:0x224455, emissiveIntensity:0.08, flatShading:true});

  const hull = new THREE.Mesh(new THREE.CapsuleGeometry(3.4,6.0,6,14), matA); hull.rotation.x=Math.PI/2; g.add(hull);
  const keel = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.6,7), matB); keel.position.set(0,-1.4,0); g.add(keel);
  const wing = new THREE.Mesh(new THREE.BoxGeometry(10,0.3,2.0), matB); wing.position.set(0,0.2,-0.5); g.add(wing);
  const fin  = new THREE.Mesh(new THREE.ConeGeometry(1.2,3.2,4), matB); fin.position.set(0,0,5.8); fin.rotation.x=Math.PI; g.add(fin);
  const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6,16,16), new THREE.MeshBasicMaterial({color:0x88ddff})); glow.position.set(0,0,-4.8); g.add(glow);

  // Visible landing gear + floats
  const gearGroup = new THREE.Group();
  const legG = new THREE.CylinderGeometry(0.12,0.12,3.0,8);
  function mkLeg(x){
    const matC = new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.1, roughness:0.2, flatShading:true});
    const leg = new THREE.Mesh(legG, matC);
    leg.position.set(x,-2.4,0.6);
    const foot = new THREE.Mesh(new THREE.BoxGeometry(1.0,0.22,1.4), matC);
    foot.position.set(0,-1.6,0.15);
    const tip = new THREE.Mesh(new THREE.SphereGeometry(0.1,10,10), new THREE.MeshBasicMaterial({color:0xffee66}));
    tip.position.set(0,-1.6,0.6);
    foot.add(tip); leg.add(foot); return leg;
  }
  gearGroup.add(mkLeg(-2.2), mkLeg(2.2), mkLeg(0)); gearGroup.visible=false; g.add(gearGroup);

  const floatGroup = new THREE.Group();
  const pont = new THREE.CapsuleGeometry(0.6,3.2,4,8);
  const left = new THREE.Mesh(pont, new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.1, roughness:0.2, flatShading:true}));
  left.rotation.z=Math.PI/2; left.position.set(-5.2,-1.0,0.2);
  const right = left.clone(); right.position.x*=-1;
  floatGroup.add(left,right); floatGroup.visible=false; g.add(floatGroup);

  g.userData = {gearGroup, floatGroup};
  g.traverse(o=>{o.castShadow=false;o.receiveShadow=false});
  return g;
}
const ship = buildShip();
scene.add(ship);

/* ---------- Controls ---------- */
const joyWrap = document.getElementById('joy'), stick = document.getElementById('stick');
const throttleEl = document.getElementById('throttle'), nub = document.getElementById('nub');
const gearLabel = document.getElementById('gearLabel');

let joyActive=false, joyDx=0, joyDy=0;
let throttle=0.45; // 0..1

const joyRect = ()=> joyWrap.getBoundingClientRect();
joyWrap.addEventListener('pointerdown', e=>{ joyActive=true; stick.style.transition='none'; e.preventDefault(); });
addEventListener('pointermove', e=>{
  if(!joyActive) return;
  const r=joyRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
  const dx=e.clientX-cx, dy=e.clientY-cy, max=r.width*0.35;
  const d=Math.min(Math.hypot(dx,dy),max), a=Math.atan2(dy,dx);
  joyDx=Math.cos(a)*d/max; joyDy=Math.sin(a)*d/max;
  stick.style.transform=`translate(${joyDx*max}px,${joyDy*max}px)`;
  e.preventDefault();
},{passive:false});
addEventListener('pointerup', ()=>{ joyActive=false; joyDx=joyDy=0; stick.style.transition='transform 120ms ease-out'; stick.style.transform='translate(0,0)'; });

function throttleRect(){ return throttleEl.getBoundingClientRect(); }
function setThrottleFrom(y){
  const r=throttleRect(), pad=r.height*0.1;
  const clamped=Math.max(r.top+pad, Math.min(y, r.bottom-pad));
  throttle = 1 - (clamped-(r.top+pad))/((r.height-pad*2));
  throttle = Math.max(0, Math.min(1, throttle));
  const track=r.height*0.8, yPos=r.top+(1-throttle)*track+(r.height-track)/2-20;
  nub.style.top=(yPos-r.top)+'px';
}
throttleEl.addEventListener('pointerdown', e=>{ throttleEl.setPointerCapture(e.pointerId); setThrottleFrom(e.clientY); e.preventDefault(); });
throttleEl.addEventListener('pointermove', e=>{ if(e.pressure===0) return; setThrottleFrom(e.clientY); e.preventDefault(); }, {passive:false});

/* Pause: 3-finger tap */
let paused=false, touchCount=0, touchTimer=0;
addEventListener('touchstart', e=>{ touchCount=e.touches.length; clearTimeout(touchTimer); touchTimer=setTimeout(()=>{ if(touchCount>=3) paused=!paused; },120); }, {passive:true});

/* ---------- Terrain ---------- */
const seed=12345, noise=new ImprovedNoise();
function n2(x,y,scale=1){ return noise.noise(x/scale, y/scale, seed)*0.5+0.5; }

const CHUNK_SIZE=240, RES=48, LOAD_RADIUS=5;
const pool=[], chunks=new Map();

const terrainMat=new THREE.MeshStandardMaterial({flatShading:true,vertexColors:true,metalness:0,roughness:1});

function sampleHeight(wx,wz){
  const continent=n2(wx*0.6, wz*0.6, 1400);
  const ridges   =n2(wx, wz, 320);
  const detail   =n2(wx*3.7, wz*3.7, 90);
  let h = continent*0.55 + ridges*0.35 + detail*0.10;
  h = (h*1.15) - 0.35;
  return h*120;
}
function sampleClimate(wx,wz){
  const temp=n2(wx+10000, wz-5000, 1800);
  const wet =n2(wx-7000,  wz+3000, 1000);
  const hRaw=((n2(wx*0.6,wz*0.6,1400)*0.55 + n2(wx,wz,320)*0.35 + n2(wx*3.7,wz*3.7,90)*0.10)*1.15)-0.35;
  return {temp,wet,hRaw};
}
function biomeColor(h,t,w){
  if(h<0.47) return new THREE.Color().setHSL(0.58,0.45,0.45);
  if(h<0.50) return new THREE.Color(0xbedee8);
  if(h>0.82) return new THREE.Color(0xf0f2f2);
  if(t<0.35 && h>0.68) return new THREE.Color(0xd9e6f0);
  if(t>0.7 && w<0.35) return new THREE.Color(0xd9c58f);
  if(w>0.7 && t>0.5) return new THREE.Color(0x1c6b3a);
  if(w>0.55) return new THREE.Color(0x2e8f4f);
  return new THREE.Color(0x77b55a);
}

function makeChunk(ix,iz){
  let geom=pool.pop();
  if(!geom){ geom=new THREE.PlaneGeometry(CHUNK_SIZE,CHUNK_SIZE,RES,RES); geom.rotateX(-Math.PI/2); }
  const pos=geom.attributes.position.array;
  const color=new Float32Array((RES+1)*(RES+1)*3);
  const worldX0=ix*CHUNK_SIZE, worldZ0=iz*CHUNK_SIZE;

  for(let z=0; z<=RES; z++){
    for(let x=0; x<=RES; x++){
      const i=(z*(RES+1)+x), p=i*3;
      const wx=worldX0+(x/RES-0.5)*CHUNK_SIZE;
      const wz=worldZ0+(z/RES-0.5)*CHUNK_SIZE;
      const elev=sampleHeight(wx,wz);
      pos[p+1]=elev;
      const {temp,wet,hRaw}=sampleClimate(wx,wz);
      const c=biomeColor(hRaw+0.35,temp,wet);
      color[p]=c.r;color[p+1]=c.g;color[p+2]=c.b;
    }
  }
  geom.setAttribute('color', new THREE.BufferAttribute(color,3));
  geom.computeVertexNormals();

  const mesh=new THREE.Mesh(geom,terrainMat);
  mesh.position.set(worldX0,0,worldZ0);
  mesh.matrixAutoUpdate=false; mesh.updateMatrix();
  mesh.userData={ix,iz};
  return mesh;
}
const key=(ix,iz)=>ix+','+iz;

const toCreate=[];
function queueChunk(ix,iz,priority=0){ toCreate.push({ix,iz,priority}); }
function pumpCreate(budgetMs=9){
  toCreate.sort((a,b)=> b.priority - a.priority);
  const start=performance.now();
  while(toCreate.length && (performance.now()-start)<budgetMs){
    const {ix,iz}=toCreate.shift();
    const k=key(ix,iz);
    if(chunks.has(k)) continue;
    const m=makeChunk(ix,iz); scene.add(m); chunks.set(k,m);
  }
}
function updateChunks(px,pz,forward){
  const cx=Math.floor(px/CHUNK_SIZE);
  const cz=Math.floor(pz/CHUNK_SIZE);
  for(let dz=-LOAD_RADIUS; dz<=LOAD_RADIUS; dz++){
    for(let dx=-LOAD_RADIUS; dx<=LOAD_RADIUS; dx++){
      const ix=cx+dx, iz=cz+dz, k=key(ix,iz);
      if(chunks.has(k)) continue;
      const center=new THREE.Vector3(ix*CHUNK_SIZE,0,iz*CHUNK_SIZE);
      const rel=center.sub(new THREE.Vector3(px,0,pz));
      const prio = rel.normalize().dot(forward||new THREE.Vector3(0,0,-1))*100 - rel.length()/1000;
      queueChunk(ix,iz, prio);
    }
  }
  for(const [k,m] of chunks){
    const {ix,iz}=m.userData;
    if(Math.abs(ix-cx)>LOAD_RADIUS+1 || Math.abs(iz-cz)>LOAD_RADIUS+1){
      scene.remove(m); m.geometry.attributes.color?.dispose?.(); pool.push(m.geometry); chunks.delete(k);
    }
  }
}

/* ---------- Ocean (animated waves) ---------- */
let ocean, uTime;
(function buildOcean(){
  const size=3000, segs=96;
  const geom=new THREE.PlaneGeometry(size,size,segs,segs);
  geom.rotateX(-Math.PI/2);

  const uniforms={ uTime:(uTime={value:0}),
    uColorDeep:{value:new THREE.Color(0x1a5c78)},
    uColorShallow:{value:new THREE.Color(0x4bb3d3)},
    uFogColor:{value:scene.fog.color},
    uFogDensity:{value:scene.fog.density} };

  const vert=`
    uniform float uTime;
    varying vec3 vWorldPos;
    varying vec3 vNormalW;
    void main(){
      vec3 pos = position;
      float t = uTime*0.6;
      pos.y += sin(pos.x*0.02 + t)*0.6
             + sin(pos.z*0.018 - t*1.2)*0.45
             + sin((pos.x*0.012 + pos.z*0.014) + t*0.7)*0.35;
      vec4 wp = modelMatrix * vec4(pos,1.0);
      vWorldPos = wp.xyz;
      vec3 dx = dFdx(vWorldPos), dz = dFdy(vWorldPos);
      vNormalW = normalize(cross(dz,dx));
      gl_Position = projectionMatrix * viewMatrix * wp;
    }`;
  const frag=`
    uniform vec3 uColorDeep, uColorShallow, uFogColor;
    uniform float uFogDensity;
    varying vec3 vWorldPos, vNormalW;
    void main(){
      float depth = clamp(exp(-abs(vWorldPos.y)*0.15),0.0,1.0);
      vec3 base = mix(uColorDeep,uColorShallow,depth);
      vec3 N = normalize(vNormalW);
      vec3 V = normalize(cameraPosition - vWorldPos);
      float fres = pow(1.0 - max(dot(N,V),0.0),3.0);
      vec3 col = base + fres*0.25;
      float dist = length(cameraPosition - vWorldPos);
      float fog = 1.0 - exp(-uFogDensity*uFogDensity*dist*dist);
      gl_FragColor = vec4(mix(col,uFogColor,fog),1.0);
    }`;
  const mat=new THREE.ShaderMaterial({uniforms,vertexShader:vert,fragmentShader:frag,fog:true});
  ocean=new THREE.Mesh(geom,mat); ocean.position.y=0; ocean.frustumCulled=false; scene.add(ocean);
})();
function updateOceanFollow(pos){
  const tile=400;
  ocean.position.x = Math.round(pos.x/tile)*tile;
  ocean.position.z = Math.round(pos.z/tile)*tile;
}

/* ---------- Flight + Landing ---------- */
const state={
  speed:0, heading:0, pitch:0, roll:0,
  pos:new THREE.Vector3(0,60,0),
  vel:new THREE.Vector3(0,0,-1),
  onGround:false, onWater:false, gearDown:false, floatDown:false
};
const tmpV=new THREE.Vector3();

/* ---------- Stable chase camera (heading-only) + free-look ---------- */
const camBaseBack = 20;  // meters behind
const camBaseUp   = 8;   // meters above
const camLookAhead= 6;   // look-ahead distance

// Free-look deltas (radians)
let camYaw=0, camPitch=0, isCamDrag=false, camLastX=0, camLastY=0, camIdleTimer=0, lastTapTime=0;
const YAW_SENS=0.006, PIT_SENS=0.005, PIT_MIN=-0.6, PIT_MAX=0.6;

canvas.addEventListener('pointerdown', e=>{
  // ignore if dragging controls
  if(e.target.closest('.stick-wrap,.throttle')) return;
  const now = performance.now();
  if(now-lastTapTime < 280){ camYaw=0; camPitch=0; } // double-tap reset
  lastTapTime=now;
  isCamDrag=true; camLastX=e.clientX; camLastY=e.clientY; e.preventDefault();
}, {passive:false});
canvas.addEventListener('pointermove', e=>{
  if(!isCamDrag) return;
  const dx=e.clientX-camLastX, dy=e.clientY-camLastY;
  camLastX=e.clientX; camLastY=e.clientY;
  camYaw += dx*YAW_SENS;
  camPitch = THREE.MathUtils.clamp(camPitch + dy*PIT_SENS, PIT_MIN, PIT_MAX);
  camIdleTimer = 0; e.preventDefault();
}, {passive:false});
addEventListener('pointerup', ()=>{ isCamDrag=false; });

const camPosW = new THREE.Vector3(), camLookW = new THREE.Vector3();
function placeCamera(dt){
  // basis from heading only
  const sh=Math.sin(state.heading), ch=Math.cos(state.heading);
  const forward = new THREE.Vector3(sh,0,-ch);     // where ship points horizontally
  const right   = new THREE.Vector3(ch,0, sh);     // perpendicular
  const up      = new THREE.Vector3(0,1,0);

  // base chase offset
  let offset = new THREE.Vector3().copy(forward).multiplyScalar(-camBaseBack).addScaledVector(up, camBaseUp);

  // apply free-look yaw/pitch around ship using heading basis
  // yaw around world up, pitch around 'right'
  const qYaw = new THREE.Quaternion().setFromAxisAngle(up, camYaw);
  const qPit = new THREE.Quaternion().setFromAxisAngle(right, camPitch);
  offset.applyQuaternion(qYaw).applyQuaternion(qPit);

  camPosW.copy(state.pos).add(offset);
  const lookAhead = new THREE.Vector3().copy(forward).multiplyScalar(camLookAhead);
  lookAhead.applyQuaternion(qYaw).applyQuaternion(qPit);
  camLookW.copy(state.pos).add(lookAhead);

  camera.position.lerp(camPosW, 0.14);
  camera.lookAt(camLookW);

  // auto-reset
  if(!isCamDrag){
    camIdleTimer += dt;
    const strength = THREE.MathUtils.clamp(1.0 + camIdleTimer*1.5, 1.0, 4.0);
    camYaw   = THREE.MathUtils.damp(camYaw,   0, strength, dt);
    camPitch = THREE.MathUtils.damp(camPitch, 0, strength, dt);
  } else camIdleTimer=0;
}

/* ---------- Step ---------- */
const gearLabelEl=document.getElementById('gearLabel');
function stepShip(dt){
  const turn=joyDx, lift=-joyDy;

  const targetSpd = THREE.MathUtils.lerp(0, 180, throttle);
  state.speed = THREE.MathUtils.damp(state.speed, targetSpd, 2.5, dt);

  const groundY = sampleHeight(state.pos.x, state.pos.z);
  const altitude = state.pos.y - Math.max(0, groundY);
  state.onWater = groundY < 0 && state.pos.y <= 1.2;
  state.onGround = groundY >= 0 && (state.pos.y - groundY) <= 1.2;

  state.gearDown = (!state.onWater) && (altitude < 12 || state.speed < 25);
  state.floatDown = state.onWater || (groundY<0 && (altitude < 14 || state.speed < 25));

  ship.userData.gearGroup.visible = state.gearDown;
  ship.userData.floatGroup.visible = state.floatDown;

  // integrate heading/pitch/roll
  state.heading += turn * dt * THREE.MathUtils.lerp(0.9, 2.0, Math.max(throttle,0.15));
  const pitchTarget = lift*0.45 * (state.onGround||state.onWater ? 0.2 : 1.0);
  state.pitch = THREE.MathUtils.damp(state.pitch, pitchTarget, 6, dt);
  state.roll  = THREE.MathUtils.damp(state.roll, -turn*0.6, 6, dt);

  // velocity from heading & pitch
  const ch=Math.cos(state.heading), sh=Math.sin(state.heading);
  const cp=Math.cos(state.pitch),  sp=Math.sin(state.pitch);
  state.vel.set(sh*cp, sp, -ch*cp).multiplyScalar(state.speed);

  if(!(state.onGround||state.onWater)){
    const liftFactor = THREE.MathUtils.clamp(cp*state.speed*0.002, 0, 1.2);
    state.vel.y += (liftFactor - 0.25) * 9.8 * dt;
  }
  state.pos.addScaledVector(state.vel, dt);

  if(state.onGround){
    state.pos.y = Math.max(state.pos.y, groundY+1.0);
    state.speed = THREE.MathUtils.damp(state.speed, 0, 6, dt);
    state.pos.y = THREE.MathUtils.damp(state.pos.y, groundY+1.0, 8, dt);
  } else if(state.onWater){
    state.pos.y = Math.max(state.pos.y, 0.9);
    state.pos.y += Math.sin(performance.now()*0.003 + (state.pos.x+state.pos.z)*0.01)*0.03;
    state.speed = THREE.MathUtils.damp(state.speed, 0, 4, dt);
  } else if(state.pos.y < 2){
    state.pos.y = THREE.MathUtils.damp(state.pos.y, 2, 3, dt);
  }

  // orient ship toward velocity (visual)
  ship.position.copy(state.pos);
  const lookFwd = tmpV.copy(state.pos).add(state.vel.clone().multiplyScalar(0.12));
  ship.lookAt(lookFwd); ship.rotateZ(state.roll);

  // camera (stable heading-frame) & world streaming
  placeCamera(dt);
  const forward = new THREE.Vector3(Math.sin(state.heading),0,-Math.cos(state.heading));
  updateChunks(state.pos.x, state.pos.z, forward);

  // ocean
  updateOceanFollow(state.pos); uTime.value += dt;

  gearLabelEl.textContent = state.onWater ? 'FLOATS' : (state.gearDown ? 'GEAR' : '—');
}

/* ---------- Loop / FPS ---------- */
const fpsEl=document.getElementById('fps'); let fpsAcc=0,fpsCount=0,fpsT=0;
let last=performance.now()/1000;
function tick(){
  const now=performance.now()/1000; const dt=Math.min(now-last,1/30); last=now;
  pumpCreate(9);
  if(!paused){ stepShip(dt); renderer.render(scene,camera); }
  fpsAcc+=1/dt; fpsCount++; if(now-fpsT>0.5){ fpsEl.textContent=(fpsAcc/fpsCount|0)+' fps'; fpsAcc=0; fpsCount=0; fpsT=now; }
  requestAnimationFrame(tick);
}

/* ---------- Init ---------- */
(function init(){
  updateChunks(0,0,new THREE.Vector3(0,0,-1));
  requestAnimationFrame(tick);
  setTimeout(()=>{ const r=throttleRect(); setThrottleFrom(r.top + (1-throttle)*r.height*0.8 + 20); },0);
  // block default gestures only when touching controls—canvas already touch-action:none
  ['touchmove','gesturestart'].forEach(evt=>addEventListener(evt,e=>{ if(e.target.closest('.stick-wrap,.throttle')) e.preventDefault(); }, {passive:false}));
})();
</script>
</body>
</html>