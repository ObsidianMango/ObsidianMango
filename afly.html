<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>SkySea — Procedural Flyer</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:system-ui, -apple-system, Segoe UI, Roboto, sans-serif;}
  #ui{position:fixed;inset:0;pointer-events:none}
  /* Joystick (left) */
  .stick-wrap{position:absolute;left:2.5vw;bottom:4vh;width:26vw;height:26vw;max-width:210px;max-height:210px;border-radius:50%;background:radial-gradient(rgba(255,255,255,.08),rgba(255,255,255,.03) 60%, transparent 61%);backdrop-filter:blur(2px);pointer-events:auto;touch-action:none}
  .stick{position:absolute;inset:0;margin:auto;width:32%;height:32%;border-radius:50%;background:radial-gradient(rgba(255,255,255,.25),rgba(255,255,255,.1));box-shadow:0 0 10px rgba(255,255,255,.25) inset}
  /* Throttle (right) */
  .throttle{position:absolute;right:3vw;bottom:4vh;width:48px;height:44vh;max-height:340px;border-radius:30px;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));backdrop-filter:blur(2px);pointer-events:auto;touch-action:none;display:flex;align-items:center;justify-content:center}
  .rail{position:absolute;width:6px;height:80%;background:rgba(255,255,255,.15);border-radius:4px}
  .nub{position:absolute;width:40px;height:40px;border-radius:50%;background:radial-gradient(rgba(255,255,255,.25),rgba(255,255,255,.1));left:4px;right:4px;margin:auto;box-shadow:0 0 10px rgba(255,255,255,.25) inset}
  .label{position:absolute;top:6px;left:10px;color:#ddd;font-size:12px;letter-spacing:.08em;text-transform:uppercase;opacity:.75;pointer-events:none}
  /* Perf dot */
  .perf{position:fixed;top:8px;right:10px;color:#9ae6ff;font-size:12px;opacity:.8}
  /* Pause hint */
  .hint{position:fixed;top:8px;left:10px;color:#ddd;font-size:12px;opacity:.7}
</style>
</head>
<body>
<canvas id="c"></canvas>

<div id="ui" aria-hidden="false">
  <div class="hint">Tap with 3 fingers: pause</div>
  <div class="perf" id="fps">—</div>

  <div class="stick-wrap" id="joy">
    <div class="stick" id="stick"></div>
  </div>

  <div class="throttle" id="throttle">
    <div class="label">Throttle</div>
    <div class="rail"></div>
    <div class="nub" id="nub"></div>
  </div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
import { ImprovedNoise } from "https://unpkg.com/three@0.165.0/examples/jsm/math/ImprovedNoise.js";

/* ====== Core ====== */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:false, powerPreference:'high-performance', alpha:false});
renderer.setPixelRatio(Math.min( window.devicePixelRatio, 2 ));
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x99bbdd, 0.0009); // distant haze

const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.6, 20000);
camera.position.set(0, 8, 18);

const hemi = new THREE.HemisphereLight(0x99c6ff, 0x223344, 0.8);
scene.add(hemi);

const dir = new THREE.DirectionalLight(0xffffff, 1.0);
dir.position.set(200, 400, 100);
dir.castShadow = false;
scene.add(dir);

/* ====== Player (procedural hybrid ship) ====== */
function buildShip(){
  const g = new THREE.Group();

  const hull = new THREE.CapsuleGeometry(3.4, 6.0, 6, 14);
  const keel = new THREE.BoxGeometry(1.2, 0.6, 7);
  const fins = new THREE.ConeGeometry(1.2, 3.2, 4); // rear fin
  const wing = new THREE.BoxGeometry(10, 0.3, 2.0);
  const sponsons = new THREE.CylinderGeometry(0.5, 0.8, 6, 6);

  const matA = new THREE.MeshStandardMaterial({color:0x7bd3ff, metalness:0.2, roughness:0.5, flatShading:true});
  const matB = new THREE.MeshStandardMaterial({color:0x125e84, metalness:0.4, roughness:0.4, flatShading:true});
  const matC = new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.1, roughness:0.2, emissive:0x224455, emissiveIntensity:0.08, flatShading:true});

  const hullM = new THREE.Mesh(hull, matA); hullM.rotation.x = Math.PI/2;
  g.add(hullM);

  const keelM = new THREE.Mesh(keel, matB); keelM.position.set(0,-1.4,0); g.add(keelM);

  const wingM = new THREE.Mesh(wing, matB); wingM.position.set(0,0.2,-0.5); g.add(wingM);

  const finM = new THREE.Mesh(fins, matB); finM.position.set(0,0,5.8); finM.rotation.x = Math.PI; g.add(finM);

  const left = new THREE.Mesh(sponsons, matC); left.rotation.z = Math.PI/2; left.position.set(-5.4,-0.4,-0.5);
  const right = left.clone(); right.position.x *= -1;
  g.add(left,right);

  // Nose light
  const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6,16,16), new THREE.MeshBasicMaterial({color:0x88ddff}));
  glow.position.set(0,0,-4.8); g.add(glow);

  // “Water jets” / VTOL nozzles
  const jet = new THREE.CylinderGeometry(0.4,0.7,1.4,10);
  const j1 = new THREE.Mesh(jet, matC); j1.rotation.x = Math.PI/2; j1.position.set(-2,-0.8,2.6);
  const j2 = j1.clone(); j2.position.x = 2;
  g.add(j1,j2);

  g.traverse(o=>{o.castShadow=false;o.receiveShadow=false});
  return g;
}
const ship = buildShip();
scene.add(ship);

/* ====== Input — virtual joystick + throttle ====== */
const joyWrap = document.getElementById('joy');
const stick = document.getElementById('stick');
const throttleEl = document.getElementById('throttle');
const nub = document.getElementById('nub');

let joyActive=false, joyCx=0, joyCy=0, joyDx=0, joyDy=0;
let throttle=0.5; // 0..1

const joyRect = ()=> joyWrap.getBoundingClientRect();
joyWrap.addEventListener('pointerdown', e=>{ joyActive=true; joyCx=e.clientX; joyCy=e.clientY; stick.style.transition='none'; });
window.addEventListener('pointermove', e=>{
  if(!joyActive) return;
  const r = joyRect(); const cx = r.left+r.width/2, cy=r.top+r.height/2;
  const dx = e.clientX-cx, dy=e.clientY-cy;
  const max = r.width*0.35;
  const dist = Math.min(Math.hypot(dx,dy), max);
  const ang = Math.atan2(dy,dx);
  joyDx = Math.cos(ang)*dist/max;
  joyDy = Math.sin(ang)*dist/max;
  stick.style.transform = `translate(${joyDx*max}px, ${joyDy*max}px)`;
},{passive:false});
window.addEventListener('pointerup', ()=>{ 
  joyActive=false; 
  joyDx=joyDy=0; 
  stick.style.transition='transform 120ms ease-out';
  stick.style.transform='translate(0,0)';
});

function throttleRect(){ return throttleEl.getBoundingClientRect(); }
function setThrottleFrom(y){
  const r = throttleRect();
  const pad = r.height*0.1;
  const clamped = Math.max(r.top+pad, Math.min(y, r.bottom-pad));
  const t = 1 - (clamped-(r.top+pad))/((r.height-pad*2));
  throttle = Math.max(0, Math.min(1, t));
  const track = r.height*0.8;
  const yPos = r.top + (1-throttle)*track + (r.height-track)/2 - 20;
  nub.style.top = (yPos - r.top) + 'px';
}
throttleEl.addEventListener('pointerdown', e=>{
  throttleEl.setPointerCapture(e.pointerId);
  setThrottleFrom(e.clientY);
});
throttleEl.addEventListener('pointermove', e=>{
  if(e.pressure===0) return;
  setThrottleFrom(e.clientY);
});
/* Three-finger tap to pause */
let paused=false;
let touchCount=0, touchTimer=0;
window.addEventListener('touchstart', e=>{
  touchCount = e.touches.length;
  clearTimeout(touchTimer);
  touchTimer=setTimeout(()=>{ if(touchCount>=3) paused=!paused; }, 120);
},{passive:true});

/* ====== World gen (chunked heightfields) ====== */
const seed = 12345;
const noise = new ImprovedNoise();
function n2(x,y,scale=1){ return noise.noise(x/scale, y/scale, seed)*0.5+0.5; }

const CHUNK_SIZE = 240;    // meters across a chunk
const RES = 48;            // grid resolution per side (keep low for mobile)
const HALF = CHUNK_SIZE/2;
const LOAD_RADIUS = 3;     // chunks in each direction
const pool = [];           // geometry pool to avoid GC

const chunks = new Map();  // "ix,iz" -> Mesh

const terrainMat = new THREE.MeshStandardMaterial({
  flatShading:true, vertexColors:true, metalness:0.0, roughness:1.0
});

function biomeColor(h, temp, wet){
  // Simple biome palette by height/temperature/wetness
  // h: 0..1 (sea->mountain), temp:0..1 (cold->hot), wet:0..1 (dry->wet)
  if(h<0.47) return new THREE.Color().setHSL(0.58, 0.45, 0.45); // ocean teal
  if(h<0.50) return new THREE.Color(0xbedee8); // shore foam
  if(h>0.82) return new THREE.Color(0xf0f2f2); // snow cap
  if(temp<0.35 && h>0.68) return new THREE.Color(0xd9e6f0); // alpine
  if(temp>0.7 && wet<0.35) return new THREE.Color(0xd9c58f); // desert sand
  if(wet>0.7 && temp>0.5) return new THREE.Color(0x1c6b3a);  // jungle deep
  if(wet>0.55) return new THREE.Color(0x2e8f4f);             // forest
  return new THREE.Color(0x77b55a); // plains
}

function makeChunk(ix, iz){
  // reuse or create geometry
  let geom = pool.pop();
  if(!geom){
    geom = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, RES, RES);
    geom.rotateX(-Math.PI/2);
  }

  // fill height + color
  const pos = geom.attributes.position.array;
  const color = new Float32Array((RES+1)*(RES+1)*3);
  const col = new THREE.Color();

  const worldX0 = ix*CHUNK_SIZE;
  const worldZ0 = iz*CHUNK_SIZE;

  for(let z=0; z<=RES; z++){
    for(let x=0; x<=RES; x++){
      const i = (z*(RES+1)+x);
      const p = i*3;

      const wx = worldX0 + (x/RES-0.5)*CHUNK_SIZE;
      const wz = worldZ0 + (z/RES-0.5)*CHUNK_SIZE;

      // Elevation: layered noise
      const continent = n2(wx*0.6, wz*0.6, 1400);  // big shapes
      const ridges    = n2(wx, wz, 320);
      const detail    = n2(wx*3.7, wz*3.7, 90);

      let h = continent*0.55 + ridges*0.35 + detail*0.10;
      h = (h*1.15) - 0.35;              // bias to make oceans
      const elev = h*120;               // vertical scale (meters)

      pos[p+1] = elev;

      // Climate fields for biome
      const temp = n2(wx+10000, wz-5000, 1800); // slow field
      const wet  = n2(wx-7000,  wz+3000, 1000);

      const c = biomeColor(h+0.35, temp, wet); // shift so 0 is deep sea
      color[p+0]=c.r; color[p+1]=c.g; color[p+2]=c.b;
    }
  }
  geom.setAttribute('color', new THREE.BufferAttribute(color,3));
  geom.computeVertexNormals();

  const mesh = new THREE.Mesh(geom, terrainMat);
  mesh.position.set(worldX0, 0, worldZ0);
  mesh.matrixAutoUpdate = false;
  mesh.updateMatrix();

  // mark
  mesh.userData = {ix,iz};
  return mesh;
}

function key(ix,iz){ return ix+','+iz; }

function updateChunks(px,pz){
  const cx = Math.floor(px/CHUNK_SIZE);
  const cz = Math.floor(pz/CHUNK_SIZE);

  // Load needed
  for(let dz=-LOAD_RADIUS; dz<=LOAD_RADIUS; dz++){
    for(let dx=-LOAD_RADIUS; dx<=LOAD_RADIUS; dx++){
      const k = key(cx+dx, cz+dz);
      if(!chunks.has(k)){
        // stagger creation to avoid spikes
        queueChunk(cx+dx, cz+dz);
      }
    }
  }
  // Unload far
  for(const [k,mesh] of chunks){
    const {ix,iz} = mesh.userData;
    if(Math.abs(ix-cx)>LOAD_RADIUS+1 || Math.abs(iz-cz)>LOAD_RADIUS+1){
      scene.remove(mesh);
      mesh.geometry.attributes.color?.dispose?.();
      // recycle geometry (keep index/position arrays)
      pool.push(mesh.geometry);
      chunks.delete(k);
    }
  }
}

/* Lightweight creation queue to keep frame time low on mobile */
const toCreate = [];
function queueChunk(ix,iz){
  toCreate.push([ix,iz]);
}
function pumpCreate(budgetMs=6){ // ~6ms per frame for gen
  const start = performance.now();
  while(toCreate.length && (performance.now()-start)<budgetMs){
    const [ix,iz] = toCreate.shift();
    const m = makeChunk(ix,iz);
    scene.add(m);
    chunks.set(key(ix,iz), m);
  }
}

/* ====== Motion / camera spring ====== */
const state = {
  speed: 40,   // m/s base
  yaw: 0, pitch: 0, roll: 0,
  heading: 0, altitude: 40,
  vel: new THREE.Vector3(0,0,-1),
  up: new THREE.Vector3(0,1,0),
  pos: new THREE.Vector3(0,60,0),
};
const tmpV = new THREE.Vector3();
const follow = {pos:new THREE.Vector3(), target:new THREE.Vector3(), vel:new THREE.Vector3()};

function stepShip(dt){
  // inputs
  const turn = joyDx;       // left/right
  const lift = -joyDy;      // up/down

  // throttle curve
  const minS=18, maxS=180;
  const spd = THREE.MathUtils.lerp(minS, maxS, throttle);
  state.speed = THREE.MathUtils.damp(state.speed, spd, 2.5, dt);

  // yaw/pitch integrators
  state.heading += turn * dt * THREE.MathUtils.lerp(0.9, 2.2, throttle);
  state.pitch   = THREE.MathUtils.damp(state.pitch, lift*0.45, 8, dt);
  state.roll    = THREE.MathUtils.damp(state.roll, -turn*0.6, 6, dt);

  // forward vector from heading/pitch
  const ch = Math.cos(state.heading), sh = Math.sin(state.heading);
  const cp = Math.cos(state.pitch), sp = Math.sin(state.pitch);
  state.vel.set(sh*cp, sp, -ch*cp).multiplyScalar(state.speed);

  // update position
  state.pos.addScaledVector(state.vel, dt);

  // prevent going far below sea level (soft clamp)
  if(state.pos.y < 6) state.pos.y = THREE.MathUtils.damp(state.pos.y, 6, 4, dt);
  // mild gravity when throttle low
  if(throttle<0.25) state.pos.y -= (0.6 - throttle)*10*dt;

  // orient ship
  ship.position.copy(state.pos);
  const look = tmpV.copy(state.pos).add(state.vel.clone().multiplyScalar(0.15));
  ship.lookAt(look);
  ship.rotateZ(state.roll);

  // camera follow spring
  follow.target.copy(ship.position).add( tmpV.copy(state.vel).multiplyScalar(0.06) ).add(new THREE.Vector3(0,4,0));
  follow.pos.lerp(follow.target.clone().add(new THREE.Vector3(0,6,16)), 0.06);
  camera.position.copy(follow.pos);
  camera.lookAt(ship.position.x, ship.position.y+1.5, ship.position.z);

  // world streaming
  updateChunks(state.pos.x, state.pos.z);
}

/* ====== Resize ====== */
function onResize(){
  const w = window.innerWidth, h=window.innerHeight;
  renderer.setSize(w,h,false);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
window.addEventListener('resize', onResize);

/* ====== FPS meter (tiny) ====== */
const fpsEl = document.getElementById('fps');
let fpsAcc=0, fpsCount=0, fpsTimer=0;

/* ====== Main loop ====== */
let last = performance.now()/1000;
function frame(){
  const now = performance.now()/1000;
  let dt = now-last; last=now;
  dt = Math.min(dt, 1/30); // avoid giant steps

  pumpCreate( (renderer.capabilities.isWebGL2? 7:5) ); // creation budget

  if(!paused){
    stepShip(dt);
    renderer.render(scene, camera);
  }

  // fps
  fpsAcc += 1/dt; fpsCount++;
  if(now-fpsTimer>0.5){ fpsEl.textContent = (fpsAcc/fpsCount).toFixed(0)+' fps'; fpsAcc=0; fpsCount=0; fpsTimer=now; }

  requestAnimationFrame(frame);
}
updateChunks(0,0);
requestAnimationFrame(frame);

/* ====== Initial throttle nub placement ====== */
setTimeout(()=>{ setThrottleFrom(throttleRect().top + (1-throttle)*throttleRect().height*0.8 + 20); }, 0);

/* ====== Prevent pull-to-refresh/scroll on controls ====== */
['touchmove','gesturestart'].forEach(evt=>{
  window.addEventListener(evt, e=>{ if(e.target.closest('.stick-wrap, .throttle')) e.preventDefault(); }, {passive:false});
});
</script>
</body>
</html>