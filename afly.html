<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>SkySea — Centered Chase Cam</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  /* Canvas fills the true visible viewport on iOS (no URL-bar jump). */
  #c{position:fixed;inset:0;width:100dvw;height:100dvh;display:block}

  #ui{position:fixed;inset:0;pointer-events:none}
  .stick-wrap{position:absolute;left:2.5vw;bottom:4vh;width:26vw;height:26vw;max-width:210px;max-height:210px;border-radius:50%;background:radial-gradient(rgba(255,255,255,.08),rgba(255,255,255,.03) 60%,transparent 61%);backdrop-filter:blur(2px);pointer-events:auto;touch-action:none}
  .stick{position:absolute;inset:0;margin:auto;width:32%;height:32%;border-radius:50%;background:radial-gradient(rgba(255,255,255,.25),rgba(255,255,255,.1));box-shadow:0 0 10px rgba(255,255,255,.25) inset}
  .throttle{position:absolute;right:3vw;bottom:4vh;width:48px;height:44vh;max-height:340px;border-radius:30px;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(255,255,255,.02));backdrop-filter:blur(2px);pointer-events:auto;touch-action:none;display:flex;align-items:center;justify-content:center}
  .rail{position:absolute;width:6px;height:80%;background:rgba(255,255,255,.15);border-radius:4px}
  .nub{position:absolute;width:40px;height:40px;border-radius:50%;background:radial-gradient(rgba(255,255,255,.25),rgba(255,255,255,.1));left:4px;right:4px;margin:auto;box-shadow:0 0 10px rgba(255,255,255,.25) inset}
  .label{position:absolute;top:6px;left:10px;color:#ddd;font-size:12px;letter-spacing:.08em;text-transform:uppercase;opacity:.75;pointer-events:none}
  .perf{position:fixed;top:8px;right:10px;color:#9ae6ff;font-size:12px;opacity:.8}
  .hint{position:fixed;top:8px;left:10px;color:#ddd;font-size:12px;opacity:.7}
  .gear{position:fixed;left:50%;transform:translateX(-50%);bottom:10px;color:#ddd;font-size:12px;opacity:.75}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <div class="hint">Tap with 3 fingers: pause</div>
  <div class="perf" id="fps">—</div>
  <div class="stick-wrap" id="joy"><div class="stick" id="stick"></div></div>
  <div class="throttle" id="throttle"><div class="label">THROTTLE</div><div class="rail"></div><div class="nub" id="nub"></div></div>
  <div class="gear" id="gearLabel">—</div>
</div>

<script type="module">
import * as THREE from "https://unpkg.com/three@0.165.0/build/three.module.js";
import { ImprovedNoise } from "https://unpkg.com/three@0.165.0/examples/jsm/math/ImprovedNoise.js";

/* ============== Renderer / Scene ============== */
const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:false, powerPreference:'high-performance', alpha:false});
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x99bbdd, 0.0010);

const camera = new THREE.PerspectiveCamera(65, 1, 0.6, 20000);

function sizeRendererToCanvas(){
  const w = canvas.clientWidth, h = canvas.clientHeight;
  renderer.setSize(w, h, false);
  camera.aspect = w/h; camera.updateProjectionMatrix();
}
sizeRendererToCanvas();
addEventListener('resize', sizeRendererToCanvas);
if (window.visualViewport) visualViewport.addEventListener('resize', sizeRendererToCanvas);

scene.add(new THREE.HemisphereLight(0x99c6ff, 0x223344, 0.85));
const dir = new THREE.DirectionalLight(0xffffff, 1.0); dir.position.set(200,400,100); scene.add(dir);

/* ============== Ship with gear/floats ============== */
function buildShip(){
  const g = new THREE.Group();
  const matA = new THREE.MeshStandardMaterial({color:0x7bd3ff, metalness:0.2, roughness:0.5, flatShading:true});
  const matB = new THREE.MeshStandardMaterial({color:0x125e84, metalness:0.4, roughness:0.4, flatShading:true});
  const matC = new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.1, roughness:0.2, emissive:0x224455, emissiveIntensity:0.08, flatShading:true});

  const hull = new THREE.Mesh(new THREE.CapsuleGeometry(3.4,6.0,6,14), matA); hull.rotation.x=Math.PI/2; g.add(hull);
  const keel = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.6,7), matB); keel.position.set(0,-1.4,0); g.add(keel);
  const wing = new THREE.Mesh(new THREE.BoxGeometry(10,0.3,2.0), matB); wing.position.set(0,0.2,-0.5); g.add(wing);
  const fin  = new THREE.Mesh(new THREE.ConeGeometry(1.2,3.2,4), matB); fin.position.set(0,0,5.8); fin.rotation.x=Math.PI; g.add(fin);
  const glow = new THREE.Mesh(new THREE.SphereGeometry(0.6,16,16), new THREE.MeshBasicMaterial({color:0x88ddff})); glow.position.set(0,0,-4.8); g.add(glow);

  // Gear
  const gearGroup = new THREE.Group();
  const legG = new THREE.CylinderGeometry(0.12,0.12,2,8);
  const footG = new THREE.BoxGeometry(0.8,0.2,1.2);
  function mkLeg(x){ const leg=new THREE.Mesh(legG,matC); leg.position.set(x,-2,0.6); const foot=new THREE.Mesh(footG,matC); foot.position.set(0,-1.2,0.1); leg.add(foot); return leg; }
  gearGroup.add(mkLeg(-2.2), mkLeg(2.2), mkLeg(0));
  gearGroup.visible=false; g.add(gearGroup);

  // Floats
  const floatGroup = new THREE.Group();
  const pont = new THREE.CapsuleGeometry(0.6,3.2,4,8);
  const left = new THREE.Mesh(pont, matC); left.rotation.z=Math.PI/2; left.position.set(-5.2,-1.0,0.2);
  const right = left.clone(); right.position.x*=-1;
  floatGroup.add(left,right); floatGroup.visible=false; g.add(floatGroup);

  g.userData = {gearGroup, floatGroup};
  g.traverse(o=>{o.castShadow=false;o.receiveShadow=false});
  return g;
}
const ship = buildShip();
scene.add(ship);

/* ============== Controls ============== */
const joyWrap = document.getElementById('joy'), stick = document.getElementById('stick');
const throttleEl = document.getElementById('throttle'), nub = document.getElementById('nub');
const gearLabel = document.getElementById('gearLabel');

let joyActive=false, joyDx=0, joyDy=0;
let throttle=0.45; // 0..1

const joyRect = ()=> joyWrap.getBoundingClientRect();
joyWrap.addEventListener('pointerdown', ()=>{ joyActive=true; stick.style.transition='none'; });
addEventListener('pointermove', e=>{
  if(!joyActive) return;
  const r=joyRect(), cx=r.left+r.width/2, cy=r.top+r.height/2;
  const dx=e.clientX-cx, dy=e.clientY-cy, max=r.width*0.35;
  const d=Math.min(Math.hypot(dx,dy),max), a=Math.atan2(dy,dx);
  joyDx=Math.cos(a)*d/max; joyDy=Math.sin(a)*d/max;
  stick.style.transform=`translate(${joyDx*max}px,${joyDy*max}px)`;
},{passive:false});
addEventListener('pointerup', ()=>{ joyActive=false; joyDx=joyDy=0; stick.style.transition='transform 120ms ease-out'; stick.style.transform='translate(0,0)'; });

function throttleRect(){ return throttleEl.getBoundingClientRect(); }
function setThrottleFrom(y){
  const r=throttleRect(), pad=r.height*0.1;
  const clamped=Math.max(r.top+pad, Math.min(y, r.bottom-pad));
  throttle = 1 - (clamped-(r.top+pad))/((r.height-pad*2));
  throttle = Math.max(0, Math.min(1, throttle));
  const track=r.height*0.8, yPos=r.top+(1-throttle)*track+(r.height-track)/2-20;
  nub.style.top=(yPos-r.top)+'px';
}
throttleEl.addEventListener('pointerdown', e=>{ throttleEl.setPointerCapture(e.pointerId); setThrottleFrom(e.clientY); });
throttleEl.addEventListener('pointermove', e=>{ if(e.pressure===0) return; setThrottleFrom(e.clientY); });

/* Pause: 3-finger tap */
let paused=false, touchCount=0, touchTimer=0;
addEventListener('touchstart', e=>{ touchCount=e.touches.length; clearTimeout(touchTimer); touchTimer=setTimeout(()=>{ if(touchCount>=3) paused=!paused; },120); }, {passive:true});

/* ============== Terrain (chunked) ============== */
const seed=12345, noise=new ImprovedNoise();
function n2(x,y,scale=1){ return noise.noise(x/scale, y/scale, seed)*0.5+0.5; }

const CHUNK_SIZE=240, RES=48, LOAD_RADIUS=5;
const pool=[], chunks=new Map();

const terrainMat=new THREE.MeshStandardMaterial({flatShading:true,vertexColors:true,metalness:0,roughness:1});

function sampleHeight(wx,wz){
  const continent=n2(wx*0.6, wz*0.6, 1400);
  const ridges   =n2(wx, wz, 320);
  const detail   =n2(wx*3.7, wz*3.7, 90);
  let h = continent*0.55 + ridges*0.35 + detail*0.10;
  h = (h*1.15) - 0.35;
  return h*120;
}
function sampleClimate(wx,wz){
  const temp=n2(wx+10000, wz-5000, 1800);
  const wet =n2(wx-7000,  wz+3000, 1000);
  const hRaw=((n2(wx*0.6,wz*0.6,1400)*0.55 + n2(wx,wz,320)*0.35 + n2(wx*3.7,wz*3.7,90)*0.10)*1.15)-0.35;
  return {temp,wet,hRaw};
}
function biomeColor(h,t,w){
  if(h<0.47) return new THREE.Color().setHSL(0.58,0.45,0.45);
  if(h<0.50) return new THREE.Color(0xbedee8);
  if(h>0.82) return new THREE.Color(0xf0f2f2);
  if(t<0.35 && h>0.68) return new THREE.Color(0xd9e6f0);
  if(t>0.7 && w<0.35) return new THREE.Color(0xd9c58f);
  if(w>0.7 && t>0.5) return new THREE.Color(0x1c6b3a);
  if(w>0.55) return new THREE.Color(0x2e8f4f);
  return new THREE.Color(0x77b55a);
}

function makeChunk(ix,iz){
  let geom=pool.pop();
  if(!geom){ geom=new THREE.PlaneGeometry(CHUNK_SIZE,CHUNK_SIZE,RES,RES); geom.rotateX(-Math.PI/2); }
  const pos=geom.attributes.position.array;
  const color=new Float32Array((RES+1)*(RES+1)*3);
  const worldX0=ix*CHUNK_SIZE, worldZ0=iz*CHUNK_SIZE;
  const col=new THREE.Color();

  for(let z=0; z<=RES; z++){
    for(let x=0; x<=RES; x++){
      const i=(z*(RES+1)+x), p=i*3;
      const wx=worldX0+(x/RES-0.5)*CHUNK_SIZE;
      const wz=worldZ0+(z/RES-0.5)*CHUNK_SIZE;
      const elev=sampleHeight(wx,wz);
      pos[p+1]=elev;
      const {temp,wet,hRaw}=sampleClimate(wx,wz);
      const c=biomeColor(hRaw+0.35,temp,wet);
      color[p]=c.r;color[p+1]=c.g;color[p+2]=c.b;
    }
  }
  geom.setAttribute('color', new THREE.BufferAttribute(color,3));
  geom.computeVertexNormals();

  const mesh=new THREE.Mesh(geom,terrainMat);
  mesh.position.set(worldX0,0,worldZ0);
  mesh.matrixAutoUpdate=false; mesh.updateMatrix();
  mesh.userData={ix,iz};
  return mesh;
}
const key=(ix,iz)=>ix+','+iz;

const toCreate=[];
function queueChunk(ix,iz,priority=0){ toCreate.push({ix,iz,priority}); }
function pumpCreate(budgetMs=9){
  toCreate.sort((a,b)=> b.priority - a.priority);
  const start=performance.now();
  while(toCreate.length && (performance.now()-start)<budgetMs){
    const {ix,iz}=toCreate.shift();
    const k=key(ix,iz);
    if(chunks.has(k)) continue;
    const m=makeChunk(ix,iz); scene.add(m); chunks.set(k,m);
  }
}
function updateChunks(px,pz,forward){
  const cx=Math.floor(px/CHUNK_SIZE);
  const cz=Math.floor(pz/CHUNK_SIZE);
  for(let dz=-LOAD_RADIUS; dz<=LOAD_RADIUS; dz++){
    for(let dx=-LOAD_RADIUS; dx<=LOAD_RADIUS; dx++){
      const ix=cx+dx, iz=cz+dz, k=key(ix,iz);
      if(chunks.has(k)) continue;
      const center=new THREE.Vector3(ix*CHUNK_SIZE,0,iz*CHUNK_SIZE);
      const rel=center.sub(new THREE.Vector3(px,0,pz));
      const prio = rel.normalize().dot(forward||new THREE.Vector3(0,0,-1))*100 - rel.length()/1000;
      queueChunk(ix,iz, prio);
    }
  }
  for(const [k,m] of chunks){
    const {ix,iz}=m.userData;
    if(Math.abs(ix-cx)>LOAD_RADIUS+1 || Math.abs(iz-cz)>LOAD_RADIUS+1){
      scene.remove(m); m.geometry.attributes.color?.dispose?.(); pool.push(m.geometry); chunks.delete(k);
    }
  }
}

/* ============== Flight, Landing, Centered Camera ============== */
const state={
  speed:0, heading:0, pitch:0, roll:0,
  pos:new THREE.Vector3(0,60,0),
  vel:new THREE.Vector3(0,0,-1),
  onGround:false, onWater:false, gearDown:false, floatDown:false
};
const tmpV=new THREE.Vector3();

// Centered chase-cam in ship local frame
const camLocalOffset = new THREE.Vector3(0, 8, 20);
const camLookLocal   = new THREE.Vector3(0, 2, 0);
const worldPos = new THREE.Vector3();
const worldLook = new THREE.Vector3();

const gearLabelEl = document.getElementById('gearLabel');

function stepShip(dt){
  const turn=joyDx, lift=-joyDy;

  // throttle 0..1 → 0..180 m/s
  const targetSpd = THREE.MathUtils.lerp(0, 180, throttle);
  state.speed = THREE.MathUtils.damp(state.speed, targetSpd, 2.5, dt);

  const groundY = sampleHeight(state.pos.x, state.pos.z);
  const altitude = state.pos.y - Math.max(0, groundY);
  state.onWater = groundY < 0 && state.pos.y <= 1.2;
  state.onGround = groundY >= 0 && (state.pos.y - groundY) <= 1.2;

  state.gearDown = (!state.onWater) && (altitude < 12 || state.speed < 25);
  state.floatDown = state.onWater || (groundY<0 && (altitude < 14 || state.speed < 25));

  ship.userData.gearGroup.visible = state.gearDown;
  ship.userData.floatGroup.visible = state.floatDown;

  state.heading += turn * dt * THREE.MathUtils.lerp(0.9, 2.0, Math.max(throttle,0.15));
  const pitchTarget = lift*0.45 * (state.onGround||state.onWater ? 0.2 : 1.0);
  state.pitch = THREE.MathUtils.damp(state.pitch, pitchTarget, 6, dt);
  state.roll  = THREE.MathUtils.damp(state.roll, -turn*0.6, 6, dt);

  const ch=Math.cos(state.heading), sh=Math.sin(state.heading);
  const cp=Math.cos(state.pitch),  sp=Math.sin(state.pitch);
  state.vel.set(sh*cp, sp, -ch*cp).multiplyScalar(state.speed);

  if(!(state.onGround||state.onWater)){
    const liftFactor = THREE.MathUtils.clamp(cp*state.speed*0.002, 0, 1.2);
    state.vel.y += (liftFactor - 0.25) * 9.8 * dt;
  }
  state.pos.addScaledVector(state.vel, dt);

  if(state.onGround){
    state.pos.y = Math.max(state.pos.y, groundY+1.0);
    state.speed = THREE.MathUtils.damp(state.speed, 0, 6, dt);
    state.pos.y = THREE.MathUtils.damp(state.pos.y, groundY+1.0, 8, dt);
  } else if(state.onWater){
    state.pos.y = Math.max(state.pos.y, 0.9);
    state.pos.y += Math.sin(performance.now()*0.003 + (state.pos.x+state.pos.z)*0.01)*0.03;
    state.speed = THREE.MathUtils.damp(state.speed, 0, 4, dt);
  } else {
    if(state.pos.y < 2) state.pos.y = THREE.MathUtils.damp(state.pos.y, 2, 3, dt);
  }

  // Orient ship
  ship.position.copy(state.pos);
  const lookFwd = tmpV.copy(state.pos).add(state.vel.clone().multiplyScalar(0.12));
  ship.lookAt(lookFwd); ship.rotateZ(state.roll);

  // ---- Centered chase cam tied to ship local frame ----
  ship.updateMatrixWorld(true);
  worldPos.copy(camLocalOffset).applyMatrix4(ship.matrixWorld);
  worldLook.copy(camLookLocal).applyMatrix4(ship.matrixWorld);
  camera.position.lerp(worldPos, 0.12);
  camera.lookAt(worldLook);

  // Stream world; prioritize forward
  const forward = new THREE.Vector3(0,0,-1).applyQuaternion(ship.quaternion);
  updateChunks(state.pos.x, state.pos.z, forward);

  gearLabelEl.textContent = state.onWater ? 'FLOATS' : (state.gearDown ? 'GEAR' : '—');
}

/* ============== Loop / FPS ============== */
const fpsEl=document.getElementById('fps'); let fpsAcc=0,fpsCount=0,fpsT=0;
let last=performance.now()/1000;
function tick(){
  const now=performance.now()/1000; const dt=Math.min(now-last,1/30); last=now;
  pumpCreate(9);
  if(!paused){ stepShip(dt); renderer.render(scene,camera); }
  fpsAcc+=1/dt; fpsCount++; if(now-fpsT>0.5){ fpsEl.textContent=(fpsAcc/fpsCount|0)+' fps'; fpsAcc=0; fpsCount=0; fpsT=now; }
  requestAnimationFrame(tick);
}

/* ============== Init ============== */
(function init(){
  updateChunks(0,0,new THREE.Vector3(0,0,-1));
  requestAnimationFrame(tick);
  setTimeout(()=>{ const r=throttleRect(); setThrottleFrom(r.top + (1-throttle)*r.height*0.8 + 20); },0);
  ['touchmove','gesturestart'].forEach(evt=>addEventListener(evt,e=>{ if(e.target.closest('.stick-wrap,.throttle')) e.preventDefault(); }, {passive:false}));
})();
</script>
</body>
</html>