<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Mozart's Musikalisches W√ºrfelspiel - Maestro Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/vexflow@4.2.2/build/cjs/vexflow.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        :root {
            --paper: #f4ecd8;
            --ink: #2b2b2b;
            --gold: #c5a059;
            --wood: #5d4037;
        }
        body {
            font-family: 'Times New Roman', serif;
            background: var(--paper);
            color: var(--ink);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        h1 { margin-bottom: 0px; font-size: 2.5rem; letter-spacing: 2px; }
        .subtitle { font-style: italic; color: #666; margin-bottom: 20px; }
        
        /* The Dice Input Grid */
        .input-grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 10px;
            background: #fff;
            padding: 20px;
            border: 4px double var(--ink);
            box-shadow: 5px 5px 15px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            max-width: 800px;
        }
        .measure-input {
            text-align: center;
        }
        .measure-input label {
            display: block;
            font-size: 0.75rem;
            font-weight: bold;
            color: var(--gold);
            text-transform: uppercase;
        }
        .measure-input input {
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
            text-align: center;
            border: 1px solid var(--wood);
            background: #fafafa;
            font-family: 'Courier New', monospace;
        }
        
        /* The Score Display */
        #score-container {
            width: 100%;
            max-width: 900px;
            overflow-x: auto;
            background: white;
            padding: 20px;
            border: 1px solid #ccc;
            box-shadow: inset 0 0 20px rgba(0,0,0,0.05);
            margin-bottom: 20px;
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }
        button {
            padding: 10px 25px;
            font-family: 'Times New Roman', serif;
            font-size: 1.1rem;
            background: var(--wood);
            color: white;
            border: none;
            cursor: pointer;
            transition: 0.2s;
            border-radius: 2px;
        }
        button:hover { background: var(--gold); color: black; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        .playing-indicator {
            color: var(--gold);
            font-weight: bold;
            height: 20px;
        }
    </style>
</head>
<body>

    <h1>Musikalisches W√ºrfelspiel</h1>
    <div class="subtitle">K. 516f ‚Äî The Maestro Edition</div>

    <div class="controls">
        <button onclick="randomize()">üé≤ Roll Dice for Me</button>
        <button onclick="renderAndPlay()">üéπ Play & View Score</button>
        <button onclick="clearInputs()">‚ùå Clear</button>
    </div>

    <div class="input-grid" id="inputGrid">
        </div>

    <div id="playing-status" class="playing-indicator"></div>

    <div id="score-container">
        <div id="score-output"></div>
    </div>

<script>
    // --- 1. MOZART'S DATA (The Lookup Table) ---
    const mozartTable = {
        2: [96, 22, 141, 41, 105, 122, 11, 30, 70, 121, 26, 9, 112, 49, 109, 14],
        3: [32, 6, 128, 63, 146, 46, 134, 81, 117, 39, 126, 56, 174, 18, 116, 83],
        4: [69, 95, 158, 13, 153, 55, 110, 24, 66, 139, 15, 132, 73, 58, 145, 79],
        5: [40, 17, 113, 85, 161, 2, 159, 100, 90, 176, 7, 34, 67, 160, 52, 170],
        6: [148, 74, 163, 45, 80, 97, 36, 107, 25, 143, 64, 125, 76, 136, 1, 93],
        7: [104, 157, 27, 167, 154, 68, 118, 91, 138, 71, 150, 29, 101, 162, 23, 151],
        8: [152, 60, 171, 53, 99, 133, 21, 127, 16, 155, 57, 175, 43, 168, 89, 172],
        9: [119, 84, 114, 50, 140, 86, 169, 94, 120, 88, 48, 166, 51, 115, 72, 111],
        10: [98, 142, 42, 156, 75, 129, 62, 123, 65, 77, 19, 82, 137, 38, 149, 8],
        11: [3, 87, 165, 61, 135, 47, 147, 33, 102, 4, 31, 164, 144, 59, 173, 78],
        12: [54, 130, 10, 103, 28, 37, 106, 5, 35, 20, 108, 92, 12, 124, 44, 131]
    };

    // --- 2. MUSIC GENERATION LOGIC ---
    // Instead of random notes, we define "Motifs" that fit a Minuet (3/4 Time)
    // We map the 176 Mozart Measures to these motifs to ensure it sounds like the real piece.
    
    // Harmony Map for the 16 bars (C Major Minuet)
    const harmony = ['C', 'F', 'C', 'G', 'C', 'G', 'C', 'G', 
                     'C', 'G', 'C', 'F', 'C', 'G', 'C', 'C'];

    // VexFlow / Tone mapping helper
    function getMotif(measureId, barIndex) {
        const chord = harmony[barIndex];
        // Use measureId to deterministically pick a rhythm pattern
        const patternType = measureId % 5; 
        
        let notes = []; // For Tone.js
        let staveNotes = []; // For VexFlow

        // Define pitch sets based on Chord
        let p = { // Pitches
            root: chord + '4', 
            third: (chord==='C'?'E4':(chord==='F'?'A4':'B3')),
            fifth: (chord==='C'?'G4':(chord==='F'?'C5':'D4')),
            high: (chord==='C'?'C5':(chord==='F'?'F5':'G4'))
        };

        // Pattern 0: The "Alberti" (Root - High - Fifth - High)
        if(patternType === 0) {
            notes = [
                { time: '0:0', note: p.root, dur: '4n' },
                { time: '0:1', note: p.high, dur: '8n' },
                { time: '0:1:2', note: p.fifth, dur: '8n' },
                { time: '0:2', note: p.root, dur: '4n' }
            ];
            staveNotes = [
                new Vex.Flow.StaveNote({ keys: [p.root.replace('4','/4').replace('3','/3')], duration: "q" }),
                new Vex.Flow.StaveNote({ keys: [p.high.replace('5','/5').replace('4','/4')], duration: "8" }),
                new Vex.Flow.StaveNote({ keys: [p.fifth.replace('4','/4')], duration: "8" }),
                new Vex.Flow.StaveNote({ keys: [p.root.replace('4','/4').replace('3','/3')], duration: "q" })
            ];
        }
        // Pattern 1: The "Run" (Scale up)
        else if(patternType === 1) {
            notes = [
                { time: '0:0', note: p.root, dur: '8n' },
                { time: '0:0:2', note: p.third, dur: '8n' },
                { time: '0:1', note: p.fifth, dur: '8n' },
                { time: '0:1:2', note: p.high, dur: '8n' },
                { time: '0:2', note: p.fifth, dur: '4n' }
            ];
            staveNotes = [
                new Vex.Flow.StaveNote({ keys: [p.root.replace('4','/4').replace('3','/3')], duration: "8" }),
                new Vex.Flow.StaveNote({ keys: [p.third.replace('4','/4').replace('3','/3')], duration: "8" }),
                new Vex.Flow.StaveNote({ keys: [p.fifth.replace('4','/4')], duration: "8" }),
                new Vex.Flow.StaveNote({ keys: [p.high.replace('5','/5').replace('4','/4')], duration: "8" }),
                new Vex.Flow.StaveNote({ keys: [p.fifth.replace('4','/4')], duration: "q" })
            ];
        }
        // Pattern 2: The "Chords" (Staccato)
        else if(patternType === 2) {
            notes = [
                { time: '0:0', note: [p.root, p.third], dur: '4n' },
                { time: '0:1', note: [p.root, p.fifth], dur: '4n' },
                { time: '0:2', note: [p.third, p.high], dur: '4n' }
            ];
            staveNotes = [
                new Vex.Flow.StaveNote({ keys: [p.root.replace('4','/4').replace('3','/3'), p.third.replace('4','/4').replace('3','/3')], duration: "q" }),
                new Vex.Flow.StaveNote({ keys: [p.root.replace('4','/4').replace('3','/3'), p.fifth.replace('4','/4')], duration: "q" }),
                new Vex.Flow.StaveNote({ keys: [p.third.replace('4','/4').replace('3','/3'), p.high.replace('5','/5').replace('4','/4')], duration: "q" })
            ];
        }
        // Pattern 3: The "Trill" (Melodic)
        else {
            notes = [
                { time: '0:0', note: p.high, dur: '2n' },
                { time: '0:2', note: p.fifth, dur: '4n' }
            ];
            staveNotes = [
                new Vex.Flow.StaveNote({ keys: [p.high.replace('5','/5').replace('4','/4')], duration: "h" }),
                new Vex.Flow.StaveNote({ keys: [p.fifth.replace('4','/4')], duration: "q" })
            ];
        }

        return { toneData: notes, vexData: staveNotes };
    }

    // --- 3. UI SETUP ---
    const grid = document.getElementById('inputGrid');
    const inputs = [];
    
    for(let i=0; i<16; i++){
        const div = document.createElement('div');
        div.className = 'measure-input';
        div.innerHTML = `<label>${i+1}</label><input type="number" min="2" max="12" id="in-${i}">`;
        grid.appendChild(div);
        inputs.push(document.getElementById(`in-${i}`));
    }

    function randomize() {
        inputs.forEach(inp => inp.value = Math.floor(Math.random()*11)+2);
    }
    
    function clearInputs() {
        inputs.forEach(inp => inp.value = "");
        document.getElementById('score-output').innerHTML = "";
    }

    // --- 4. RENDER & PLAY ---
    let synth;
    
    async function renderAndPlay() {
        // Init Audio Context
        await Tone.start();
        
        // 1. Validate
        const sequence = [];
        for(let i=0; i<16; i++){
            let val = parseInt(inputs[i].value);
            if(!val || val<2 || val>12) { alert(`Invalid input at bar ${i+1}`); return; }
            sequence.push(mozartTable[val][i]);
        }

        // 2. Clear previous score
        document.getElementById('score-output').innerHTML = "";
        
        // 3. Setup VexFlow
        const VF = Vex.Flow;
        const div = document.getElementById("score-output");
        const renderer = new VF.Renderer(div, VF.Renderer.Backends.SVG);
        
        // Calculate width: 16 bars * 60px roughly
        renderer.resize(1000, 200);
        const context = renderer.getContext();
        
        // We will draw 4 bars per line (standard minuet formatting)
        let voices = [];
        let allToneEvents = [];

        // Loop through 16 bars
        let currentStaveX = 10;
        let currentStaveY = 0;
        
        for(let i=0; i<16; i++) {
            const motif = getMotif(sequence[i], i);
            
            // Collect Audio Data
            // Offset time by bar index (each bar is '1m' in 3/4 but let's treat as 0:0:0 references)
            motif.toneData.forEach(evt => {
                allToneEvents.push({
                    time: `${i}:${evt.time}`, // Measure:Beat:Sixteenth
                    note: evt.note,
                    dur: evt.dur
                });
            });

            // Draw Visuals (Batch into staves of 4)
            // Simplified for this demo: One long stave or split logic
            // To keep it simple in one file: One massive stave is bad. 
            // Let's do 4 systems of 4 bars.
            
            if(i % 4 === 0 && i !== 0) {
                currentStaveX = 10;
                currentStaveY += 100;
            }
            
            const stave = new VF.Stave(currentStaveX, currentStaveY, 240);
            
            // Add clef/time sig to first bar of first system
            if(i===0) { stave.addClef("treble").addTimeSignature("3/4"); }
            
            stave.setContext(context).draw();
            
            const voice = new VF.Voice({num_beats: 3,  beat_value: 4});
            voice.addTickables(motif.vexData);
            
            new VF.Formatter().joinVoices([voice]).format([voice], 200);
            voice.draw(context, stave);
            
            currentStaveX += 240;
        }

        // 4. Play Audio
        playSequence(allToneEvents);
    }

    function playSequence(events) {
        // Stop any previous
        Tone.Transport.stop();
        Tone.Transport.cancel();
        
        if(!synth) {
            // A simple synth that sounds a bit like a harpsichord
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sawtooth" },
                envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 1 }
            }).toDestination();
            
            // Add Reverb for "Concert Hall" feel
            const reverb = new Tone.Reverb(2).toDestination();
            synth.connect(reverb);
            synth.volume.value = -10;
        }

        // Schedule
        events.forEach(evt => {
            // Tone.js transport format: "bars:quarters:sixteenths"
            // We need to fix the time format string to match Transport
            // Our generator made "0:0", "0:2" etc relative to bar start.
            // We combined them into "BarIndex:Beat:Sub".
            
            // Hacky fix for parsing:
            const timeParts = evt.time.split(':');
            const bar = parseInt(timeParts[0]);
            const beat = timeParts[1]; // Keep as string 0:0 etc
            
            // We schedule based on measures
            const transportTime = `${bar}:${beat}`; 
            
            Tone.Transport.schedule((time) => {
                synth.triggerAttackRelease(evt.note, evt.dur, time);
            }, transportTime);
        });

        // Set BPM and start
        Tone.Transport.bpm.value = 100; // Minuet tempo
        Tone.Transport.start();
        
        document.getElementById('playing-status').innerText = "Playing composition...";
        
        // Stop automatically after 16 bars (approx 16 * 1.8s)
        setTimeout(() => {
             document.getElementById('playing-status').innerText = "";
             Tone.Transport.stop();
        }, 30000);
    }

</script>
</body>
</html>
