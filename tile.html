<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Space Block Breaker</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; }
    body { background: black; overflow: hidden; }
    canvas { display: block; position: absolute; top: 0; left: 0; }
    #playAgain {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: #0ff;
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <button id="playAgain">Play Again</button>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const playAgainButton = document.getElementById("playAgain");

    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    let basePaddleWidth = width * 0.2;
    let paddleWidth = basePaddleWidth;
    const paddleHeight = 12;
    let paddleX = (width - paddleWidth) / 2;

    let ballRadius = 10;
    let balls = [];
    let ballTrailLength = 15; // Number of previous positions to keep
    let ballCount = 3; // Start with 3 balls

    let particles = [];
    let powerUps = [];
    let starfield = [];
    let level = 1;
    let gameOver = false;

    let leftPressed = false;
    let rightPressed = false;

    let blocks = [];
    const rows = 6, cols = 10;
    const blockWidth = width / cols - 4;
    const blockHeight = 30;

    let superBallActive = false;
    let paddleEffectTimer = null; // Timer for paddle extend/shorten effect

    function resetBall() {
      if (!gameOver) {
        balls.push({
          x: width / 2,
          y: height - 50,
          dx: 4 * (Math.random() < 0.5 ? 1 : -1),
          dy: -4,
          speed: 6,
          power: false,
          trail: []
        });
      }
    }

    function init() {
      ballCount = 3;
      level = 1;
      gameOver = false;
      paddleWidth = basePaddleWidth;
      paddleX = (width - paddleWidth) / 2;
      balls = [];
      particles = [];
      powerUps = [];
      createBlocks();
      createStarfield();
      resetBall();
    }

    function createBlocks() {
      blocks = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          blocks.push({
            x: c * (blockWidth + 4) + 2,
            y: r * (blockHeight + 4) + 50,
            status: true,
            color: `hsl(${Math.random() * 360}, 100%, 60%)`
          });
        }
      }
    }

    function createStarfield() {
      starfield = [];
      for (let i = 0; i < 100; i++) {
        starfield.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: Math.random() * 2,
          speed: Math.random() * 3 + 1
        });
      }
    }

    function drawStarfield() {
      ctx.fillStyle = "white";
      starfield.forEach(star => {
        ctx.fillRect(star.x, star.y, star.size, star.size);
        star.y += star.speed;
        if (star.y > height) star.y = 0;
      });
    }

    function drawPaddle() {
      ctx.fillStyle = "#0ff";
      ctx.fillRect(paddleX, height - paddleHeight - 10, paddleWidth, paddleHeight);
    }

    function drawBall(ball) {
      // Draw trail
      for (let i = 0; i < ball.trail.length; i++) {
        let pos = ball.trail[i];
        let alpha = ((i + 1) / ball.trail.length) * 0.5;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = ball.power ? `rgba(240, 0, 240, ${alpha})` : `rgba(255, 255, 255, ${alpha})`;
        ctx.fill();
      }
      // Draw current ball with a 3D radial gradient
      let gradient = ctx.createRadialGradient(ball.x - 3, ball.y - 3, 3, ball.x, ball.y, ballRadius);
      gradient.addColorStop(0, ball.power ? "#f0f" : "#fff");
      gradient.addColorStop(0.5, ball.power ? "#ff0" : "#ff0");
      gradient.addColorStop(1, ball.power ? "#f00" : "#f00");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBlocks() {
      blocks.forEach(block => {
        if (block.status) {
          ctx.fillStyle = block.color;
          ctx.fillRect(block.x, block.y, blockWidth, blockHeight);
        }
      });
    }

    function createExplosion(x, y, color) {
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: x,
          y: y,
          dx: (Math.random() - 0.5) * 8,
          dy: (Math.random() - 0.5) * 8,
          size: Math.random() * 8 + 2,
          color: color,
          life: Math.random() * 50 + 30
        });
      }
    }

    function drawParticles() {
      particles.forEach((p, i) => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        p.x += p.dx;
        p.y += p.dy;
        p.dy += 0.1;
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      });
    }

    function dropPowerUp(x, y) {
      const types = ["extend", "super", "extra", "shorten"];
      let type = types[Math.floor(Math.random() * types.length)];
      powerUps.push({ x: x, y: y, dy: 2, type: type });
    }

    function drawPowerUps() {
      powerUps.forEach((p, i) => {
        let color;
        if (p.type === "extend") color = "#0f0";
        else if (p.type === "super") color = "#f0f";
        else if (p.type === "extra") color = "#ff0";
        else if (p.type === "shorten") color = "#f00";
        ctx.fillStyle = color;
        ctx.fillRect(p.x, p.y, 20, 20);
        p.y += p.dy;
        if (p.y + 20 > height - paddleHeight - 10 && p.x + 20 > paddleX && p.x < paddleX + paddleWidth) {
          activatePowerUp(p.type);
          powerUps.splice(i, 1);
        }
      });
    }

    // Updated activatePowerUp to prevent overlapping effects
    function activatePowerUp(type) {
      if (type === "extend") {
        if (paddleEffectTimer) clearTimeout(paddleEffectTimer);
        paddleWidth = basePaddleWidth * 1.5;
        paddleEffectTimer = setTimeout(() => {
          paddleWidth = basePaddleWidth;
          paddleEffectTimer = null;
        }, 10000);
      } else if (type === "shorten") {
        if (paddleEffectTimer) clearTimeout(paddleEffectTimer);
        paddleWidth = basePaddleWidth * 0.5;
        paddleEffectTimer = setTimeout(() => {
          paddleWidth = basePaddleWidth;
          paddleEffectTimer = null;
        }, 10000);
      } else if (type === "super") {
        superBallActive = true;
        balls.forEach(ball => ball.power = true);
        setTimeout(() => {
          superBallActive = false;
          balls.forEach(ball => ball.power = false);
        }, 10000);
      } else if (type === "extra") {
        ballCount++;
        balls.push({
          x: paddleX + paddleWidth / 2,
          y: height - paddleHeight - 20,
          dx: 4 * (Math.random() < 0.5 ? 1 : -1),
          dy: -4,
          speed: 6,
          power: false,
          trail: []
        });
      }
    }

    function moveBalls() {
      balls.forEach((ball, index) => {
        // Update ball trail
        ball.trail.push({ x: ball.x, y: ball.y });
        if (ball.trail.length > ballTrailLength) ball.trail.shift();
        ball.x += ball.dx;
        ball.y += ball.dy;
        if (ball.x < ballRadius || ball.x > width - ballRadius) ball.dx *= -1;
        if (ball.y < ballRadius) ball.dy *= -1;
        if (ball.y > height) {
          balls.splice(index, 1);
          ballCount--;
          if (ballCount <= -10) { gameOver = true; }
          if (!gameOver && balls.length === 0) { resetBall(); }
        }
        // Paddle collision with velocity & hit-position effect
        if (ball.y + ballRadius >= height - paddleHeight - 10 && ball.x > paddleX && ball.x < paddleX + paddleWidth && ball.dy > 0) {
          let hitPos = (ball.x - paddleX) / paddleWidth;
          let angle = (hitPos - 0.5) * (Math.PI / 3); // -60 to 60 degrees
          ball.dx = ball.speed * Math.sin(angle);
          ball.dy = -ball.speed * Math.cos(angle);
        }
        // Block collision
        blocks.forEach(block => {
          if (block.status &&
              ball.x > block.x &&
              ball.x < block.x + blockWidth &&
              ball.y > block.y &&
              ball.y < block.y + blockHeight) {
            if (!superBallActive) ball.dy *= -1;
            block.status = false;
            createExplosion(block.x + blockWidth / 2, block.y + blockHeight / 2, block.color);
            if (Math.random() < 0.3) dropPowerUp(block.x + blockWidth / 2, block.y + blockHeight / 2);
          }
        });
      });
      if (blocks.every(block => !block.status)) {
        level++;
        createBlocks();
      }
    }

    function movePaddle() {
      if (rightPressed) {
        paddleX += 8;
        if (paddleX + paddleWidth > width) paddleX = width - paddleWidth;
      }
      if (leftPressed) {
        paddleX -= 8;
        if (paddleX < 0) paddleX = 0;
      }
    }

    function drawHUD() {
      ctx.font = "20px 'Courier New', monospace";
      // Centered retro HUD with different neon colors
      let levelText = "LEVEL: " + level;
      let ballText = "BALLS: " + ballCount;
      ctx.textAlign = "left";
      let levelWidth = ctx.measureText(levelText).width;
      let ballWidth = ctx.measureText(ballText).width;
      let totalWidth = levelWidth + ballWidth + 40;
      let startX = (width - totalWidth) / 2;
      ctx.fillStyle = "#0f0"; // Neon green for level
      ctx.fillText(levelText, startX, 30);
      ctx.fillStyle = "#f0f"; // Neon magenta for balls
      ctx.fillText(ballText, startX + levelWidth + 40, 30);
    }

    function update() {
      ctx.clearRect(0, 0, width, height);
      drawStarfield();
      movePaddle();
      drawPaddle();
      balls.forEach(drawBall);
      drawBlocks();
      drawParticles();
      drawPowerUps();
      moveBalls();
      drawHUD();
      if (!gameOver) {
        requestAnimationFrame(update);
      } else {
        ctx.fillStyle = "#fff";
        ctx.font = "40px 'Courier New', monospace";
        ctx.textAlign = "center";
        ctx.fillText("Game Over", width / 2, height / 2);
        playAgainButton.style.display = "block";
      }
    }
    update();

    // Smooth mouse/touch & keyboard controls
    document.addEventListener("mousemove", e => {
      paddleX = e.clientX - paddleWidth / 2;
    });
    document.addEventListener("touchmove", e => {
      paddleX = e.touches[0].clientX - paddleWidth / 2;
    });
    document.addEventListener("keydown", e => {
      if (e.key === "ArrowRight" || e.key === "d") rightPressed = true;
      if (e.key === "ArrowLeft" || e.key === "a") leftPressed = true;
    });
    document.addEventListener("keyup", e => {
      if (e.key === "ArrowRight" || e.key === "d") rightPressed = false;
      if (e.key === "ArrowLeft" || e.key === "a") leftPressed = false;
    });
    playAgainButton.addEventListener("click", () => {
      playAgainButton.style.display = "none";
      init();
      update();
    });
    window.addEventListener("resize", () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      basePaddleWidth = width * 0.2;
      paddleWidth = basePaddleWidth;
      paddleX = (width - paddleWidth) / 2;
      createStarfield();
      createBlocks();
    });
    init();
  </script>
</body>
</html>
