<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Space Block Breaker</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; }
    body { background: black; overflow: hidden; }
    canvas { display: block; position: absolute; top: 0; left: 0; }
    #playAgain {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 20px 40px;
      font-size: 24px;
      background: #0ff;
      color: #000;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      display: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <button id="playAgain">Play Again</button>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    const playAgainButton = document.getElementById("playAgain");

    let width = canvas.width = window.innerWidth;
    let height = canvas.height = window.innerHeight;

    let basePaddleWidth = width * 0.2;
    let paddleWidth = basePaddleWidth;
    const paddleHeight = 12;
    let paddleX = (width - paddleWidth) / 2;

    let ballRadius = 10;
    let balls = [];
    let ballTrailLength = 15; // Number of previous positions to keep
    let ballCount = 3; // Start with 3 balls (lives)

    let particles = [];
    let powerUps = [];
    let starfield = [];
    let level = 1;
    let gameOver = false;

    let blocks = [];
    const rows = 6, cols = 10;
    const blockWidth = width / cols - 4;
    const blockHeight = 30;

    let superBallActive = false;

    // Reset and spawn a new ball (if game not over)
    function resetBall() {
      if (!gameOver) {
        balls.push({
          x: width / 2,
          y: height - 50,
          dx: 4 * (Math.random() < 0.5 ? 1 : -1),
          dy: -4,
          speed: 6,
          power: false,
          trail: []
        });
      }
    }

    function init() {
      ballCount = 3;
      level = 1;
      gameOver = false;
      paddleWidth = basePaddleWidth;
      paddleX = (width - paddleWidth) / 2;
      balls = [];
      particles = [];
      powerUps = [];
      createBlocks();
      createStarfield();
      resetBall();
    }

    function createBlocks() {
      blocks = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          blocks.push({
            x: c * (blockWidth + 4) + 2,
            y: r * (blockHeight + 4) + 50,
            status: true,
            color: `hsl(${Math.random() * 360}, 100%, 60%)`
          });
        }
      }
    }

    function createStarfield() {
      starfield = [];
      for (let i = 0; i < 100; i++) {
        starfield.push({
          x: Math.random() * width,
          y: Math.random() * height,
          size: Math.random() * 2,
          speed: Math.random() * 3 + 1
        });
      }
    }

    function drawStarfield() {
      ctx.fillStyle = "white";
      starfield.forEach(star => {
        ctx.fillRect(star.x, star.y, star.size, star.size);
        star.y += star.speed;
        if (star.y > height) star.y = 0;
      });
    }

    function drawPaddle() {
      ctx.fillStyle = "#0ff";
      ctx.fillRect(paddleX, height - paddleHeight - 10, paddleWidth, paddleHeight);
    }

    function drawBall(ball) {
      // Draw trail
      for (let i = 0; i < ball.trail.length; i++) {
        let pos = ball.trail[i];
        let alpha = ((i + 1) / ball.trail.length) * 0.5;
        ctx.beginPath();
        ctx.arc(pos.x, pos.y, ballRadius, 0, Math.PI * 2);
        ctx.fillStyle = ball.power ? `rgba(240, 0, 240, ${alpha})` : `rgba(255, 255, 255, ${alpha})`;
        ctx.fill();
      }
      // Draw current ball
      let gradient = ctx.createRadialGradient(ball.x - 3, ball.y - 3, 3, ball.x, ball.y, ballRadius);
      gradient.addColorStop(0, ball.power ? "#f0f" : "#fff");
      gradient.addColorStop(0.5, ball.power ? "#ff0" : "#ff0");
      gradient.addColorStop(1, ball.power ? "#f00" : "#f00");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ballRadius, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawBlocks() {
      blocks.forEach(block => {
        if (block.status) {
          ctx.fillStyle = block.color;
          ctx.fillRect(block.x, block.y, blockWidth, blockHeight);
        }
      });
    }

    function createExplosion(x, y, color) {
      // Increase explosion particles for a massive effect!
      for (let i = 0; i < 50; i++) {
        particles.push({
          x: x,
          y: y,
          dx: (Math.random() - 0.5) * 8,
          dy: (Math.random() - 0.5) * 8,
          size: Math.random() * 8 + 2,
          color: color,
          life: Math.random() * 50 + 30
        });
      }
    }

    function drawParticles() {
      particles.forEach((p, i) => {
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
        p.x += p.dx;
        p.y += p.dy;
        p.dy += 0.1; // Gravity effect
        p.life--;
        if (p.life <= 0) particles.splice(i, 1);
      });
    }

    function dropPowerUp(x, y) {
      // Only drop extend and super power-ups
      const types = ["extend", "super"];
      let type = types[Math.floor(Math.random() * types.length)];
      powerUps.push({ x: x, y: y, dy: 2, type: type });
    }

    function drawPowerUps() {
      powerUps.forEach((p, i) => {
        ctx.fillStyle = p.type === "extend" ? "#0f0" : "#f0f";
        ctx.fillRect(p.x, p.y, 20, 20);
        p.y += p.dy;
        // Check collision with paddle
        if (p.y + 20 > height - paddleHeight - 10 && p.x + 20 > paddleX && p.x < paddleX + paddleWidth) {
          activatePowerUp(p.type);
          powerUps.splice(i, 1);
        }
      });
    }

    function activatePowerUp(type) {
      if (type === "extend") {
        paddleWidth = basePaddleWidth * 1.5;
        setTimeout(() => { paddleWidth = basePaddleWidth; }, 10000);
      } else if (type === "super") {
        superBallActive = true;
        balls.forEach(ball => ball.power = true);
        setTimeout(() => {
          superBallActive = false;
          balls.forEach(ball => ball.power = false);
        }, 10000);
      }
    }

    function moveBalls() {
      balls.forEach((ball, index) => {
        // Update trail
        ball.trail.push({ x: ball.x, y: ball.y });
        if (ball.trail.length > ballTrailLength) ball.trail.shift();
        ball.x += ball.dx;
        ball.y += ball.dy;
        // Bounce off walls
        if (ball.x < ballRadius || ball.x > width - ballRadius) ball.dx *= -1;
        if (ball.y < ballRadius) ball.dy *= -1;
        // If ball falls below screen, lose a ball
        if (ball.y > height) {
          balls.splice(index, 1);
          ballCount--;
          if (ballCount <= -10) { gameOver = true; }
          if (!gameOver && balls.length === 0) { resetBall(); }
        }
        // Paddle collision
        if (ball.y > height - paddleHeight - 10 - ballRadius &&
            ball.x > paddleX && ball.x < paddleX + paddleWidth) {
          ball.dy = -Math.abs(ball.dy);
        }
        // Block collision
        blocks.forEach(block => {
          if (block.status &&
              ball.x > block.x &&
              ball.x < block.x + blockWidth &&
              ball.y > block.y &&
              ball.y < block.y + blockHeight) {
            if (!superBallActive) ball.dy *= -1;
            block.status = false;
            createExplosion(block.x + blockWidth / 2, block.y + blockHeight / 2, block.color);
            if (Math.random() < 0.3) dropPowerUp(block.x + blockWidth / 2, block.y + blockHeight / 2);
          }
        });
      });
      // If all blocks are broken, increment level and create new blocks
      if (blocks.every(block => !block.status)) {
        level++;
        createBlocks();
      }
    }

    function drawHUD() {
      ctx.fillStyle = "#fff";
      ctx.font = "20px Arial";
      ctx.fillText("Level: " + level, 10, 30);
      ctx.fillText("Balls: " + ballCount, 10, 60);
    }

    function update() {
      ctx.clearRect(0, 0, width, height);
      drawStarfield();
      drawPaddle();
      balls.forEach(drawBall);
      drawBlocks();
      drawParticles();
      drawPowerUps();
      moveBalls();
      drawHUD();
      if (!gameOver) {
        requestAnimationFrame(update);
      } else {
        ctx.fillStyle = "#fff";
        ctx.font = "40px Arial";
        ctx.fillText("Game Over", width / 2 - 100, height / 2);
        playAgainButton.style.display = "block";
      }
    }
    update();

    document.addEventListener("mousemove", e => {
      paddleX = e.clientX - paddleWidth / 2;
    });
    document.addEventListener("touchmove", e => {
      paddleX = e.touches[0].clientX - paddleWidth / 2;
    });
    playAgainButton.addEventListener("click", () => {
      playAgainButton.style.display = "none";
      init();
      update();
    });

    window.addEventListener("resize", () => {
      width = canvas.width = window.innerWidth;
      height = canvas.height = window.innerHeight;
      basePaddleWidth = width * 0.2;
      paddleWidth = basePaddleWidth;
      paddleX = (width - paddleWidth) / 2;
      createStarfield();
      createBlocks();
    });

    init();
  </script>
</body>
</html>
