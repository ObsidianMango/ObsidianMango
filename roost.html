<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <!-- Retro font -->
  <link href="https://fonts.googleapis.com/css?family=Press+Start+2P" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Emoji FPS Game - Retro Edition</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
      font-family: 'Press Start 2P', cursive;
    }
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
    }
    /* HUD overlay */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 5px;
      text-align: center;
      font-size: 12px;
      color: #fff;
      background: rgba(0,0,0,0.6);
      z-index: 2;
    }
    /* Final screen overlay */
    #finalScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.9);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 3;
      color: #fff;
      text-align: center;
    }
    #finalScreen h1 {
      font-size: 28px;
      margin-bottom: 20px;
    }
    #finalScreen p {
      font-size: 14px;
      margin: 5px;
    }
    /* Animated play again button */
    #playAgainBtn {
      padding: 10px 20px;
      border: 2px solid #fff;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      margin-top: 20px;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    /* Joystick & shoot button */
    #joystick {
      position: absolute;
      bottom: 10%;
      left: 5%;
      width: 80px;
      height: 80px;
      border: 2px solid #aaa;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      touch-action: none;
      z-index: 2;
    }
    #joystickKnob {
      position: absolute;
      width: 40px;
      height: 40px;
      top: 50%;
      left: 50%;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    #shootBtn {
      position: absolute;
      bottom: 10%;
      right: 5%;
      width: 80px;
      height: 80px;
      border: 2px solid #aaa;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      font-size: 36px;
      line-height: 80px;
      text-align: center;
      color: #fff;
      user-select: none;
      touch-action: none;
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="overlay">Level: 1 | Roosters: 0 | Ghosts: 0 | HP: 10 | Weapon: üçó | Time: 0s | Score: 0</div>
  <div id="finalScreen">
    <h1>GAME OVER</h1>
    <p id="finalTime"></p>
    <p id="finalScore"></p>
    <div id="playAgainBtn">Play Again</div>
  </div>
  <div id="joystick"><div id="joystickKnob"></div></div>
  <div id="shootBtn">Fire</div>
  <script>
(() => {
  // Canvas & context setup
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // UI Elements
  const overlay = document.getElementById('overlay');
  const finalScreen = document.getElementById('finalScreen');
  const finalTimeElem = document.getElementById('finalTime');
  const finalScoreElem = document.getElementById('finalScore');
  const playAgainBtn = document.getElementById('playAgainBtn');
  const joystick = document.getElementById('joystick');
  const joystickKnob = document.getElementById('joystickKnob');
  const shootBtn = document.getElementById('shootBtn');

  // Game state variables
  let currentLevel = 0;
  let score = 0;
  let levelData = []; // 2D map grid: 0 = empty, 1 = wall
  let enemies = [];   // {x, y, dx, dy, isGhost, health}
  let pickups = [];   // {x, y, type} (type: 'rock' or 'dagger')
  let player = { x: 0, y: 0, angle: 0, health: 10, weapon: "üçó" };
  let projectiles = []; // {x, y, dx, dy, rotation, rotationSpeed, weapon}
  let particles = [];   // {x, y, z, vx, vy, vz, life, color}
  let gameStartTime = performance.now();
  let gameOver = false;
  let damageFlashTimer = 0;

  // Level definitions (characters: '#' wall, 'P' player, 'R' rooster, 'G' ghost, 'K' rock pickup, 'D' dagger pickup)
  const levels = [
    [
      "###########",
      "#P....R...#",
      "#.....K..#",
      "#.........#",
      "#...#.....#",
      "#.....R..#",
      "###########"
    ],
    [
      "###############",
      "#P...R...D...#",
      "#.....#.......#",
      "#..G..#...R..#",
      "#.....#.......#",
      "#...R...G....#",
      "###############"
    ]
  ];

  // Colors & visual settings
  const ceilingColor = "#005588"; 
  const floorColor = "#444444";
  const wallColor = "#c0c0c0";
  const wallColorDark = "#888888";
  const explosionColors = ["255,165,0", "255,100,0", "255,255,0"];
  const ghostExplosionColor = "255,0,0";

  // Joystick control variables
  let moveForward = 0;
  let turnDirection = 0;
  const moveSpeed = 3.0;
  const turnSpeed = 2.0;
  const joystickRadius = 40;
  let joystickActive = false;
  let joystickPointerId = null;
  let joystickCenterX = 0;
  let joystickCenterY = 0;

  // Keyboard input
  const keys = {};

  // HUD update tracking
  let lastLevelDisplay = -1;
  let lastEnemiesDisplay = -1;
  let lastGhostsDisplay = -1;
  let lastHPTally = -1;
  let lastTimeDisplay = -1;
  let lastScoreDisplay = -1;

  // Utility: Line-of-sight check
  function lineOfSight(x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const dist = Math.hypot(dx, dy);
    const steps = Math.ceil(dist / 0.1);
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = x1 + dx * t, y = y1 + dy * t;
      if (isWall(x, y)) return false;
    }
    return true;
  }

  // Level loading
  function loadLevel(index) {
    currentLevel = index;
    enemies = [];
    projectiles = [];
    particles = [];
    pickups = [];
    gameStartTime = performance.now();
    gameOver = false;
    player.health = 10;
    player.weapon = "üçó";
    const rows = levels[index];
    levelData = [];
    for (let y = 0; y < rows.length; y++) {
      const rowStr = rows[y];
      const rowArr = [];
      for (let x = 0; x < rowStr.length; x++) {
        const ch = rowStr[x];
        if (ch === "#") {
          rowArr.push(1);
        } else if (ch === "P") {
          player.x = x + 0.5;
          player.y = y + 0.5;
          player.angle = 0;
          rowArr.push(0);
        } else if (ch === "R") {
          enemies.push({ x: x + 0.5, y: y + 0.5, dx: (Math.random()-0.5)*1.5, dy: (Math.random()-0.5)*1.5, isGhost: false });
          rowArr.push(0);
        } else if (ch === "G") {
          enemies.push({ x: x + 0.5, y: y + 0.5, dx: 0, dy: 0, isGhost: true, health: 2 });
          rowArr.push(0);
        } else if (ch === "K") {
          pickups.push({ x: x + 0.5, y: y + 0.5, type: "rock" });
          rowArr.push(0);
        } else if (ch === "D") {
          pickups.push({ x: x + 0.5, y: y + 0.5, type: "dagger" });
          rowArr.push(0);
        } else {
          rowArr.push(0);
        }
      }
      levelData.push(rowArr);
    }
  }

  function isWall(x, y) {
    const mx = Math.floor(x), my = Math.floor(y);
    if (my < 0 || my >= levelData.length || mx < 0 || mx >= levelData[0].length)
      return true;
    return levelData[my][mx] === 1;
  }

  // Explosions
  function createExplosion(x, y) {
    const count = 150;
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * 2 * Math.PI;
      const speed = Math.random() * 3 + 1;
      const vx = Math.sin(angle) * speed;
      const vy = -Math.cos(angle) * speed;
      const vz = (Math.random()-0.5) * 6;
      const col = explosionColors[Math.floor(Math.random()*explosionColors.length)];
      particles.push({ x, y, z: 0, vx, vy, vz, life: 1.0, color: col });
    }
  }
  function createGhostExplosion(x, y) {
    const count = 300;
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * 2 * Math.PI;
      const speed = Math.random() * 4 + 2;
      const vx = Math.sin(angle) * speed;
      const vy = -Math.cos(angle) * speed;
      const vz = (Math.random()-0.5) * 8;
      particles.push({ x, y, z: 0, vx, vy, vz, life: 1.0, color: ghostExplosionColor });
    }
  }

  // Shooting & weapon pickups
  function shoot() {
    const dirX = Math.sin(player.angle);
    const dirY = -Math.cos(player.angle);
    const speed = 6.0;
    projectiles.push({ x: player.x, y: player.y, dx: dirX * speed, dy: dirY * speed, rotation: 0, rotationSpeed: Math.PI*2, weapon: player.weapon });
  }

  // Final screen & restart
  function showFinalScreen() {
    finalTimeElem.textContent = "Time: " + Math.floor((performance.now() - gameStartTime) / 1000) + "s";
    finalScoreElem.textContent = "Score: " + score;
    finalScreen.style.display = "flex";
  }
  function restartGame() {
    finalScreen.style.display = "none";
    score = 0;
    loadLevel(0);
    gameStartTime = performance.now();
    gameOver = false;
    requestAnimationFrame(gameLoop);
  }
  playAgainBtn.addEventListener("click", restartGame);

  // Main update loop
  function update(dt) {
    // Keyboard input
    let kbMove = 0, kbTurn = 0;
    if (keys['w'] || keys['ArrowUp']) kbMove += 1;
    if (keys['s'] || keys['ArrowDown']) kbMove -= 1;
    if (keys['a'] || keys['ArrowLeft']) kbTurn -= 1;
    if (keys['d'] || keys['ArrowRight']) kbTurn += 1;
    const effectiveMove = (joystickActive ? moveForward : 0) + kbMove;
    const effectiveTurn = (joystickActive ? turnDirection : 0) + kbTurn;
    
    // Update player rotation & movement
    player.angle += effectiveTurn * turnSpeed * dt;
    if (player.angle < 0) player.angle += Math.PI*2;
    if (player.angle >= Math.PI*2) player.angle -= Math.PI*2;
    if (effectiveMove !== 0) {
      const step = effectiveMove * moveSpeed * dt;
      const newX = player.x + Math.sin(player.angle) * step;
      const newY = player.y - Math.cos(player.angle) * step;
      if (!isWall(newX, player.y)) player.x = newX;
      if (!isWall(player.x, newY)) player.y = newY;
    }
    // Weapon pickups (do not block progression)
    for (let i = 0; i < pickups.length; i++) {
      const pu = pickups[i];
      if (Math.hypot(player.x - pu.x, player.y - pu.y) < 0.5) {
        player.weapon = (pu.type === "rock") ? "ü™®" : "üó°Ô∏è";
        score += 50;
        pickups.splice(i,1);
        i--;
      }
    }
    // Update enemies
    for (let i = 0; i < enemies.length; i++) {
      const enemy = enemies[i];
      if (enemy.isGhost) {
        const dx = player.x - enemy.x, dy = player.y - enemy.y;
        const dist = Math.hypot(dx, dy);
        const chaseSpeed = 2.5;
        enemy.dx = (dx/dist) * chaseSpeed;
        enemy.dy = (dy/dist) * chaseSpeed;
      }
      let newX = enemy.x + enemy.dx * dt;
      let newY = enemy.y + enemy.dy * dt;
      if (!isWall(newX, enemy.y)) enemy.x = newX; else enemy.dx = -enemy.dx;
      if (!isWall(enemy.x, newY)) enemy.y = newY; else enemy.dy = -enemy.dy;
      // Ghost enemy damages player on contact and triggers screen flash
      if (enemy.isGhost && Math.hypot(player.x - enemy.x, player.y - enemy.y) < 0.5) {
        player.health--;
        damageFlashTimer = 0.2; // flash red for 0.2 seconds
        enemy.x -= enemy.dx * dt * 2;
        enemy.y -= enemy.dy * dt * 2;
        if (player.health <= 0) gameOver = true;
      }
    }
    // Update projectiles
    for (let i = 0; i < projectiles.length; i++) {
      const proj = projectiles[i];
      proj.x += proj.dx * dt;
      proj.y += proj.dy * dt;
      proj.rotation += proj.rotationSpeed * dt;
      if (isWall(proj.x, proj.y)) {
        createExplosion(proj.x, proj.y);
        projectiles.splice(i, 1);
        i--;
        continue;
      }
      if (proj.x < 0 || proj.y < 0 || proj.x >= levelData[0].length || proj.y >= levelData.length) {
        projectiles.splice(i,1);
        i--;
        continue;
      }
      for (let j = 0; j < enemies.length; j++) {
        const enemy = enemies[j];
        if (Math.hypot(enemy.x - proj.x, enemy.y - proj.y) < 0.5) {
          if (enemy.isGhost) {
            enemy.health--;
            if (enemy.health <= 0) {
              createGhostExplosion(enemy.x, enemy.y);
              score += 300;
              enemies.splice(j, 1);
              j--;
            }
          } else {
            createExplosion(enemy.x, enemy.y);
            score += 100;
            enemies.splice(j, 1);
            j--;
          }
          projectiles.splice(i, 1);
          i--;
          break;
        }
      }
    }
    // Update explosion particles
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.z += p.vz * dt;
      p.life -= dt;
      if (p.life <= 0) { particles.splice(i, 1); i--; }
    }
    // Level progression: if no enemies remain, progress to next level (or finish game on final level)
    if (enemies.length === 0) {
      if (currentLevel < levels.length - 1) loadLevel(currentLevel + 1);
      else gameOver = true;
    }
    // Update damage flash timer
    if (damageFlashTimer > 0) damageFlashTimer = Math.max(damageFlashTimer - dt, 0);
    // Update HUD
    const elapsedTime = Math.floor((performance.now() - gameStartTime) / 1000);
    let roosterCount = 0, ghostCount = 0;
    for (const enemy of enemies) { enemy.isGhost ? ghostCount++ : roosterCount++; }
    overlay.textContent = `Level: ${currentLevel+1} | Roosters: ${roosterCount} | Ghosts: ${ghostCount} | HP: ${player.health} | Weapon: ${player.weapon} | Time: ${elapsedTime}s | Score: ${score}`;
  }

  // Rendering
  function render() {
    const w = canvas.width, h = canvas.height;
    ctx.fillStyle = ceilingColor;
    ctx.fillRect(0, 0, w, h/2);
    ctx.fillStyle = floorColor;
    ctx.fillRect(0, h/2, w, h/2);
    const posX = player.x, posY = player.y;
    const dirX = Math.sin(player.angle), dirY = -Math.cos(player.angle);
    const fov = 1.0472;
    const planeLen = Math.tan(fov/2);
    const planeX = -dirY * planeLen, planeY = dirX * planeLen;
    for (let x = 0; x < w; x++) {
      const cameraX = 2 * x / w - 1;
      const rayDirX = dirX + planeX * cameraX;
      const rayDirY = dirY + planeY * cameraX;
      let mapX = Math.floor(posX), mapY = Math.floor(posY);
      let sideDistX, sideDistY;
      const deltaDistX = (rayDirX === 0) ? Infinity : Math.abs(1 / rayDirX);
      const deltaDistY = (rayDirY === 0) ? Infinity : Math.abs(1 / rayDirY);
      let stepX, stepY, hit = 0, side = 0;
      if (rayDirX < 0) { stepX = -1; sideDistX = (posX - mapX)*deltaDistX; }
      else { stepX = 1; sideDistX = (mapX + 1 - posX)*deltaDistX; }
      if (rayDirY < 0) { stepY = -1; sideDistY = (posY - mapY)*deltaDistY; }
      else { stepY = 1; sideDistY = (mapY + 1 - posY)*deltaDistY; }
      while (hit === 0) {
        if (sideDistX < sideDistY) { sideDistX += deltaDistX; mapX += stepX; side = 0; }
        else { sideDistY += deltaDistY; mapY += stepY; side = 1; }
        if (mapX < 0 || mapX >= levelData[0].length || mapY < 0 || mapY >= levelData.length) { hit = 1; break; }
        if (levelData[mapY][mapX] === 1) hit = 1;
      }
      let perpWallDist = (side === 0) ? sideDistX - deltaDistX : sideDistY - deltaDistY;
      if (perpWallDist < 0.01) perpWallDist = 0.01;
      const lineHeight = Math.floor(h / perpWallDist);
      let drawStart = Math.floor(-lineHeight/2 + h/2);
      if (drawStart < 0) drawStart = 0;
      let drawEnd = Math.floor(lineHeight/2 + h/2);
      if (drawEnd >= h) drawEnd = h - 1;
      ctx.fillStyle = (side === 1) ? wallColorDark : wallColor;
      ctx.fillRect(x, drawStart, 1, drawEnd - drawStart + 1);
    }
    // Sprite projection: enemies, pickups, projectiles, particles.
    const spriteList = [];
    const invDet = 1.0 / (planeX * dirY - dirX * planeY);
    const halfW = w / 2, halfH = h / 2;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    // Enemies (only if in line-of-sight)
    for (const enemy of enemies) {
      if (!lineOfSight(player.x, player.y, enemy.x, enemy.y)) continue;
      const ex = enemy.x - posX, ey = enemy.y - posY;
      const transformX = invDet * (dirY * ex - dirX * ey);
      const transformY = invDet * (-planeY * ex + planeX * ey);
      if (transformY <= 0) continue;
      const spriteX = halfW * (1 + transformX/transformY);
      const spriteHeight = Math.abs(Math.floor(h/transformY));
      spriteList.push({ type: 'enemy', char: enemy.isGhost ? "üëª" : "üêì", x: spriteX, height: spriteHeight, depth: transformY });
    }
    // Weapon pickups
    for (const pu of pickups) {
      const px = pu.x - posX, py = pu.y - posY;
      const transformX = invDet * (dirY * px - dirX * py);
      const transformY = invDet * (-planeY * px + planeX * py);
      if (transformY <= 0) continue;
      const spriteX = halfW * (1 + transformX/transformY);
      const spriteHeight = Math.abs(Math.floor((h/transformY)*0.3));
      const emoji = pu.type === "rock" ? "ü™®" : "üó°Ô∏è";
      spriteList.push({ type: 'pickup', char: emoji, x: spriteX, height: spriteHeight, depth: transformY });
    }
    // Project projectiles
    for (const proj of projectiles) {
      const px = proj.x - posX, py = proj.y - posY;
      const transformX = invDet * (dirY * px - dirX * py);
      const transformY = invDet * (-planeY * px + planeX * py);
      if (transformY <= 0) continue;
      const spriteX = halfW * (1 + transformX/transformY);
      const spriteHeight = Math.abs(Math.floor((h/transformY)*0.3));
      spriteList.push({ type: 'projectile', char: proj.weapon, x: spriteX, height: spriteHeight < 1 ? 1 : spriteHeight, depth: transformY, rotation: proj.rotation });
    }
    // Explosion particles
    for (const p of particles) {
      const fx = p.x - posX, fy = p.y - posY;
      const transformX = invDet * (dirY * fx - dirX * fy);
      const transformY = invDet * (-planeY * fx + planeX * fy);
      if (transformY <= 0) continue;
      const spriteX = halfW * (1 + transformX/transformY);
      const spriteHeight = Math.abs(Math.floor((h/transformY)*0.1));
      const yOffset = p.z * 50;
      spriteList.push({ type: 'particle', x: spriteX, height: spriteHeight < 1 ? 1 : spriteHeight, depth: transformY, alpha: p.life, color: p.color, yOffset: yOffset });
    }
    spriteList.sort((a,b) => b.depth - a.depth);
    for (const spr of spriteList) {
      if (spr.x < -spr.height || spr.x > w+spr.height) continue;
      if (spr.type === 'projectile') {
        ctx.save();
        ctx.translate(spr.x, halfH);
        ctx.rotate(spr.rotation);
        ctx.font = spr.height + "px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.fillText(spr.char, 0, 0);
        ctx.restore();
      } else if (spr.type === 'enemy' || spr.type === 'pickup') {
        ctx.font = spr.height + "px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.fillText(spr.char, spr.x, halfH);
      } else if (spr.type === 'particle') {
        ctx.fillStyle = "rgba(" + spr.color + "," + spr.alpha.toFixed(2) + ")";
        ctx.fillRect(spr.x - spr.height/2, halfH - spr.yOffset - spr.height/2, spr.height, spr.height);
      }
    }
    // Damage flash: if player was hit, flash a red overlay
    if (damageFlashTimer > 0) {
      ctx.fillStyle = "rgba(255,0,0,0.4)";
      ctx.fillRect(0, 0, w, h);
    }
  }

  // Joystick handling
  joystick.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    joystickActive = true;
    joystickPointerId = e.pointerId;
    const rect = joystick.getBoundingClientRect();
    joystickCenterX = rect.left + rect.width/2;
    joystickCenterY = rect.top + rect.height/2;
    joystick.setPointerCapture(joystickPointerId);
    const dx = e.clientX - joystickCenterX;
    const dy = e.clientY - joystickCenterY;
    const dist = Math.sqrt(dx*dx+dy*dy);
    let normX = dist ? dx/dist : 0, normY = dist ? dy/dist : 0;
    if (dist > joystickRadius) { normX = dx/dist; normY = dy/dist; }
    if (dist < 5) { normX = 0; normY = 0; }
    moveForward = -normY;
    turnDirection = normX;
    joystickKnob.style.transform = `translate(-50%, -50%) translate(${normX*joystickRadius}px, ${normY*joystickRadius}px)`;
  });
  joystick.addEventListener('pointermove', (e) => {
    if (!joystickActive || e.pointerId !== joystickPointerId) return;
    const dx = e.clientX - joystickCenterX;
    const dy = e.clientY - joystickCenterY;
    const dist = Math.sqrt(dx*dx+dy*dy);
    let normX = dist ? dx/dist : 0, normY = dist ? dy/dist : 0;
    if (dist > joystickRadius) { normX = dx/dist; normY = dy/dist; }
    if (dist < 5) { normX = 0; normY = 0; }
    moveForward = -normY;
    turnDirection = normX;
    joystickKnob.style.transform = `translate(-50%, -50%) translate(${normX*joystickRadius}px, ${normY*joystickRadius}px)`;
  });
  joystick.addEventListener('pointerup', (e) => {
    if (e.pointerId !== joystickPointerId) return;
    joystick.releasePointerCapture(joystickPointerId);
    joystickActive = false;
    joystickPointerId = null;
    moveForward = 0;
    turnDirection = 0;
    joystickKnob.style.transform = 'translate(-50%, -50%)';
  });
  joystick.addEventListener('pointercancel', (e) => {
    if (e.pointerId !== joystickPointerId) return;
    joystickActive = false;
    joystickPointerId = null;
    moveForward = 0;
    turnDirection = 0;
    joystickKnob.style.transform = 'translate(-50%, -50%)';
  });

  // Shoot button & keyboard input
  shootBtn.addEventListener('pointerdown', (e) => { e.preventDefault(); shoot(); });
  window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    if (e.key === " ") { e.preventDefault(); shoot(); }
  });
  window.addEventListener('keyup', (e) => { keys[e.key] = false; });

  // Main game loop
  let lastTime = performance.now();
  function gameLoop(time) {
    const dt = Math.min((time - lastTime)/1000, 0.1);
    lastTime = time;
    if (!gameOver) {
      update(dt);
      render();
      if (gameOver) { finalScreen.style.display = "flex"; return; }
      requestAnimationFrame(gameLoop);
    } else {
      finalScreen.style.display = "flex";
    }
  }

  loadLevel(0);
  requestAnimationFrame(gameLoop);
})();
  </script>
</body>
</html>
