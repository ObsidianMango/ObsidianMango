<!DOCTYPE html>
<html lang="en">
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Emoji FPS Game</title>
  <style>
    /* Fullscreen canvas and disable scrolling */
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
    }
    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
      background: #000;
    }
    /* Top HUD overlay */
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 5px;
      text-align: center;
      font-family: sans-serif;
      font-size: 16px;
      color: #fff;
      background: rgba(0,0,0,0.5);
      z-index: 1;
    }
    /* Joystick (bottom-left) */
    #joystick {
      position: absolute;
      bottom: 10%;
      left: 5%;
      width: 80px;
      height: 80px;
      border: 2px solid #aaa;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      touch-action: none;
      z-index: 2;
    }
    /* Joystick knob */
    #joystickKnob {
      position: absolute;
      width: 40px;
      height: 40px;
      top: 50%;
      left: 50%;
      background: rgba(255,255,255,0.3);
      border: 2px solid #fff;
      border-radius: 50%;
      transform: translate(-50%, -50%);
    }
    /* Shoot button (bottom-right) */
    #shootBtn {
      position: absolute;
      bottom: 10%;
      right: 5%;
      width: 80px;
      height: 80px;
      border: 2px solid #aaa;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      font-size: 36px;
      line-height: 80px;
      text-align: center;
      color: #fff;
      user-select: none;
      touch-action: none;
      z-index: 2;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div id="overlay">Level: 1 | Roosters: 0 | Score: 0</div>
  <div id="joystick"><div id="joystickKnob"></div></div>
  <div id="shootBtn">üçó</div>
  <script>
(() => {
  // Canvas setup
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // UI elements
  const overlay = document.getElementById('overlay');
  const joystick = document.getElementById('joystick');
  const joystickKnob = document.getElementById('joystickKnob');
  const shootBtn = document.getElementById('shootBtn');

  // Game state variables
  let currentLevel = 0;
  let score = 0;
  let levelData = []; // 2D array for map: 0 = empty, 1 = wall
  let enemies = [];   // Array of enemy objects {x, y, dx, dy}
  let player = { x: 0, y: 0, angle: 0 };
  let projectiles = []; // {x, y, dx, dy, rotation, rotationSpeed}
  let particles = [];   // Explosion particles: {x, y, z, vx, vy, vz, life, color}

  // Level definitions (each level is a grid using characters)
  const levels = [
    [
      "#######",
      "#.....#",
      "#..#R.#",
      "#.....#",
      "#P.#.R#",
      "#..#..#",
      "#.R#..#",
      "#.....#",
      "#######"
    ],
    [
      "############",
      "#....R.....#",
      "#.........R#",
      "#..........#",
      "#..###.....#",
      "#..#..R....#",
      "#..#.......#",
      "#..#...P...#",
      "#..#.......#",
      "#..........#",
      "#..R.......#",
      "############"
    ]
  ];

  // Colors and visual settings:
  // Ceiling now is a distinct blue, and floor remains dark gray.
  const ceilingColor = "#005588"; 
  const floorColor = "#444444";
  const wallColor = "#c0c0c0";
  const wallColorDark = "#888888";
  const explosionColors = ["255,165,0", "255,100,0", "255,255,0"];

  // Movement control variables for joystick
  let moveForward = 0;   // from joystick (-1 to 1)
  let turnDirection = 0; // from joystick (-1 to 1)
  const moveSpeed = 3.0; // units per second
  const turnSpeed = 2.0; // radians per second
  const joystickRadius = 40; 
  let joystickActive = false;
  let joystickPointerId = null;
  let joystickCenterX = 0;
  let joystickCenterY = 0;

  // Keyboard input tracking
  const keys = {};

  // HUD update tracking
  let lastLevelDisplay = -1;
  let lastEnemiesDisplay = -1;
  let lastScoreDisplay = -1;

  // Check line-of-sight from (x1,y1) to (x2,y2); returns false if a wall is in between.
  function lineOfSight(x1, y1, x2, y2) {
    const dx = x2 - x1, dy = y2 - y1;
    const distance = Math.hypot(dx, dy);
    const steps = Math.ceil(distance / 0.1);
    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      const x = x1 + dx * t, y = y1 + dy * t;
      if (isWall(x, y)) return false;
    }
    return true;
  }

  // Load a level: parse the level map and initialize player/enemies.
  function loadLevel(index) {
    currentLevel = index;
    enemies = [];
    projectiles = [];
    particles = [];
    const rows = levels[index];
    levelData = [];
    for (let y = 0; y < rows.length; y++) {
      const rowStr = rows[y];
      const rowArr = [];
      for (let x = 0; x < rowStr.length; x++) {
        const ch = rowStr[x];
        if (ch === '#') {
          rowArr.push(1);
        } else if (ch === 'P') {
          player.x = x + 0.5;
          player.y = y + 0.5;
          player.angle = 0;
          rowArr.push(0);
        } else if (ch === 'R') {
          enemies.push({
            x: x + 0.5,
            y: y + 0.5,
            dx: (Math.random() - 0.5) * 1.5,
            dy: (Math.random() - 0.5) * 1.5
          });
          rowArr.push(0);
        } else {
          rowArr.push(0);
        }
      }
      levelData.push(rowArr);
    }
  }

  // Check if position (x,y) is a wall.
  function isWall(x, y) {
    const mx = Math.floor(x);
    const my = Math.floor(y);
    if (my < 0 || my >= levelData.length || mx < 0 || mx >= levelData[0].length)
      return true;
    return levelData[my][mx] === 1;
  }

  // Create an explosion at (x,y) with 150 particles bursting in all directions.
  function createExplosion(x, y) {
    const count = 150;
    for (let i = 0; i < count; i++) {
      const angle = Math.random() * 2 * Math.PI;
      const speed = Math.random() * 3 + 1;
      const vx = Math.sin(angle) * speed;
      const vy = -Math.cos(angle) * speed;
      // Increase vertical spread: wider range for vz.
      const vz = (Math.random() - 0.5) * 6;
      const col = explosionColors[Math.floor(Math.random() * explosionColors.length)];
      particles.push({ x: x, y: y, z: 0, vx: vx, vy: vy, vz: vz, life: 1.0, color: col });
    }
  }

  // Shoot: fire a spinning chicken wing projectile.
  function shoot() {
    const dirX = Math.sin(player.angle);
    const dirY = -Math.cos(player.angle);
    const speed = 6.0;
    projectiles.push({
      x: player.x,
      y: player.y,
      dx: dirX * speed,
      dy: dirY * speed,
      rotation: 0,
      rotationSpeed: Math.PI * 2
    });
  }

  // Update game state.
  function update(dt) {
    // Keyboard input (W/A/S/D or Arrow keys)
    let kbMove = 0;
    let kbTurn = 0;
    if (keys['w'] || keys['ArrowUp']) kbMove += 1;
    if (keys['s'] || keys['ArrowDown']) kbMove -= 1;
    if (keys['a'] || keys['ArrowLeft']) kbTurn -= 1;
    if (keys['d'] || keys['ArrowRight']) kbTurn += 1;
    const effectiveMove = (joystickActive ? moveForward : 0) + kbMove;
    const effectiveTurn = (joystickActive ? turnDirection : 0) + kbTurn;
    
    // Update player rotation.
    player.angle += effectiveTurn * turnSpeed * dt;
    if (player.angle < 0) player.angle += Math.PI * 2;
    if (player.angle >= Math.PI * 2) player.angle -= Math.PI * 2;
    // Update player movement.
    if (effectiveMove !== 0) {
      const moveStep = effectiveMove * moveSpeed * dt;
      const newX = player.x + Math.sin(player.angle) * moveStep;
      const newY = player.y - Math.cos(player.angle) * moveStep;
      if (!isWall(newX, player.y)) player.x = newX;
      if (!isWall(player.x, newY)) player.y = newY;
    }
    // Update enemy movement.
    for (let i = 0; i < enemies.length; i++) {
      const enemy = enemies[i];
      let newX = enemy.x + enemy.dx * dt;
      let newY = enemy.y + enemy.dy * dt;
      if (!isWall(newX, enemy.y)) {
        enemy.x = newX;
      } else {
        enemy.dx = -enemy.dx;
      }
      if (!isWall(enemy.x, newY)) {
        enemy.y = newY;
      } else {
        enemy.dy = -enemy.dy;
      }
    }
    // Update projectiles.
    for (let i = 0; i < projectiles.length; i++) {
      const proj = projectiles[i];
      proj.x += proj.dx * dt;
      proj.y += proj.dy * dt;
      proj.rotation += proj.rotationSpeed * dt;
      if (isWall(proj.x, proj.y)) {
        projectiles.splice(i, 1);
        i--;
        continue;
      }
      if (proj.x < 0 || proj.y < 0 || proj.x >= levelData[0].length || proj.y >= levelData.length) {
        projectiles.splice(i, 1);
        i--;
        continue;
      }
      // Check collision with enemies.
      for (let j = 0; j < enemies.length; j++) {
        const enemy = enemies[j];
        const dx = enemy.x - proj.x;
        const dy = enemy.y - proj.y;
        if (Math.hypot(dx, dy) < 0.5) {
          createExplosion(enemy.x, enemy.y);
          enemies.splice(j, 1);
          j--;
          projectiles.splice(i, 1);
          i--;
          score += 100;
          break;
        }
      }
    }
    // Update explosion particles.
    for (let i = 0; i < particles.length; i++) {
      const p = particles[i];
      p.x += p.vx * dt;
      p.y += p.vy * dt;
      p.z += p.vz * dt;
      p.life -= dt;
      if (p.life <= 0) {
        particles.splice(i, 1);
        i--;
      }
    }
    // Level completion check.
    if (enemies.length === 0) {
      if (currentLevel < levels.length - 1) {
        loadLevel(currentLevel + 1);
      } else {
        loadLevel(0);
      }
    }
  }

  // Render the 3D scene and sprites using raycasting and sprite projection.
  function render() {
    const w = canvas.width;
    const h = canvas.height;
    // Draw ceiling and floor.
    ctx.fillStyle = ceilingColor;
    ctx.fillRect(0, 0, w, h/2);
    ctx.fillStyle = floorColor;
    ctx.fillRect(0, h/2, w, h/2);

    // Player variables for raycasting.
    const posX = player.x;
    const posY = player.y;
    const dirX = Math.sin(player.angle);
    const dirY = -Math.cos(player.angle);
    const fov = 1.0472; // 60¬∞ FOV.
    const planeLen = Math.tan(fov / 2);
    const planeX = -dirY * planeLen;
    const planeY =  dirX * planeLen;

    // Raycasting: draw walls column by column.
    for (let x = 0; x < w; x++) {
      const cameraX = 2 * x / w - 1;
      const rayDirX = dirX + planeX * cameraX;
      const rayDirY = dirY + planeY * cameraX;
      let mapX = Math.floor(posX);
      let mapY = Math.floor(posY);
      let sideDistX, sideDistY;
      const deltaDistX = (rayDirX === 0) ? Infinity : Math.abs(1 / rayDirX);
      const deltaDistY = (rayDirY === 0) ? Infinity : Math.abs(1 / rayDirY);
      let stepX, stepY;
      let hit = 0, side = 0;
      if (rayDirX < 0) {
        stepX = -1;
        sideDistX = (posX - mapX) * deltaDistX;
      } else {
        stepX = 1;
        sideDistX = (mapX + 1.0 - posX) * deltaDistX;
      }
      if (rayDirY < 0) {
        stepY = -1;
        sideDistY = (posY - mapY) * deltaDistY;
      } else {
        stepY = 1;
        sideDistY = (mapY + 1.0 - posY) * deltaDistY;
      }
      while (hit === 0) {
        if (sideDistX < sideDistY) {
          sideDistX += deltaDistX;
          mapX += stepX;
          side = 0;
        } else {
          sideDistY += deltaDistY;
          mapY += stepY;
          side = 1;
        }
        if (mapX < 0 || mapX >= levelData[0].length || mapY < 0 || mapY >= levelData.length) {
          hit = 1;
          break;
        }
        if (levelData[mapY][mapX] === 1) hit = 1;
      }
      let perpWallDist = (side === 0) ? sideDistX - deltaDistX : sideDistY - deltaDistY;
      if (perpWallDist < 0.01) perpWallDist = 0.01;
      const lineHeight = Math.floor(h / perpWallDist);
      let drawStart = Math.floor(-lineHeight / 2 + h / 2);
      if (drawStart < 0) drawStart = 0;
      let drawEnd = Math.floor(lineHeight / 2 + h / 2);
      if (drawEnd >= h) drawEnd = h - 1;
      ctx.fillStyle = (side === 1) ? wallColorDark : wallColor;
      ctx.fillRect(x, drawStart, 1, drawEnd - drawStart + 1);
    }

    // Sprite projection: enemies, projectiles, and explosion particles.
    const spriteList = [];
    const invDet = 1.0 / (planeX * dirY - dirX * planeY);
    const halfW = w / 2;
    const halfH = h / 2;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";

    // Project enemies if in line-of-sight.
    for (let i = 0; i < enemies.length; i++) {
      const enemy = enemies[i];
      if (!lineOfSight(player.x, player.y, enemy.x, enemy.y)) continue;
      const ex = enemy.x - posX;
      const ey = enemy.y - posY;
      const transformX = invDet * (dirY * ex - dirX * ey);
      const transformY = invDet * (-planeY * ex + planeX * ey);
      if (transformY <= 0) continue;
      const spriteX = halfW * (1 + transformX / transformY);
      const spriteHeight = Math.abs(Math.floor(h / transformY));
      spriteList.push({
        type: 'enemy',
        char: "üêì",
        x: spriteX,
        height: spriteHeight,
        depth: transformY
      });
    }
    // Project projectiles (with rotation).
    for (let i = 0; i < projectiles.length; i++) {
      const px = projectiles[i].x - posX;
      const py = projectiles[i].y - posY;
      const transformX = invDet * (dirY * px - dirX * py);
      const transformY = invDet * (-planeY * px + planeX * py);
      if (transformY <= 0) continue;
      const spriteX = halfW * (1 + transformX / transformY);
      const spriteHeight = Math.abs(Math.floor((h / transformY) * 0.3));
      spriteList.push({
        type: 'projectile',
        char: "üçó",
        x: spriteX,
        height: spriteHeight < 1 ? 1 : spriteHeight,
        depth: transformY,
        rotation: projectiles[i].rotation
      });
    }
    // Project explosion particles with vertical offset.
    for (let i = 0; i < particles.length; i++) {
      const fx = particles[i].x - posX;
      const fy = particles[i].y - posY;
      const transformX = invDet * (dirY * fx - dirX * fy);
      const transformY = invDet * (-planeY * fx + planeX * fy);
      if (transformY <= 0) continue;
      const spriteX = halfW * (1 + transformX / transformY);
      const spriteHeight = Math.abs(Math.floor((h / transformY) * 0.1));
      // Use the particle's z to offset vertical placement (increased offset factor).
      const yOffset = particles[i].z * 50;
      spriteList.push({
        type: 'particle',
        x: spriteX,
        height: spriteHeight < 1 ? 1 : spriteHeight,
        depth: transformY,
        alpha: particles[i].life,
        color: particles[i].color,
        yOffset: yOffset
      });
    }
    // Sort sprites by depth (farthest drawn first).
    spriteList.sort((a, b) => b.depth - a.depth);
    // Draw sprites.
    for (let i = 0; i < spriteList.length; i++) {
      const spr = spriteList[i];
      if (spr.x < -spr.height || spr.x > w + spr.height) continue;
      if (spr.type === 'projectile') {
        ctx.save();
        ctx.translate(spr.x, halfH);
        ctx.rotate(spr.rotation);
        ctx.font = spr.height + "px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.fillText(spr.char, 0, 0);
        ctx.restore();
      } else if (spr.type === 'enemy') {
        ctx.font = spr.height + "px sans-serif";
        ctx.fillStyle = "#fff";
        ctx.fillText(spr.char, spr.x, halfH);
      } else if (spr.type === 'particle') {
        ctx.fillStyle = "rgba(" + spr.color + "," + spr.alpha.toFixed(2) + ")";
        ctx.fillRect(spr.x - spr.height/2, halfH - spr.yOffset - spr.height/2, spr.height, spr.height);
      }
    }
  }

  // Joystick handling (pointer events)
  joystick.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    joystickActive = true;
    joystickPointerId = e.pointerId;
    const rect = joystick.getBoundingClientRect();
    joystickCenterX = rect.left + rect.width / 2;
    joystickCenterY = rect.top + rect.height / 2;
    joystick.setPointerCapture(joystickPointerId);
    const dx = e.clientX - joystickCenterX;
    const dy = e.clientY - joystickCenterY;
    const dist = Math.sqrt(dx*dx + dy*dy);
    let normX = dx / joystickRadius;
    let normY = dy / joystickRadius;
    if (dist > joystickRadius) {
      normX = dx / dist;
      normY = dy / dist;
    }
    if (dist < 5) { normX = 0; normY = 0; }
    moveForward = -normY;
    turnDirection = normX;
    joystickKnob.style.transform = `translate(-50%, -50%) translate(${normX * joystickRadius}px, ${normY * joystickRadius}px)`;
  });
  joystick.addEventListener('pointermove', (e) => {
    if (!joystickActive || e.pointerId !== joystickPointerId) return;
    const dx = e.clientX - joystickCenterX;
    const dy = e.clientY - joystickCenterY;
    const dist = Math.sqrt(dx * dx + dy * dy);
    let normX = dx / joystickRadius;
    let normY = dy / joystickRadius;
    if (dist > joystickRadius) {
      normX = dx / dist;
      normY = dy / dist;
    }
    if (dist < 5) { normX = 0; normY = 0; }
    moveForward = -normY;
    turnDirection = normX;
    joystickKnob.style.transform = `translate(-50%, -50%) translate(${normX * joystickRadius}px, ${normY * joystickRadius}px)`;
  });
  joystick.addEventListener('pointerup', (e) => {
    if (e.pointerId !== joystickPointerId) return;
    joystick.releasePointerCapture(joystickPointerId);
    joystickActive = false;
    joystickPointerId = null;
    moveForward = 0;
    turnDirection = 0;
    joystickKnob.style.transform = 'translate(-50%, -50%)';
  });
  joystick.addEventListener('pointercancel', (e) => {
    if (e.pointerId !== joystickPointerId) return;
    joystickActive = false;
    joystickPointerId = null;
    moveForward = 0;
    turnDirection = 0;
    joystickKnob.style.transform = 'translate(-50%, -50%)';
  });

  // Shoot button handling
  shootBtn.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    shoot();
  });

  // Keyboard input handling
  window.addEventListener('keydown', (e) => {
    keys[e.key] = true;
    if (e.key === " ") {
      e.preventDefault();
      shoot();
    }
  });
  window.addEventListener('keyup', (e) => {
    keys[e.key] = false;
  });

  // Main game loop
  let lastTime = performance.now();
  function gameLoop(time) {
    const dt = Math.min((time - lastTime) / 1000, 0.1);
    lastTime = time;
    update(dt);
    if (currentLevel + 1 !== lastLevelDisplay || enemies.length !== lastEnemiesDisplay || score !== lastScoreDisplay) {
      overlay.textContent = `Level: ${currentLevel + 1} | Roosters: ${enemies.length} | Score: ${score}`;
      lastLevelDisplay = currentLevel + 1;
      lastEnemiesDisplay = enemies.length;
      lastScoreDisplay = score;
    }
    render();
    requestAnimationFrame(gameLoop);
  }

  loadLevel(0);
  requestAnimationFrame(gameLoop);
})();
  </script>
</body>
</html>
