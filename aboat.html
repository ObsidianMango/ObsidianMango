<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>Low-Poly 3D Boat + Waves (No Bundler, Single File)</title>
<style>
  html,body{margin:0;height:100%;background:#0a0f1a;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  #ui{
    position:fixed;inset:0;pointer-events:none;
  }
  .panel{
    position:absolute;left:12px;top:12px;pointer-events:auto;
    background:#111a; backdrop-filter: blur(6px);
    color:#eee;border:1px solid #333;border-radius:10px;padding:10px 12px;line-height:1.35
  }
  .panel h1{font-size:14px;margin:0 0 6px 0;font-weight:700;letter-spacing:.3px}
  .panel .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .panel button,.chip{
    padding:6px 10px;border-radius:8px;border:1px solid #444;background:#1b2230;color:#eaeaea;
    cursor:pointer;font-size:12px
  }
  .panel button:hover{background:#243146}
  .chip{display:inline-block}
  .stat{display:inline-block;min-width:58px}
  .small{opacity:.8;font-size:12px}
  #help{
    position:absolute;right:12px;top:12px;pointer-events:auto;
    background:#111a;border:1px solid #333;border-radius:10px;padding:8px 10px;color:#eaeaea;max-width:320px
  }
  #help b{color:#fff}
  #mobile{
    position:absolute;left:0;right:0;bottom:0;height:46%;pointer-events:none;
  }
  .zone{
    position:absolute;bottom:0;top:auto;width:50%;height:100%;
    pointer-events:auto;touch-action:none;opacity:.08
  }
  .zone.left{left:0;background:#5af}
  .zone.right{right:0;background:#fa5}
  .hud{
    position:absolute;left:50%;bottom:12px;transform:translateX(-50%);
    pointer-events:none;color:#e6f1ff;text-shadow:0 1px 0 #000a; font-size:14px
  }
  .bar{height:8px;background:#0f2238;border:1px solid #274264;border-radius:999px;overflow:hidden;margin-top:4px}
  .fill{height:100%;width:0;background:#5cf;transition:width .12s}
  .slider{
    width:160px;appearance:none;height:6px;border-radius:999px;background:#29405f;outline:none
  }
  .slider::-webkit-slider-thumb{appearance:none;width:16px;height:16px;border-radius:50%;background:#bfe3ff;border:2px solid #20354f}
  canvas{display:block}
</style>
</head>
<body>
<div id="ui">
  <div class="panel" id="panel">
    <h1>Boat Simulator — Low Poly</h1>
    <div class="row">
      <button id="camBtn" title="Cycle camera modes">Camera: <span id="camMode">CHASE</span></button>
      <button id="pauseBtn">Pause</button>
      <button id="resetBtn" title="Reset boat to origin">Reset Boat</button>
      <button id="seaBtn" title="Randomize wave set">Random Sea</button>
    </div>
    <div class="row small">
      <span class="chip stat">FPS: <span id="fps">60</span></span>
      <span class="chip stat">KTS: <span id="knots">0.0</span></span>
      <span class="chip stat">SEA: <span id="seaState">3</span>/6</span>
      <span class="chip stat">WAVES: <span id="waveCount">5</span></span>
    </div>
    <div class="row small">
      <label>Time of day</label>
      <input id="timeSlider" class="slider" type="range" min="0" max="24" step="0.1" value="13">
      <span id="timeLbl" class="chip">13:00</span>
    </div>
    <div class="row small">
      <label>Sea roughness</label>
      <input id="roughSlider" class="slider" type="range" min="0" max="1" step="0.01" value="0.45">
      <span id="roughLbl" class="chip">0.45</span>
    </div>
  </div>
  <div id="help">
    <div><b>Controls</b></div>
    <div class="small">W/S = throttle · A/D = steer · Space = handbrake · C = camera · R = reset · 1–6 = sea state</div>
    <div class="small">Drag mouse (orbit mode), or tap left/right for steer & right-side drag up/down for throttle.</div>
  </div>
  <div id="mobile">
    <div class="zone left" id="zoneL" title="Steer"></div>
    <div class="zone right" id="zoneR" title="Throttle"></div>
  </div>
  <div class="hud">
    <div>Throttle</div>
    <div class="bar"><div id="thFill" class="fill"></div></div>
  </div>
</div>

<script type="module">
/* ===== Imports (CDN, no bundler) ===== */
import * as THREE from "https://unpkg.com/three@0.164.1/build/three.module.js";
import { OrbitControls } from "https://unpkg.com/three@0.164.1/examples/jsm/controls/OrbitControls.js";

/* ===== Renderer / Scene / Camera ===== */
const renderer = new THREE.WebGLRenderer({ antialias:true, powerPreference:"high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.shadowMap.enabled = false;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0a0f1a, 60, 560);

const camera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 2000);
camera.position.set(0, 8, 18);

/* ===== Lights & Sky ===== */
const hemi = new THREE.HemisphereLight(0xbfe3ff, 0x20303b, 0.8);
scene.add(hemi);

const sun = new THREE.DirectionalLight(0xffffff, 0.75);
sun.position.set(-30, 45, 15);
scene.add(sun);

/* Sky dome (low poly) */
const skyGeo = new THREE.SphereGeometry(1000, 16, 12);
const skyMat = new THREE.MeshLambertMaterial({ color:0x71a6ff, side:THREE.BackSide, flatShading:true });
const sky = new THREE.Mesh(skyGeo, skyMat);
scene.add(sky);

/* ===== Helpers (low poly palette) ===== */
const COLORS = {
  water: 0x1a4a6b, // base water color (diffuse)
  boatHull: 0xff6a3d,
  boatDeck: 0xf5d38c,
  boatTrim: 0x22334a
};

/* ===== Ocean (Gerstner waves, low-poly plane) ===== */
const GRID = Math.min(180, Math.floor((Math.min(window.innerWidth, window.innerHeight))/3)); // adaptive grid
const SIZE = 400;                            // world size of water patch
const HALF = SIZE/2;
const segs = Math.max(64, Math.floor(GRID*0.9));
const waterGeo = new THREE.PlaneGeometry(SIZE, SIZE, segs, segs).toNonIndexed(); // per-face verts -> chunky/flat
waterGeo.rotateX(-Math.PI/2);
const waterMat = new THREE.MeshLambertMaterial({
  color: COLORS.water, flatShading:true, emissive:0x030a12, emissiveIntensity:0.35
});
const water = new THREE.Mesh(waterGeo, waterMat);
water.frustumCulled = false;
scene.add(water);

const pos = water.geometry.attributes.position;
const base = pos.array.slice(0); // original grid positions

/* Wave config */
const GRAVITY = 9.81;
let seaState = 3;        // 1..6
let roughness = 0.45;    // 0..1
let timeOfDay = 13.0;    // 0..24
let W = [];              // waves

function randomWaves(state=seaState, rough=roughness){
  const count = THREE.MathUtils.clamp(2 + state, 3, 8);
  const list = [];
  for(let i=0;i<count;i++){
    const dir = new THREE.Vector2(Math.random()*2-1, Math.random()*2-1).normalize();
    const lambda = THREE.MathUtils.lerp(8, 120, Math.random());             // wavelength
    const k = 2*Math.PI / lambda;                                           // wave number
    const a = THREE.MathUtils.lerp(0.15, 2.0, Math.random()*rough) * (state*0.12); // amplitude scales w/ sea state
    const c = Math.sqrt(GRAVITY/k)*THREE.MathUtils.lerp(0.6, 1.1, Math.random()); // dispersion
    const steep = THREE.MathUtils.lerp(0.2, 1.05, Math.random()*rough);     // steepness
    const phase = Math.random()*Math.PI*2;
    list.push({dir, lambda, k, a, c, steep, phase});
  }
  return list;
}
W = randomWaves();

/* Evaluate summed height at (x,z) + approximate normal via finite differences */
function sampleWaves(x, z, t){
  let y = 0;
  for(const w of W){
    const d = w.dir;
    const s = w.k*(d.x*x + d.y*z) - (w.c*w.k)*t + w.phase;
    y += w.a * Math.sin(s);
  }
  return y;
}
function surfaceNormal(x,z,t,eps=0.5){
  const hL = sampleWaves(x-eps, z, t);
  const hR = sampleWaves(x+eps, z, t);
  const hD = sampleWaves(x, z-eps, t);
  const hU = sampleWaves(x, z+eps, t);
  const dx = hR - hL;
  const dz = hU - hD;
  const n = new THREE.Vector3(-dx/(2*eps), 1, -dz/(2*eps)).normalize();
  return n;
}

/* Animate water vertices */
function updateWater(t){
  const arr = pos.array;
  for(let i=0;i<arr.length;i+=3){
    const x0 = base[i];
    const z0 = base[i+2];
    arr[i+1] = sampleWaves(x0, z0, t);
  }
  pos.needsUpdate = true;
  water.geometry.computeVertexNormals(); // ok w/ flatShading
}

/* ===== Boat (low-poly composite mesh) ===== */
function makeBoat(){
  const group = new THREE.Group();

  // Hull (prismatic wedge + box)
  const hullLen=6, hullWide=2.2, hullHigh=1.2;
  const stern = new THREE.BoxGeometry(hullLen*0.58, hullHigh, hullWide);
  stern.translate(-hullLen*0.08, hullHigh*0.45, 0);

  const bow = new THREE.ConeGeometry(hullWide*0.9, hullLen*0.58, 6);
  bow.rotateZ(Math.PI/2);
  bow.rotateY(Math.PI/2);
  bow.translate(hullLen*0.29, hullHigh*0.42, 0);

  const hullMat = new THREE.MeshLambertMaterial({ color:COLORS.boatHull, flatShading:true });
  const sternMesh = new THREE.Mesh(stern, hullMat);
  const bowMesh = new THREE.Mesh(bow, hullMat);
  group.add(sternMesh, bowMesh);

  // Deckhouse
  const deck = new THREE.BoxGeometry(hullLen*0.38, hullHigh*0.7, hullWide*0.9);
  deck.translate(-hullLen*0.05, hullHigh*1.1, 0);
  const deckMesh = new THREE.Mesh(deck, new THREE.MeshLambertMaterial({ color:COLORS.boatDeck, flatShading:true }));
  group.add(deckMesh);

  // Trim (keel + mast)
  const keel = new THREE.BoxGeometry(hullLen*0.4, hullHigh*0.25, hullWide*0.2);
  keel.translate(-hullLen*0.1, hullHigh*0.05, 0);
  group.add(new THREE.Mesh(keel, new THREE.MeshLambertMaterial({ color:COLORS.boatTrim, flatShading:true })));

  const mast = new THREE.CylinderGeometry(0.06, 0.08, hullHigh*2.8, 6);
  mast.translate(-hullLen*0.05, hullHigh*1.9, 0);
  group.add(new THREE.Mesh(mast, new THREE.MeshLambertMaterial({ color:0xe7edf7, flatShading:true })));

  // Shadow toggle off for perf (we aren't using shadows)
  group.traverse(o=>{ if(o.isMesh){ o.castShadow=false; o.receiveShadow=false; } });

  // Physics-ish state
  group.userData = {
    vel: new THREE.Vector3(),              // world velocity
    speed: 0,                              // scalar forward speed m/s
    heading: 0,                            // yaw (radians)
    throttle: 0,                           // -1..+1
    steer: 0,                              // -1..+1
    buoyOffset: 0.2                        // how high above waterline
  };

  // Helpful axis to know forward vector
  const nose = new THREE.AxesHelper(1.2);
  nose.position.set(hullLen*0.35, hullHigh*0.5, 0);
  nose.visible = false; // set true for debugging
  group.add(nose);

  return group;
}
const boat = makeBoat();
scene.add(boat);
boat.position.set(0, 0.8, 0);

/* ===== Camera modes ===== */
const CAM_MODES = ["CHASE","ORBIT","FIRST"];
let camModeIndex = 0;
const orbit = new OrbitControls(camera, renderer.domElement);
orbit.enabled = false;
orbit.enablePan = false;
orbit.maxPolarAngle = Math.PI*0.495;
orbit.target.set(boat.position.x, boat.position.y+1.2, boat.position.z);
orbit.update();

function setCameraMode(idx){
  camModeIndex = (idx+CAM_MODES.length)%CAM_MODES.length;
  const mode = CAM_MODES[camModeIndex];
  document.getElementById("camMode").textContent = mode;
  if(mode==="ORBIT"){
    orbit.enabled = true;
  }else{
    orbit.enabled = false;
  }
}
setCameraMode(0);

/* ===== Input (keyboard + mobile zones) ===== */
const keys = { w:false, s:false, a:false, d:false, space:false };
addEventListener("keydown", (e)=>{
  if(e.repeat) return;
  if(e.code==="KeyW") keys.w = true;
  if(e.code==="KeyS") keys.s = true;
  if(e.code==="KeyA") keys.a = true;
  if(e.code==="KeyD") keys.d = true;
  if(e.code==="Space") keys.space = true;
  if(e.code==="KeyC") setCameraMode(camModeIndex+1);
  if(e.code==="KeyR") resetBoat();
  if(e.code==="Digit1") setSeaState(1);
  if(e.code==="Digit2") setSeaState(2);
  if(e.code==="Digit3") setSeaState(3);
  if(e.code==="Digit4") setSeaState(4);
  if(e.code==="Digit5") setSeaState(5);
  if(e.code==="Digit6") setSeaState(6);
});
addEventListener("keyup", (e)=>{
  if(e.code==="KeyW") keys.w = false;
  if(e.code==="KeyS") keys.s = false;
  if(e.code==="KeyA") keys.a = false;
  if(e.code==="KeyD") keys.d = false;
  if(e.code==="Space") keys.space = false;
});

/* Mobile zones: left = steer, right = throttle */
const zoneL = document.getElementById("zoneL");
const zoneR = document.getElementById("zoneR");
let steerTouch = null, throttleTouch = null, thrVal = 0, steerVal = 0;

zoneL.addEventListener("pointerdown",(e)=>{ steerTouch = {id:e.pointerId, sx:e.clientX, sy:e.clientY}; zoneL.setPointerCapture(e.pointerId); });
zoneL.addEventListener("pointermove",(e)=>{ if(!steerTouch || steerTouch.id!==e.pointerId) return; const dx = (e.clientX - steerTouch.sx); steerVal = THREE.MathUtils.clamp(dx/80, -1, 1); });
zoneL.addEventListener("pointerup",(e)=>{ if(steerTouch && steerTouch.id===e.pointerId){ steerTouch=null; steerVal=0; zoneL.releasePointerCapture(e.pointerId);} });

zoneR.addEventListener("pointerdown",(e)=>{ throttleTouch = {id:e.pointerId, sx:e.clientX, sy:e.clientY}; zoneR.setPointerCapture(e.pointerId); });
zoneR.addEventListener("pointermove",(e)=>{ if(!throttleTouch || throttleTouch.id!==e.pointerId) return; const dy = (throttleTouch.sy - e.clientY); thrVal = THREE.MathUtils.clamp(dy/120, -1, 1); });
zoneR.addEventListener("pointerup",(e)=>{ if(throttleTouch && throttleTouch.id===e.pointerId){ throttleTouch=null; thrVal=0; zoneR.releasePointerCapture(e.pointerId);} });

/* ===== Boat dynamics ===== */
const tmpVec = new THREE.Vector3();
function updateBoat(dt, t){
  const u = boat.userData;

  // Inputs: keyboard blended w/ touch
  const throttleIn = (keys.w?1:0) + (keys.s?-1:0) + thrVal;
  u.throttle = THREE.MathUtils.clamp(u.throttle*0.9 + throttleIn*0.1, -1, 1);

  const steerIn = (keys.a?-1:0) + (keys.d?1:0) + steerVal;
  u.steer = THREE.MathUtils.clamp(steerIn, -1, 1);

  // Simple longitudinal dynamics
  const maxFwd = 14.0;        // m/s ~ 27 knots
  const maxRev = -3.0;        // m/s reverse
  const accel = 4.5;          // m/s^2
  const brake = keys.space ? 10.0 : 0.6; // handbrake vs water drag
  const drag = 0.22 + 0.06 * Math.abs(u.speed); // quadratic-ish drag

  const targetSpeed = u.throttle >= 0 ? (u.throttle*maxFwd) : (u.throttle*Math.abs(maxRev));
  const dv = THREE.MathUtils.clamp(targetSpeed - u.speed, -accel*dt, accel*dt);
  u.speed += dv;
  // Drag / brake
  const resist = Math.sign(u.speed) * Math.min(Math.abs(u.speed), (drag + brake)*dt);
  u.speed -= resist;

  // Yaw dynamics (turn more when moving & with sea state)
  const turnRate = (0.8 + seaState*0.06) * u.steer * (u.speed/ maxFwd);
  u.heading += turnRate * dt;

  // Integrate position in XZ
  const fwd = new THREE.Vector3(Math.cos(u.heading), 0, Math.sin(u.heading));
  tmpVec.copy(fwd).multiplyScalar(u.speed*dt);
  boat.position.add(tmpVec);

  // Buoyancy: place boat on wave, compute surface normal for roll/pitch
  const y = sampleWaves(boat.position.x, boat.position.z, t);
  const n = surfaceNormal(boat.position.x, boat.position.z, t);
  boat.position.y = y + u.buoyOffset;

  // Orientation: align with surface normal but preserve yaw heading
  // Build a quaternion from normal and heading:
  // 1) base orientation looking along fwd with up=n
  const zAxis = new THREE.Vector3().copy(fwd).normalize();
  const xAxis = new THREE.Vector3().crossVectors(new THREE.Vector3(0,1,0), zAxis).normalize();
  const yAxis = new THREE.Vector3().crossVectors(zAxis, xAxis).normalize();
  // tilt toward actual surface normal (blend)
  const blend = 0.88;
  const yUp = new THREE.Vector3().lerpVectors(yAxis, n, blend).normalize();
  const xSide = new THREE.Vector3().crossVectors(yUp, zAxis).normalize();
  const zFwd  = new THREE.Vector3().crossVectors(xSide, yUp).normalize();
  const m = new THREE.Matrix4().makeBasis(xSide, yUp, zFwd);
  const q = new THREE.Quaternion().setFromRotationMatrix(m);
  boat.quaternion.slerp(q, 0.18); // smooth

  // Simple bobbing/engine vibration
  boat.rotation.z += (Math.sin(t*12 + boat.position.x*0.1)*0.0005);
}

/* ===== Camera follow ===== */
const camOff = new THREE.Vector3(-9, 5.2, 0); // relative to boat forward (behind/above)
function updateCamera(dt){
  const mode = CAM_MODES[camModeIndex];
  if(mode==="ORBIT"){
    orbit.target.lerp(new THREE.Vector3(boat.position.x, boat.position.y+1.2, boat.position.z), 0.15);
    orbit.update();
    return;
  }
  if(mode==="FIRST"){
    // Seat-level perspective
    const u = boat.userData;
    const fwd = new THREE.Vector3(Math.cos(u.heading), 0, Math.sin(u.heading));
    const up = new THREE.Vector3(0,1,0);
    const side = new THREE.Vector3().crossVectors(fwd, up).normalize();
    const eye = new THREE.Vector3().copy(boat.position)
      .addScaledVector(fwd, 1.2)
      .addScaledVector(up, 1.0)
      .addScaledVector(side, 0.0);
    const look = new THREE.Vector3().copy(boat.position).addScaledVector(fwd, 10.0);
    camera.position.lerp(eye, 0.35);
    camera.lookAt(look);
    return;
  }
  // CHASE
  const u = boat.userData;
  const fwd = new THREE.Vector3(Math.cos(u.heading), 0, Math.sin(u.heading));
  const up = new THREE.Vector3(0,1,0);
  const side = new THREE.Vector3().crossVectors(fwd, up).normalize();
  const desired = new THREE.Vector3().copy(boat.position)
    .addScaledVector(fwd, camOff.x)      // behind (camOff.x is negative)
    .addScaledVector(up, camOff.y)       // up
    .addScaledVector(side, camOff.z);    // sideways
  camera.position.lerp(desired, 0.08);
  const target = new THREE.Vector3().copy(boat.position).addScaledVector(fwd, 6).addScaledVector(up, 1.2);
  camera.lookAt(target);
}

/* ===== Time of day / lighting ===== */
function updateTimeOfDay(){
  const t = timeOfDay/24; // 0..1
  const skyTop = new THREE.Color().setHSL(0.58, 0.5, THREE.MathUtils.lerp(0.1, 0.75, Math.pow(Math.sin(Math.PI*t), 0.9)));
  const skyBot = new THREE.Color(0x20303b);
  sky.material.color.copy(skyTop);
  scene.fog.color.copy(new THREE.Color().lerpColors(skyBot, skyTop, 0.35));

  // Animate sun arc
  const theta = (timeOfDay/24)*Math.PI*2; // daily cycle
  const elev = Math.cos(theta)*0.85;      // raise/lower
  sun.position.set(Math.sin(theta)*60, THREE.MathUtils.lerp(3, 80, (elev+1)/2), Math.cos(theta)*40);
  sun.intensity = THREE.MathUtils.lerp(0.15, 1.0, (elev+1)/2);
  hemi.intensity = THREE.MathUtils.lerp(0.2, 0.9, (elev+1)/2);
}

/* ===== UI wiring ===== */
const fpsLbl = document.getElementById("fps");
const ktsLbl = document.getElementById("knots");
const thFill = document.getElementById("thFill");
const seaLbl = document.getElementById("seaState");
const waveCountLbl = document.getElementById("waveCount");
const timeSlider = document.getElementById("timeSlider");
const timeLbl = document.getElementById("timeLbl");
const roughSlider = document.getElementById("roughSlider");
const roughLbl = document.getElementById("roughLbl");

document.getElementById("camBtn").onclick = ()=> setCameraMode(camModeIndex+1);
document.getElementById("resetBtn").onclick = resetBoat;
document.getElementById("seaBtn").onclick = ()=>{ randomizeSea(); };
document.getElementById("pauseBtn").onclick = ()=>{ paused = !paused; };

timeSlider.oninput = (e)=>{ timeOfDay = parseFloat(e.target.value); timeLbl.textContent = `${timeOfDay.toFixed(1)}:00`.replace(".0",""); updateTimeOfDay(); };
roughSlider.oninput = (e)=>{ roughness = parseFloat(e.target.value); roughLbl.textContent = roughness.toFixed(2); randomizeSea(); };

function setSeaState(n){
  seaState = THREE.MathUtils.clamp(n,1,6);
  randomizeSea();
}
function randomizeSea(){
  W = randomWaves(seaState, roughness);
  seaLbl.textContent = seaState;
  waveCountLbl.textContent = W.length;
}

/* ===== Reset ===== */
function resetBoat(){
  boat.position.set(0, 0.8, 0);
  boat.userData.speed = 0;
  boat.userData.heading = 0;
}

/* ===== Main loop ===== */
let t0 = performance.now()/1000, paused=false;
let fpsSampTime = 0, frames = 0, fps = 60;
function loop(){
  requestAnimationFrame(loop);
  const t1 = performance.now()/1000;
  const dt = Math.min(0.033, Math.max(0.0001, t1 - t0));
  t0 = t1;
  if(!paused){
    const simT = t1;
    updateWater(simT);
    updateBoat(dt, simT);
    updateCamera(dt);
    updateTimeOfDay();
  }
  renderer.render(scene, camera);

  // HUD
  const mps = boat.userData.speed;
  const knots = Math.max(0, mps) * 1.94384;
  ktsLbl.textContent = knots.toFixed(1);
  const thPct = (boat.userData.throttle+1)/2;
  thFill.style.width = `${(thPct*100).toFixed(1)}%`;

  // FPS
  frames++; fpsSampTime += dt;
  if(fpsSampTime > 0.5){ fps = Math.round(frames/fpsSampTime); fpsSampTime = 0; frames=0; fpsLbl.textContent = fps; }
}
loop();

/* ===== Handle resize ===== */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
});

/* ===== Kick things off ===== */
updateTimeOfDay();
randomizeSea();

</script>
</body>
</html>