<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Low‑Poly Ocean — Boat, Waves, Sharks</title>
<style>
  html,body{margin:0;height:100%;background:#6db5ff}
  canvas{position:fixed;inset:0}
  .hud{position:fixed;left:12px;bottom:12px;color:#fff;font:600 12px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .pill{background:rgba(0,0,0,.35);padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px)}
  #stick{position:fixed;left:14px;bottom:70px;width:120px;height:120px;border-radius:50%;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.2);touch-action:none}
  #thumb{position:absolute;left:50%;top:50%;width:54px;height:54px;margin:-27px 0 0 -27px;border-radius:50%;background:rgba(255,255,255,.25);border:1px solid rgba(255,255,255,.5)}
  #spear{position:fixed;right:14px;bottom:26px;width:120px;height:120px;border-radius:50%;background:rgba(220,40,40,.85);color:#fff;font:800 18px system-ui,-apple-system;display:flex;align-items:center;justify-content:center;box-shadow:0 6px 14px rgba(0,0,0,.35);touch-action:none;border:none}
  #spear.cool{background:rgba(110,110,110,.6)}
  .tag{position:fixed;right:14px;top:14px;color:#fff;background:rgba(0,0,0,.35);padding:6px 10px;border-radius:8px;font:600 12px system-ui}
</style>
</head>
<body>
<canvas id="app"></canvas>
<div class="hud pill">Drag circle to steer • Pinch/scroll to zoom</div>
<div id="stick"><div id="thumb"></div></div>
<button id="spear" aria-label="Throw Spear">SPEAR</button>
<div class="tag pill" id="status">Calm seas</div>

<!-- Fix: use an import map so bare imports resolve reliably on iPhone/Google Sites/Safari -->
<script type="importmap">
{
  "imports": {
    "three": "https://esm.sh/three@0.165.0",
    "three/addons/": "https://esm.sh/three@0.165.0/examples/jsm/"
  }
}
</script>

<script type="module">
/* CPU‑driven low‑poly waves (visible facets), rock‑solid on iPhone */
import * as THREE from 'three';
import { Sky } from 'three/addons/objects/Sky.js';

const DPR_CAP=1.5;
const canvas=document.getElementById('app');
const renderer=new THREE.WebGLRenderer({canvas,antialias:false,powerPreference:'high-performance'});
renderer.setPixelRatio(Math.min(devicePixelRatio||1,DPR_CAP));
renderer.setSize(innerWidth,innerHeight,false);
renderer.outputColorSpace=THREE.SRGBColorSpace;
renderer.toneMapping=THREE.ACESFilmicToneMapping;

const scene=new THREE.Scene();
scene.fog=new THREE.FogExp2(0x7fbfff,0.0007);

const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,2000);
camera.position.set(0,2.3,7);

const hemi=new THREE.HemisphereLight(0xBBD8FF,0x1d3557,0.9); scene.add(hemi);
const sunLight=new THREE.DirectionalLight(0xffffff,0.75); sunLight.position.set(1,1,0.5).normalize(); scene.add(sunLight);

/* Pretty sky */
const sky=new Sky(); sky.scale.setScalar(10000); scene.add(sky);
const su=sky.material.uniforms; su.turbidity.value=8; su.rayleigh.value=1.2; su.mieCoefficient.value=0.005; su.mieDirectionalG.value=0.8;
const sun=new THREE.Vector3();
(function setSun(elev=14+Math.random()*8,az=150+Math.random()*40){const phi=THREE.MathUtils.degToRad(90-elev),th=THREE.MathUtils.degToRad(az);sun.setFromSphericalCoords(1,phi,th);su.sunPosition.value.copy(sun);sunLight.position.copy(sun).multiplyScalar(1500);})();

/* ===== LOW‑POLY OCEAN (CPU vertex displacement + flat shading) ===== */
const O_SIZE=1200, SEG=120; // 121*121 = 14641 verts → fine on mobile
const oceanGeo=new THREE.PlaneGeometry(O_SIZE,O_SIZE,SEG,SEG);
oceanGeo.rotateX(-Math.PI/2);
const oceanMat=new THREE.MeshStandardMaterial({color:0x2b76a8,roughness:0.9,metalness:0.0,flatShading:true});
const ocean=new THREE.Mesh(oceanGeo,oceanMat); ocean.frustumCulled=false; scene.add(ocean);

// cache original xz for waves
const pos=oceanGeo.attributes.position;
const baseXZ=new Float32Array(pos.count*2);
for(let i=0;i<pos.count;i++){ baseXZ[i*2]=pos.getX(i); baseXZ[i*2+1]=pos.getZ(i); }

/* wave params (multiple moving sine sets) */
const waves=[
  {amp:1.1,  freq:0.012, dir:new THREE.Vector2(1, 0.3).normalize(), speed:0.5},
  {amp:0.55, freq:0.017, dir:new THREE.Vector2(-0.6, 1).normalize(), speed:0.22},
  {amp:0.3,  freq:0.014, dir:new THREE.Vector2(0.2,-1).normalize(), speed:0.12},
];
let tNow=0, normalsTick=0;
function sampleHeight(x,z,t){
  let y=0;
  for(const w of waves){ const k=w.freq; const d=w.dir; y+=Math.sin((x*d.x+z*d.y)*k + t*w.speed)*w.amp; }
  return y;
}
function updateOcean(dt){
  tNow+=dt;
  for(let i=0;i<pos.count;i++){
    const x=baseXZ[i*2], z=baseXZ[i*2+1];
    const y=sampleHeight(x,z,tNow);
    pos.setY(i,y);
  }
  pos.needsUpdate=true;

  // recompute normals less often for perf; keeps faceted look
  normalsTick=(normalsTick+1)%2;
  if(normalsTick===0){ oceanGeo.computeVertexNormals(); oceanGeo.normalizeNormals(); oceanMat.needsUpdate=true; }
}

/* ===== Boat (controllable) ===== */
function makeBoat(){
  const hull=new THREE.Mesh(new THREE.ConeGeometry(0.7,2.4,6), new THREE.MeshStandardMaterial({color:0x8a4928,roughness:0.9,flatShading:true}));
  hull.rotation.x=Math.PI/2; hull.position.y=0.25;
  const deck=new THREE.Mesh(new THREE.BoxGeometry(0.6,0.2,1.0), new THREE.MeshStandardMaterial({color:0xcaa572,roughness:0.9,flatShading:true}));
  deck.position.set(0,0.55,0.1);
  const mast=new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,1.2,6), new THREE.MeshStandardMaterial({color:0xddd7c9,roughness:0.8,flatShading:true}));
  mast.position.set(0,1.1,-0.1);
  const sail=new THREE.Mesh(new THREE.ConeGeometry(0.02,0.9,3), new THREE.MeshStandardMaterial({color:0xffffff,roughness:0.95,flatShading:true}));
  sail.position.set(0.15,0.7,-0.1); sail.rotation.z=Math.PI/2;
  const g=new THREE.Group(); g.add(hull,deck,mast,sail); g.position.set(0,0,0);
  g.userData={vel:new THREE.Vector2(0,0),heading:0,speed:0};
  return g;
}
const boat=makeBoat(); scene.add(boat);

/* Camera follow */
let camYaw=0, camPitch=-0.12, camDist=7.2, targetDist=7.2;

/* ===== Seagulls (instanced) ===== */
const birdGeom=new THREE.ConeGeometry(0.12,0.5,3); birdGeom.rotateX(Math.PI/2);
const birdMat=new THREE.MeshStandardMaterial({color:0xffffff,flatShading:true,roughness:.6});
const BIRDS=22; const gulls=new THREE.InstancedMesh(birdGeom,birdMat,BIRDS); gulls.instanceMatrix.setUsage(THREE.DynamicDrawUsage); scene.add(gulls);
const birdData=[...Array(BIRDS)].map(()=>({a:Math.random()*Math.PI*2,r:18+Math.random()*70,h:7+Math.random()*10,spd:.12+Math.random()*.22,wob:Math.random()*Math.PI*2}));

/* ===== Fish schools (instanced) ===== */
const fishGeom=new THREE.CapsuleGeometry(0.06,0.18,1,5);
const fishMat=new THREE.MeshStandardMaterial({color:0x66c2ff,roughness:.7,flatShading:true});
const FISH_PER_SCHOOL=70, MAX_SCHOOLS=5;
const fishSchools=[];
function spawnSchool(center){
  const mesh=new THREE.InstancedMesh(fishGeom,fishMat,FISH_PER_SCHOOL);
  mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); scene.add(mesh);
  const data=[...Array(FISH_PER_SCHOOL)].map(()=>({
    pos:new THREE.Vector3(center.x+(Math.random()-0.5)*6, 0.2+Math.random()*0.8, center.z+(Math.random()-0.5)*6),
    ang:Math.random()*Math.PI*2, spd:.8+Math.random()*1.2, wob:Math.random()*6.28
  }));
  fishSchools.push({mesh,data,ttl:40+Math.random()*50});
}
function updateFish(dt,t){
  const m=new THREE.Matrix4();
  for(let si=fishSchools.length-1;si>=0;si--){
    const s=fishSchools[si];
    s.ttl-=dt; if(s.ttl<=0){ scene.remove(s.mesh); s.mesh.dispose(); fishSchools.splice(si,1); continue; }
    for(let i=0;i<s.data.length;i++){
      const f=s.data[i]; f.ang+=(Math.sin(t*0.5+f.wob)*0.3+0.2)*dt;
      f.pos.x+=Math.cos(f.ang)*f.spd*dt; f.pos.z+=Math.sin(f.ang)*f.spd*dt;
      f.pos.y=0.25+Math.sin(t*2+f.wob)*0.15;
      m.makeRotationY(-f.ang+Math.PI/2); m.setPosition(f.pos); s.mesh.setMatrixAt(i,m);
    }
    s.mesh.instanceMatrix.needsUpdate=true;
  }
}

/* ===== Sharks (fins) + attacks ===== */
function makeFin(){
  const fin=new THREE.Mesh(new THREE.ConeGeometry(0.28,0.7,4), new THREE.MeshStandardMaterial({color:0x222a33,roughness:.95,flatShading:true}));
  fin.position.y=0.05; const g=new THREE.Group(); g.add(fin);
  g.position.set((Math.random()-0.5)*80,0,(Math.random()-0.5)*80);
  g.userData={state:'cruise',dir:new THREE.Vector2(Math.random()-0.5,Math.random()-0.5).normalize(),speed:1+Math.random()*0.6};
  scene.add(g); return g;
}
const fins=[...Array(6)].map(makeFin);
let activeAttack=null;

/* ===== Controls (virtual stick + spear) ===== */
const stick=document.getElementById('stick'), thumb=document.getElementById('thumb'), statusEl=document.getElementById('status');
let stickActive=false, stickCenter={x:0,y:0}, stickVec={x:0,y:0};
stick.addEventListener('pointerdown',e=>{stickActive=true; stick.setPointerCapture(e.pointerId); const r=stick.getBoundingClientRect(); stickCenter={x:r.left+r.width/2,y:r.top+r.height/2};});
stick.addEventListener('pointerup',()=>{stickActive=false; stickVec.x=stickVec.y=0; thumb.style.transform='translate(-50%,-50%)';});
stick.addEventListener('pointermove',e=>{
  if(!stickActive) return;
  const dx=e.clientX-stickCenter.x, dy=e.clientY-stickCenter.y, max=46;
  const len=Math.hypot(dx,dy), k=len>max?max/len:1, sx=dx*k, sy=dy*k;
  thumb.style.transform=`translate(${sx}px,${sy}px) translate(-50%,-50%)`;
  stickVec.x=sx/max; stickVec.y=sy/max;
},{passive:true});
window.addEventListener('wheel',e=>{ targetDist=THREE.MathUtils.clamp(targetDist+(e.deltaY>0?0.7:-0.7),4.2,12.0); });

let pinch=0;
canvas.addEventListener('touchstart',e=>{ if(e.touches.length===2){ const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY; pinch=Math.hypot(dx,dy);}},{passive:false});
canvas.addEventListener('touchmove',e=>{ if(e.touches.length===2){ e.preventDefault(); const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY; const d=Math.hypot(dx,dy); targetDist=THREE.MathUtils.clamp(targetDist-(d-pinch)*0.01,4.2,12.0); pinch=d;}},{passive:false});

const spearBtn=document.getElementById('spear'); let spearCooldown=0;
spearBtn.addEventListener('pointerdown',()=>{
  if(spearCooldown>0) return;
  spearCooldown=0.6; spearBtn.classList.add('cool');
  if(activeAttack && activeAttack.phase==='charge'){
    const fin=activeAttack.fin, dist=fin.position.distanceTo(boat.position);
    if(dist<3.2){ statusEl.textContent='Shark repelled!'; activeAttack=null; splash(fin.position); } else { statusEl.textContent='Missed'; }
  } else { statusEl.textContent='Throw... (no target)'; }
});

/* Splash rings */
const splashRings=[];
function splash(pos){
  const geo=new THREE.RingGeometry(0.01,0.02,16);
  const mat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.9});
  const ring=new THREE.Mesh(geo,mat); ring.rotation.x=-Math.PI/2; ring.position.set(pos.x,0.02,pos.z);
  ring.userData.t=0; scene.add(ring); splashRings.push(ring);
}
function updateSplashes(dt){
  for(let i=splashRings.length-1;i>=0;i--){
    const r=splashRings[i]; r.userData.t+=dt; const k=r.userData.t;
    r.scale.setScalar(1+2*k); r.material.opacity=0.9*(1-k); if(k>=1){ scene.remove(r); r.geometry.dispose(); r.material.dispose(); splashRings.splice(i,1); }
  }
}

/* Birds + clouds */
function updateBirds(t){
  const m=new THREE.Matrix4();
  for(let i=0;i<BIRDS;i++){
    const b=birdData[i], ang=b.a+t*b.spd;
    const x=boat.position.x+Math.cos(ang)*b.r, z=boat.position.z+Math.sin(ang)*b.r, y=b.h+Math.sin(t*2+b.wob)*0.6;
    const yaw=Math.atan2(Math.sin(ang),Math.cos(ang))+Math.PI/2, roll=Math.sin(t*4+i)*0.25;
    m.makeRotationFromEuler(new THREE.Euler(0,yaw,roll)); m.setPosition(x,y,z); gulls.setMatrixAt(i,m);
  }
  gulls.instanceMatrix.needsUpdate=true;
}
function cloud(){ const g=new THREE.IcosahedronGeometry(1.0,0);
  const m=new THREE.MeshStandardMaterial({color:0xffffff,roughness:.95,flatShading:true});
  const cluster=new THREE.Group(); const n=5+(Math.random()*4|0);
  for(let i=0;i<n;i++){ const p=new THREE.Mesh(g,m); p.scale.setScalar(0.9+Math.random()*0.8);
    p.position.set((Math.random()-.5)*3.5,(Math.random()-.5)*1.0,(Math.random()-.5)*1.5); cluster.add(p); }
  const w=new THREE.Group(); w.add(cluster); w.position.set((Math.random()-.5)*500,34+Math.random()*28,(Math.random()-.5)*500);
  w.scale.setScalar(4+Math.random()*4); w.userData.vel=.18+Math.random()*.35; scene.add(w); return w;
}
const clouds=Array.from({length:10},cloud);
function updateClouds(dt){ for(const c of clouds){ c.position.x+=dt*c.userData.vel; if(c.position.x>boat.position.x+260) c.position.x=boat.position.x-260; } }

/* Fins + encounter logic */
function updateFins(dt){
  for(const f of fins){
    if(activeAttack && f===activeAttack.fin) continue;
    const u=f.userData;
    f.position.x+=u.dir.x*u.speed*dt; f.position.z+=u.dir.y*u.speed*dt;
    const R=100; if(f.position.x>boat.position.x+R) f.position.x=boat.position.x-R;
    if(f.position.x<boat.position.x-R) f.position.x=boat.position.x+R;
    if(f.position.z>boat.position.z+R) f.position.z=boat.position.z-R;
    if(f.position.z<boat.position.z-R) f.position.z=boat.position.z+R;
    f.rotation.y=Math.atan2(u.dir.x,u.dir.y);
  }
}
let travelDist=0, nextCheckDist=12;
function checkEncounter(){
  if(travelDist<nextCheckDist) return;
  travelDist=0; nextCheckDist=10+Math.random()*8;
  if(activeAttack) return;
  const p=0.05+Math.random()*0.13; // 5–18%
  if(Math.random()<p){
    let closest=null, dmin=1e9;
    for(const f of fins){ const d=f.position.distanceTo(boat.position); if(d<dmin){ dmin=d; closest=f; } }
    if(closest){ activeAttack={fin:closest,phase:'approach',t:0}; statusEl.textContent='Shark spotted!'; }
  } else {
    const ang=Math.random()*Math.PI*2, r=6+Math.random()*10;
    spawnSchool(new THREE.Vector3(boat.position.x+Math.cos(ang)*r,0,boat.position.z+Math.sin(ang)*r));
    statusEl.textContent='School of fish!';
  }
}
function updateAttack(dt){
  if(!activeAttack) return;
  const fin=activeAttack.fin;
  if(activeAttack.phase==='approach'){
    activeAttack.t+=dt;
    const rel=new THREE.Vector2(boat.position.x-fin.position.x, boat.position.z-fin.position.z);
    const dir=rel.normalize(); fin.position.x+=dir.x*1.8*dt; fin.position.z+=dir.y*1.8*dt;
    fin.rotation.y=Math.atan2(dir.x,dir.y);
    if(activeAttack.t>2.2 || fin.position.distanceTo(boat.position)<6){ activeAttack.phase='charge'; activeAttack.t=0; statusEl.textContent='Shark charging! SPEAR!'; }
  } else {
    activeAttack.t+=dt;
    const rel=new THREE.Vector2(boat.position.x-fin.position.x, boat.position.z-fin.position.z).normalize();
    fin.position.x+=rel.x*4.5*dt; fin.position.z+=rel.y*4.5*dt; fin.rotation.y=Math.atan2(rel.x,rel.y);
    const d=fin.position.distanceTo(boat.position);
    if(d<1.4){ statusEl.textContent='Boat hit! (cosmetic)'; splash(boat.position); activeAttack=null; }
    if(activeAttack && activeAttack.t>3.2){ activeAttack=null; statusEl.textContent='Shark broke off.'; }
  }
}

/* Boat motion on waves */
function updateBoat(dt){
  const v=new THREE.Vector2(stickVec.x,-stickVec.y);
  const targetSpeed=THREE.MathUtils.clamp(v.length(),0,1)*4.0;
  const targetHeading=v.length()>0.05?Math.atan2(v.x,v.y):boat.userData.heading;
  boat.userData.speed=THREE.MathUtils.damp(boat.userData.speed,targetSpeed,4.0,dt);
  boat.userData.heading=THREE.MathUtils.damp(boat.userData.heading,targetHeading,6.0,dt);

  const dx=Math.sin(boat.userData.heading)*boat.userData.speed*dt;
  const dz=Math.cos(boat.userData.heading)*boat.userData.speed*dt;
  if(targetSpeed>0.01){ boat.position.x+=dx; boat.position.z+=dz; travelDist+=Math.hypot(dx,dz); }

  // float on CPU waves
  const y=sampleHeight(boat.position.x,boat.position.z,tNow);
  boat.position.y=0.25+y;
  boat.rotation.y=boat.userData.heading;
}
function followCam(dt){
  const look=new THREE.Vector3(boat.position.x,boat.position.y+0.6,boat.position.z);
  camYaw=THREE.MathUtils.damp(camYaw,boat.userData.heading,2.5,dt);
  camera.position.x=look.x+Math.sin(camYaw)*camDist;
  camera.position.z=look.z+Math.cos(camYaw)*camDist;
  camera.position.y=THREE.MathUtils.damp(camera.position.y,look.y+2.0,2.5,dt);
  camera.lookAt(look);
  camDist=THREE.MathUtils.damp(camDist,targetDist,4.0,dt);
}

/* Main loop */
let tPrev=performance.now()*0.001;
function animate(){
  const t=performance.now()*0.001; const dt=Math.min(0.05,t-tPrev); tPrev=t;

  updateOcean(dt); // ★ visible faceted waves
  updateBoat(dt); followCam(dt);
  updateBirds(t); updateClouds(dt); updateFins(dt); updateAttack(dt);
  updateFish(dt,t); updateSplashes(dt); checkEncounter();

  renderer.render(scene,camera);

  if(spearCooldown>0){ spearCooldown=Math.max(0,spearCooldown-dt); if(spearCooldown===0) spearBtn.classList.remove('cool'); }
  requestAnimationFrame(animate);
}
animate();

/* Initial fish */
for(let i=0;i<3;i++){ const a=Math.random()*Math.PI*2, r=6+Math.random()*10; spawnSchool(new THREE.Vector3(Math.cos(a)*r,0,Math.sin(a)*r)); }

/* Resize */
addEventListener('resize',()=>{ renderer.setPixelRatio(Math.min(devicePixelRatio||1,DPR_CAP)); renderer.setSize(innerWidth,innerHeight,false); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); },{passive:true});

/* Wave variety (sizes + directions) every few seconds */
setInterval(()=>{
  waves[0].amp=THREE.MathUtils.lerp(0.7,1.5,Math.random());
  waves[1].amp=THREE.MathUtils.lerp(0.35,0.9,Math.random());
  waves[2].amp=THREE.MathUtils.lerp(0.2,0.6,Math.random());
  for(const w of waves){
    const ang=Math.random()*Math.PI*2; w.dir.set(Math.cos(ang),Math.sin(ang)).normalize();
    w.freq=THREE.MathUtils.lerp(0.010,0.020,Math.random());
    w.speed=THREE.MathUtils.lerp(0.12,0.6,Math.random());
  }
},7000);

/* ----- UI vars ----- */
let targetDist=7.2;
const stickVec={x:0,y:0};
const stick=document.getElementById('stick'), thumb=document.getElementById('thumb');
let stickActive=false, stickCenter={x:0,y:0};
stick.addEventListener('pointerdown',e=>{stickActive=true; stick.setPointerCapture(e.pointerId); const r=stick.getBoundingClientRect(); stickCenter={x:r.left+r.width/2,y:r.top+r.height/2};});
stick.addEventListener('pointerup',()=>{stickActive=false; stickVec.x=stickVec.y=0; thumb.style.transform='translate(-50%,-50%)';});
stick.addEventListener('pointermove',e=>{
  if(!stickActive) return;
  const dx=e.clientX-stickCenter.x, dy=e.clientY-stickCenter.y, max=46;
  const len=Math.hypot(dx,dy), k=len>max?max/len:1, sx=dx*k, sy=dy*k;
  thumb.style.transform=`translate(${sx}px,${sy}px) translate(-50%,-50%)`;
  stickVec.x=sx/max; stickVec.y=sy/max;
},{passive:true});
</script>
</body>
</html>