<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Low‑Poly Ocean — Fixed ESM Build</title>
<style>
  html,body{margin:0;height:100%;background:#6db5ff}
  canvas{position:fixed;inset:0}
  .hud{position:fixed;left:12px;bottom:12px;color:#fff;font:600 12px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .pill{background:rgba(0,0,0,.35);padding:8px 10px;border-radius:10px;backdrop-filter:blur(6px)}
  #stick{position:fixed;left:14px;bottom:70px;width:120px;height:120px;border-radius:50%;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.2);touch-action:none}
  #thumb{position:absolute;left:50%;top:50%;width:54px;height:54px;margin:-27px 0 0 -27px;border-radius:50%;background:rgba(255,255,255,.25);border:1px solid rgba(255,255,255,.5)}
  #spear{position:fixed;right:14px;bottom:26px;width:120px;height:120px;border-radius:50%;background:rgba(220,40,40,.88);color:#fff;font:800 18px system-ui,-apple-system;display:flex;align-items:center;justify-content:center;box-shadow:0 6px 14px rgba(0,0,0,.35);touch-action:none;border:none}
  #spear.cool{background:rgba(110,110,110,.6)}
  .tag{position:fixed;right:14px;top:14px;color:#fff;background:rgba(0,0,0,.35);padding:6px 10px;border-radius:8px;font:600 12px system-ui}
</style>
</head>
<body>
<canvas id="app"></canvas>
<div class="hud pill">Drag circle to steer • Pinch/scroll to zoom</div>
<div id="stick"><div id="thumb"></div></div>
<button id="spear" aria-label="Throw Spear">SPEAR</button>
<div class="tag pill" id="status">Calm seas</div>

<script type="module">
/* 100% ES Modules (no deprecated build/three.min.js), single declarations (no redeclare errors) */
import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
import { Sky } from 'https://unpkg.com/three@0.165.0/examples/jsm/objects/Sky.js';

/* ----- Renderer / Scene ----- */
const DPR_CAP = 1.5;
const canvas = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ canvas, antialias:false, powerPreference:'high-performance' });
renderer.setPixelRatio(Math.min(devicePixelRatio || 1, DPR_CAP));
renderer.setSize(innerWidth, innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x7fbfff, 0.0007);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2000);
camera.position.set(0, 2.3, 7);

/* Lights + Sky */
scene.add(new THREE.HemisphereLight(0xBBD8FF, 0x1d3557, 0.9));
const sunLight = new THREE.DirectionalLight(0xffffff, 0.75);
scene.add(sunLight);

const sky = new Sky(); sky.scale.setScalar(10000); scene.add(sky);
sky.material.uniforms.turbidity.value = 8;
sky.material.uniforms.rayleigh.value = 1.2;
sky.material.uniforms.mieCoefficient.value = 0.005;
sky.material.uniforms.mieDirectionalG.value = 0.8;
const sun = new THREE.Vector3();
(function setSun(elev=14+Math.random()*8, az=150+Math.random()*40){
  const phi = THREE.MathUtils.degToRad(90-elev), th = THREE.MathUtils.degToRad(az);
  sun.setFromSphericalCoords(1, phi, th);
  sky.material.uniforms.sunPosition.value.copy(sun);
  sunLight.position.copy(sun).multiplyScalar(1500);
})();

/* ----- Low‑poly Ocean (CPU waves + flat shading) ----- */
const O_SIZE = 1200, SEG = 120;         // mobile‑friendly
const oceanGeo = new THREE.PlaneGeometry(O_SIZE, O_SIZE, SEG, SEG);
oceanGeo.rotateX(-Math.PI/2);
const oceanMat = new THREE.MeshStandardMaterial({ color:0x2b76a8, roughness:0.92, metalness:0, flatShading:true });
const ocean = new THREE.Mesh(oceanGeo, oceanMat); ocean.frustumCulled = false; scene.add(ocean);

const pos = oceanGeo.attributes.position;
const baseXZ = new Float32Array(pos.count*2);
for (let i=0;i<pos.count;i++){ baseXZ[i*2] = pos.getX(i); baseXZ[i*2+1] = pos.getZ(i); }

const waves = [
  { amp:1.10, freq:0.012, dir:new THREE.Vector2( 1.0,  0.3).normalize(), speed:0.50 },
  { amp:0.55, freq:0.017, dir:new THREE.Vector2(-0.6,  1.0).normalize(), speed:0.22 },
  { amp:0.30, freq:0.014, dir:new THREE.Vector2( 0.2, -1.0).normalize(), speed:0.12 },
];
let tWave = 0, normalsTick = 0;

function waveHeight(x, z, t){
  let y=0;
  for (const w of waves){
    y += Math.sin((x*w.dir.x + z*w.dir.y)*w.freq + t*w.speed) * w.amp;
  }
  return y;
}
function updateOcean(dt){
  tWave += dt;
  for (let i=0;i<pos.count;i++){
    const x = baseXZ[i*2], z = baseXZ[i*2+1];
    pos.setY(i, waveHeight(x, z, tWave));
  }
  pos.needsUpdate = true;

  normalsTick = (normalsTick+1) % 2;                   // recompute half rate for perf
  if (normalsTick === 0){ oceanGeo.computeVertexNormals(); oceanGeo.normalizeNormals(); }
}

/* ----- Boat (controllable) ----- */
function makeBoat(){
  const hull = new THREE.Mesh(new THREE.ConeGeometry(0.7,2.4,6), new THREE.MeshStandardMaterial({color:0x8a4928,roughness:0.9,flatShading:true}));
  hull.rotation.x = Math.PI/2; hull.position.y = 0.25;
  const deck = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.2,1.0), new THREE.MeshStandardMaterial({color:0xcaa572,roughness:0.9,flatShading:true}));
  deck.position.set(0,0.55,0.1);
  const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.05,1.2,6), new THREE.MeshStandardMaterial({color:0xddd7c9,roughness:0.8,flatShading:true}));
  mast.position.set(0,1.1,-0.1);
  const sail = new THREE.Mesh(new THREE.ConeGeometry(0.02,0.9,3), new THREE.MeshStandardMaterial({color:0xffffff,roughness:0.95,flatShading:true}));
  sail.position.set(0.15,0.7,-0.1); sail.rotation.z = Math.PI/2;
  const g = new THREE.Group(); g.add(hull,deck,mast,sail);
  g.userData = { heading:0, speed:0 };
  return g;
}
const boat = makeBoat(); scene.add(boat);

/* Camera follow */
let camYaw = 0;
let camDist = 7.2;
let targetDist = 7.2;

/* ----- Seagulls (instanced) ----- */
const birdGeom = new THREE.ConeGeometry(0.12,0.5,3); birdGeom.rotateX(Math.PI/2);
const birdMat  = new THREE.MeshStandardMaterial({color:0xffffff, roughness:.6, flatShading:true});
const BIRDS = 22;
const gulls = new THREE.InstancedMesh(birdGeom, birdMat, BIRDS);
gulls.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
scene.add(gulls);
const birdData = Array.from({length:BIRDS}, () => ({
  a:Math.random()*Math.PI*2, r:18+Math.random()*70, h:7+Math.random()*10, spd:.12+Math.random()*.22, wob:Math.random()*Math.PI*2
}));
function updateBirds(t){
  const m=new THREE.Matrix4();
  for(let i=0;i<BIRDS;i++){
    const b=birdData[i], ang=b.a+t*b.spd;
    const x=boat.position.x+Math.cos(ang)*b.r, z=boat.position.z+Math.sin(ang)*b.r, y=b.h+Math.sin(t*2+b.wob)*0.6;
    const yaw=Math.atan2(Math.sin(ang),Math.cos(ang))+Math.PI/2, roll=Math.sin(t*4+i)*0.25;
    m.makeRotationFromEuler(new THREE.Euler(0,yaw,roll)); m.setPosition(x,y,z); gulls.setMatrixAt(i,m);
  }
  gulls.instanceMatrix.needsUpdate=true;
}

/* ----- Clouds ----- */
function makeCloud(){
  const g = new THREE.IcosahedronGeometry(1,0);
  const m = new THREE.MeshStandardMaterial({color:0xffffff,roughness:.95,flatShading:true});
  const cluster = new THREE.Group();
  const n = 5 + (Math.random()*4|0);
  for (let i=0;i<n;i++){
    const puff = new THREE.Mesh(g,m);
    puff.scale.setScalar(0.9+Math.random()*0.8);
    puff.position.set((Math.random()-.5)*3.5,(Math.random()-.5)*1.0,(Math.random()-.5)*1.5);
    cluster.add(puff);
  }
  const w = new THREE.Group(); w.add(cluster);
  w.position.set((Math.random()-.5)*500, 34+Math.random()*28, (Math.random()-.5)*500);
  w.scale.setScalar(4+Math.random()*4);
  w.userData.vel = .18 + Math.random()*.35;
  scene.add(w);
  return w;
}
const clouds = Array.from({length:10}, makeCloud);
function updateClouds(dt){
  for (const c of clouds){
    c.position.x += dt*c.userData.vel;
    if (c.position.x > boat.position.x+260) c.position.x = boat.position.x-260;
  }
}

/* ----- Fish schools (instanced) ----- */
const fishGeom = new THREE.CapsuleGeometry(0.06,0.18,1,5);
const fishMat  = new THREE.MeshStandardMaterial({color:0x66c2ff, roughness:.7, flatShading:true});
const FISH_PER_SCHOOL = 70, MAX_SCHOOLS = 5;
const fishSchools = [];
function spawnSchool(center){
  const mesh = new THREE.InstancedMesh(fishGeom, fishMat, FISH_PER_SCHOOL);
  mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage); scene.add(mesh);
  const data = Array.from({length:FISH_PER_SCHOOL}, () => ({
    pos:new THREE.Vector3(center.x+(Math.random()-0.5)*6, 0.2+Math.random()*0.8, center.z+(Math.random()-0.5)*6),
    ang:Math.random()*Math.PI*2, spd:.8+Math.random()*1.2, wob:Math.random()*6.28
  }));
  fishSchools.push({mesh,data,ttl:40+Math.random()*50});
}
function updateFish(dt,t){
  const m=new THREE.Matrix4();
  for (let si=fishSchools.length-1; si>=0; si--){
    const s = fishSchools[si];
    s.ttl -= dt;
    if (s.ttl <= 0){ scene.remove(s.mesh); fishSchools.splice(si,1); continue; }
    for (let i=0;i<s.data.length;i++){
      const f=s.data[i];
      f.ang += (Math.sin(t*0.5+f.wob)*0.3+0.2)*dt;
      f.pos.x += Math.cos(f.ang)*f.spd*dt;
      f.pos.z += Math.sin(f.ang)*f.spd*dt;
      f.pos.y  = 0.25 + Math.sin(t*2+f.wob)*0.15;
      m.makeRotationY(-f.ang+Math.PI/2); m.setPosition(f.pos); s.mesh.setMatrixAt(i,m);
    }
    s.mesh.instanceMatrix.needsUpdate = true;
  }
  while (fishSchools.length > MAX_SCHOOLS){ const s=fishSchools.shift(); scene.remove(s.mesh); }
}

/* ----- Sharks (fins cruising + random attack 5–18%) ----- */
function makeFin(){
  const fin = new THREE.Mesh(new THREE.ConeGeometry(0.28,0.7,4), new THREE.MeshStandardMaterial({color:0x222a33,roughness:.95,flatShading:true}));
  fin.position.y = 0.05;
  const g = new THREE.Group(); g.add(fin);
  g.position.set((Math.random()-0.5)*80,0,(Math.random()-0.5)*80);
  g.userData = { dir:new THREE.Vector2(Math.random()-0.5,Math.random()-0.5).normalize(), speed:1+Math.random()*0.6 };
  scene.add(g); return g;
}
const fins = Array.from({length:6}, makeFin);
let activeAttack = null;

/* ----- Dolphins (occasional jumpers) ----- */
function makeDolphin(){
  const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.18,0.7,2,6), new THREE.MeshStandardMaterial({color:0x9ec6df,roughness:0.6,flatShading:true}));
  const snout = new THREE.Mesh(new THREE.CylinderGeometry(0.05,0.07,0.25,5), body.material); snout.rotation.z = Math.PI/2; snout.position.set(0.45,0,0);
  const fin   = new THREE.Mesh(new THREE.ConeGeometry(0.08,0.2,4), body.material); fin.rotation.x = Math.PI; fin.position.set(0,0.1,0);
  const d = new THREE.Group(); d.add(body,snout,fin); d.visible=false; scene.add(d);
  d.userData = { active:false,t:0,dur:2,start:new THREE.Vector3(),end:new THREE.Vector3() };
  return d;
}
const dolphins = Array.from({length:4}, makeDolphin);
let dolphinCooldown = 2.0;
function trySpawnDolphin(dt){
  dolphinCooldown -= dt; if (dolphinCooldown > 0) return;
  dolphinCooldown = 2 + Math.random()*3;
  const d = dolphins.find(k=>!k.userData.active); if(!d) return;
  const r = 10 + Math.random()*25, a = Math.random()*Math.PI*2;
  d.userData.start.set(boat.position.x+Math.cos(a)*r, 0, boat.position.z+Math.sin(a)*r);
  d.userData.end.set(boat.position.x+Math.cos(a+0.6)*r, 0, boat.position.z+Math.sin(a+0.6)*r);
  d.userData.t=0; d.userData.dur=1.6+Math.random()*1.4; d.userData.active=true; d.visible=true;
}
function updateDolphins(dt){
  for (const d of dolphins){
    if (!d.userData.active) continue;
    d.userData.t += dt;
    const k = d.userData.t / d.userData.dur;
    if (k >= 1){ d.userData.active=false; d.visible=false; continue; }
    const p = new THREE.Vector3().lerpVectors(d.userData.start, d.userData.end, k);
    p.y = Math.sin(Math.PI*k) * (1.5 + d.userData.start.distanceTo(d.userData.end)*0.06);
    d.position.copy(p);
    const dir = new THREE.Vector3().subVectors(d.userData.end, d.userData.start).normalize();
    d.quaternion.setFromUnitVectors(new THREE.Vector3(1,0,0), new THREE.Vector3(dir.x,0.15,dir.z).normalize());
  }
}

/* ----- Virtual stick + spear (UI) ----- */
const statusEl = document.getElementById('status');
const spearBtn = document.getElementById('spear');
let spearCooldown = 0;

const stick = document.getElementById('stick');
const thumb = document.getElementById('thumb');
let stickActive = false;
let stickCenter = {x:0,y:0};
const stickVec = {x:0,y:0};

stick.addEventListener('pointerdown', (e)=>{
  stickActive = true; stick.setPointerCapture(e.pointerId);
  const r = stick.getBoundingClientRect();
  stickCenter = { x:r.left+r.width/2, y:r.top+r.height/2 };
});
stick.addEventListener('pointerup', ()=>{
  stickActive = false; stickVec.x = stickVec.y = 0; thumb.style.transform = 'translate(-50%,-50%)';
});
stick.addEventListener('pointermove', (e)=>{
  if(!stickActive) return;
  const dx = e.clientX - stickCenter.x, dy = e.clientY - stickCenter.y;
  const max = 46, len = Math.hypot(dx,dy), k = len>max ? max/len : 1;
  const sx = dx*k, sy = dy*k;
  thumb.style.transform = `translate(${sx}px,${sy}px) translate(-50%,-50%)`;
  stickVec.x = sx/max; stickVec.y = sy/max;
}, {passive:true});

addEventListener('wheel', e=>{
  targetDist = THREE.MathUtils.clamp(targetDist + (e.deltaY>0 ? 0.7 : -0.7), 4.2, 12.0);
}, {passive:true});

/* Pinch zoom */
let pinch = 0;
canvas.addEventListener('touchstart', e=>{
  if(e.touches.length===2){
    const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY;
    pinch=Math.hypot(dx,dy);
  }
}, {passive:false});
canvas.addEventListener('touchmove', e=>{
  if(e.touches.length===2){
    e.preventDefault();
    const dx=e.touches[0].clientX-e.touches[1].clientX, dy=e.touches[0].clientY-e.touches[1].clientY;
    const d=Math.hypot(dx,dy);
    targetDist = THREE.MathUtils.clamp(targetDist - (d-pinch)*0.01, 4.2, 12.0);
    pinch=d;
  }
}, {passive:false});

/* Spear throw */
spearBtn.addEventListener('pointerdown', ()=>{
  if (spearCooldown>0) return;
  spearCooldown = 0.6; spearBtn.classList.add('cool');
  if (activeAttack && activeAttack.phase==='charge'){
    const fin = activeAttack.fin, dist = fin.position.distanceTo(boat.position);
    if (dist < 3.2){ statusEl.textContent='Shark repelled!'; activeAttack=null; splash(fin.position); }
    else { statusEl.textContent='Missed'; }
  } else { statusEl.textContent='Throw... (no target)'; }
});

/* Splash ring */
const splashRings = [];
function splash(pos){
  const geo=new THREE.RingGeometry(0.01,0.02,16);
  const mat=new THREE.MeshBasicMaterial({color:0xffffff,transparent:true,opacity:0.9});
  const ring=new THREE.Mesh(geo,mat); ring.rotation.x=-Math.PI/2; ring.position.set(pos.x,0.02,pos.z);
  ring.userData.t=0; scene.add(ring); splashRings.push(ring);
}
function updateSplashes(dt){
  for (let i=splashRings.length-1;i>=0;i--){
    const r=splashRings[i]; r.userData.t+=dt; const k=r.userData.t;
    r.scale.setScalar(1+2*k); r.material.opacity=0.9*(1-k);
    if (k>=1){ scene.remove(r); r.geometry.dispose(); r.material.dispose(); splashRings.splice(i,1); }
  }
}

/* ----- Movement / Encounters ----- */
let travelDist = 0;
let nextCheckDist = 12;

function updateBoat(dt){
  const v = new THREE.Vector2(stickVec.x, -stickVec.y);
  const targetSpeed   = Math.min(1, v.length()) * 4.0;
  const targetHeading = v.length()>0.05 ? Math.atan2(v.x, v.y) : boat.userData.heading;
  boat.userData.speed   = THREE.MathUtils.damp(boat.userData.speed,   targetSpeed,   4.0, dt);
  boat.userData.heading = THREE.MathUtils.damp(boat.userData.heading, targetHeading, 6.0, dt);

  const dx = Math.sin(boat.userData.heading) * boat.userData.speed * dt;
  const dz = Math.cos(boat.userData.heading) * boat.userData.speed * dt;
  if (targetSpeed>0.01){ boat.position.x += dx; boat.position.z += dz; travelDist += Math.hypot(dx,dz); }

  boat.position.y = 0.25 + waveHeight(boat.position.x, boat.position.z, tWave);
  boat.rotation.y = boat.userData.heading;
}
function followCam(dt){
  const look = new THREE.Vector3(boat.position.x, boat.position.y+0.6, boat.position.z);
  camYaw = THREE.MathUtils.damp(camYaw, boat.userData.heading, 2.5, dt);
  camera.position.x = look.x + Math.sin(camYaw)*camDist;
  camera.position.z = look.z + Math.cos(camYaw)*camDist;
  camera.position.y = THREE.MathUtils.damp(camera.position.y, look.y+2.0, 2.5, dt);
  camera.lookAt(look);
  camDist = THREE.MathUtils.damp(camDist, targetDist, 4.0, dt);
}

function updateFins(dt){
  for (const f of fins){
    if (activeAttack && f===activeAttack.fin) continue;
    const u=f.userData;
    f.position.x += u.dir.x*u.speed*dt;
    f.position.z += u.dir.y*u.speed*dt;
    const R=100;
    if (f.position.x>boat.position.x+R) f.position.x=boat.position.x-R;
    if (f.position.x<boat.position.x-R) f.position.x=boat.position.x+R;
    if (f.position.z>boat.position.z+R) f.position.z=boat.position.z-R;
    if (f.position.z<boat.position.z-R) f.position.z=boat.position.z+R;
    f.rotation.y = Math.atan2(u.dir.x,u.dir.y);
  }
}

function checkEncounter(){
  if (travelDist < nextCheckDist) return;
  travelDist = 0; nextCheckDist = 10 + Math.random()*8;
  if (activeAttack) return;

  const p = 0.05 + Math.random()*0.13; // 5–18%
  if (Math.random() < p){
    let closest=null, dmin=1e9;
    for (const f of fins){ const d=f.position.distanceTo(boat.position); if(d<dmin){ dmin=d; closest=f; } }
    if (closest){ activeAttack = { fin:closest, phase:'approach', t:0 }; statusEl.textContent='Shark spotted!'; }
  } else {
    const ang=Math.random()*Math.PI*2, r=6+Math.random()*10;
    spawnSchool(new THREE.Vector3(boat.position.x+Math.cos(ang)*r, 0, boat.position.z+Math.sin(ang)*r));
    statusEl.textContent='School of fish!';
  }
}

function updateAttack(dt){
  if (!activeAttack) return;
  const fin = activeAttack.fin;
  if (activeAttack.phase==='approach'){
    activeAttack.t += dt;
    const rel = new THREE.Vector2(boat.position.x-fin.position.x, boat.position.z-fin.position.z);
    const dir = rel.normalize();
    fin.position.x += dir.x*1.8*dt; fin.position.z += dir.y*1.8*dt;
    fin.rotation.y = Math.atan2(dir.x,dir.y);
    if (activeAttack.t>2.2 || fin.position.distanceTo(boat.position)<6){
      activeAttack.phase='charge'; activeAttack.t=0; statusEl.textContent='Shark charging! SPEAR!';
    }
  } else {
    activeAttack.t += dt;
    const rel = new THREE.Vector2(boat.position.x-fin.position.x, boat.position.z-fin.position.z).normalize();
    fin.position.x += rel.x*4.5*dt; fin.position.z += rel.y*4.5*dt;
    fin.rotation.y = Math.atan2(rel.x,rel.y);
    const d = fin.position.distanceTo(boat.position);
    if (d < 1.4){ statusEl.textContent='Boat hit! (cosmetic)'; splash(boat.position); activeAttack=null; }
    if (activeAttack && activeAttack.t>3.2){ activeAttack=null; statusEl.textContent='Shark broke off.'; }
  }
}

/* ----- Main loop ----- */
let tPrev = performance.now()*0.001;
function animate(){
  const tNow=performance.now()*0.001, dt=Math.min(0.05, tNow-tPrev); tPrev=tNow;

  updateOcean(dt);
  updateBoat(dt); followCam(dt);
  updateBirds(tNow); updateClouds(dt);
  updateFins(dt); checkEncounter(); updateAttack(dt);
  trySpawnDolphin(dt); updateDolphins(dt);
  updateFish(dt,tNow); updateSplashes(dt);

  renderer.render(scene,camera);

  if (spearCooldown>0){ spearCooldown=Math.max(0, spearCooldown-dt); if(spearCooldown===0) spearBtn.classList.remove('cool'); }
  requestAnimationFrame(animate);
}
animate();

/* Seeds */
for(let i=0;i<3;i++){ const a=Math.random()*Math.PI*2, r=6+Math.random()*10; spawnSchool(new THREE.Vector3(Math.cos(a)*r,0,Math.sin(a)*r)); }

/* Resize */
addEventListener('resize', ()=>{
  renderer.setPixelRatio(Math.min(devicePixelRatio||1, DPR_CAP));
  renderer.setSize(innerWidth, innerHeight, false);
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
}, {passive:true});

/* Wave variety every few seconds */
setInterval(()=>{
  waves[0].amp = THREE.MathUtils.lerp(0.7,1.5,Math.random());
  waves[1].amp = THREE.MathUtils.lerp(0.35,0.9,Math.random());
  waves[2].amp = THREE.MathUtils.lerp(0.2,0.6,Math.random());
  for (const w of waves){
    const ang=Math.random()*Math.PI*2;
    w.dir.set(Math.cos(ang), Math.sin(ang)).normalize();
    w.freq  = THREE.MathUtils.lerp(0.010,0.020,Math.random());
    w.speed = THREE.MathUtils.lerp(0.12,0.6,Math.random());
  }
}, 7000);
</script>
</body>
</html>
