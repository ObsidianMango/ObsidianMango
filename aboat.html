<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"
/>
<title>Low‑Poly Ocean — Surface Safari</title>
<style>
  html, body { margin:0; height:100%; background:#4aa0ff; }
  #app { position:fixed; inset:0; touch-action:none; }
  .hud {
    position: fixed; left: 12px; bottom: 12px; color:#fff; font: 600 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
    background: rgba(0,0,0,.25); padding: 8px 10px; border-radius: 10px; backdrop-filter: blur(6px);
    user-select:none; -webkit-user-select:none;
  }
</style>
</head>
<body>
<canvas id="app"></canvas>
<div class="hud">Tap-drag: look • Pinch: zoom</div>

<script type="module">
/* ===== latest, optimized, open source stack =====
   - three.js for rendering
   - Sky from three examples for gorgeous sky
   - Custom lightweight shaders for low‑poly ocean with rolling waves
   - All assets are procedural (no heavy models), tuned for iPhone
*/
import * as THREE from 'https://unpkg.com/three@0.165.0/build/three.module.js';
import { Sky } from 'https://unpkg.com/three@0.165.0/examples/jsm/objects/Sky.js';

const DPR_CAP = 1.5; // keep iPhone cool & smooth
const canvas = document.getElementById('app');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: false, powerPreference: 'high-performance' });
renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, DPR_CAP));
renderer.setSize(window.innerWidth, window.innerHeight, false);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;

const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x7fbfff, 0.0006);

// Camera floats at the surface with gentle bob
const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 2.2, 6);

// Hemispheric light for soft daylight + subtle sun
scene.add(new THREE.HemisphereLight(0xBBD8FF, 0x1d3557, 0.85));
const sunLight = new THREE.DirectionalLight(0xffffff, 0.65);
sunLight.position.set(1, 1, 0.5).normalize();
scene.add(sunLight);

// ===== Sky (beautiful, dynamic) =====
const sky = new Sky();
sky.scale.setScalar(10000);
scene.add(sky);
const skyUniforms = sky.material.uniforms;
skyUniforms["turbidity"].value = 8;
skyUniforms["rayleigh"].value = 1.2;
skyUniforms["mieCoefficient"].value = 0.005;
skyUniforms["mieDirectionalG"].value = 0.8;
const sun = new THREE.Vector3();
function setSun(elevation=12, azimuth=160){
  const phi = THREE.MathUtils.degToRad(90 - elevation);
  const theta = THREE.MathUtils.degToRad(azimuth);
  sun.setFromSphericalCoords(1, phi, theta);
  sky.material.uniforms["sunPosition"].value.copy(sun);
  sunLight.position.copy(sun).multiplyScalar(1500);
}
setSun(10 + Math.random()*8, 140 + Math.random()*40);

// ===== Low‑poly ocean (GPU waves, facet shading) =====
const OCEAN_SIZE = 1200;
const OCEAN_SEG = 160; // careful: too high hurts iPhone; this is a good sweet spot

// Vertex/fragment shader with 3 Gerstner-like waves + hard normals for "low-poly" look
const oceanVert = /* glsl */`
  precision highp float;
  varying vec3 vPos;
  varying vec3 vNormal;
  varying float vShade;
  uniform float uTime;
  uniform float uChop;
  uniform vec2  uFreqA;
  uniform vec2  uFreqB;
  uniform vec2  uFreqC;
  uniform float uAmpA;
  uniform float uAmpB;
  uniform float uAmpC;
  uniform float uSpeedA;
  uniform float uSpeedB;
  uniform float uSpeedC;

  // rotate a 2D vector 90° (for tangent)
  vec2 perp(vec2 v){ return vec2(-v.y, v.x); }

  void main() {
    vec3 p = position;

    // world-space directions for three wave systems
    vec2 dirA = normalize(uFreqA);
    vec2 dirB = normalize(uFreqB);
    vec2 dirC = normalize(uFreqC);

    float t = uTime;

    // Phase for each system
    float wa = dot(dirA, p.xz) * uFreqA.x + t * uSpeedA;
    float wb = dot(dirB, p.xz) * uFreqB.x + t * uSpeedB;
    float wc = dot(dirC, p.xz) * uFreqC.x + t * uSpeedC;

    // Height from summed sines (slightly gerstner-ish with chop)
    float ya = sin(wa) * uAmpA;
    float yb = sin(wb) * uAmpB;
    float yc = sin(wc) * uAmpC;
    p.y += ya + yb + yc;

    // Approximate normals from partial derivatives (for simple lighting)
    vec3 dx = vec3(1.0, uAmpA * uFreqA.x * cos(wa) * uChop
                        + uAmpB * uFreqB.x * cos(wb) * uChop
                        + uAmpC * uFreqC.x * cos(wc) * uChop, 0.0);
    vec3 dz = vec3(0.0, uAmpA * uFreqA.y * cos(wa) * uChop
                        + uAmpB * uFreqB.y * cos(wb) * uChop
                        + uAmpC * uFreqC.y * cos(wc) * uChop, 1.0);

    vec3 n = normalize(cross(dz, dx));

    // Low‑poly "faceted" look: snap the normal a bit
    n = normalize(floor(n * 12.0) / 12.0);

    vNormal = n;
    vPos = p;

    // simple rim lighting factor for sparkle
    vec3 viewDir = normalize(cameraPosition - p);
    vShade = pow(1.0 - max(dot(n, viewDir), 0.0), 1.5);

    gl_Position = projectionMatrix * modelViewMatrix * vec4(p, 1.0);
  }
`;

const oceanFrag = /* glsl */`
  precision highp float;
  varying vec3 vPos;
  varying vec3 vNormal;
  varying float vShade;

  void main() {
    // base water color gradient (shallower near viewer)
    float depth = clamp((vPos.y + 4.0) * 0.08, 0.0, 1.0);
    vec3 deep = vec3(0.02, 0.24, 0.45);
    vec3 shallow = vec3(0.10, 0.52, 0.75);
    vec3 base = mix(deep, shallow, depth);

    // lambert with a single white sun-like light coming from above/right
    vec3 L = normalize(vec3(0.8, 1.0, 0.4));
    float NdotL = max(dot(vNormal, L), 0.0);

    // subtle spec-ish sparkle
    float sparkle = pow(NdotL, 18.0) * 0.35 + vShade * 0.15;

    // fog (match scene fog-ish)
    float fog = clamp(length(vPos) / 900.0, 0.0, 1.0);
    vec3 fogColor = vec3(0.50, 0.72, 0.95);

    vec3 color = mix(base * (0.35 + 0.85*NdotL) + sparkle, fogColor, fog);
    gl_FragColor = vec4(color, 1.0);
  }
`;

const oceanMat = new THREE.ShaderMaterial({
  vertexShader: oceanVert,
  fragmentShader: oceanFrag,
  uniforms: {
    uTime:   { value: 0 },
    uChop:   { value: 0.45 },
    // frequencies encode both direction and wavelength (x carries magnitude)
    uFreqA:  { value: new THREE.Vector2(0.018,  0.006) },
    uFreqB:  { value: new THREE.Vector2(-0.008, 0.014) },
    uFreqC:  { value: new THREE.Vector2(0.011, -0.012) },
    uAmpA:   { value: 0.85 },
    uAmpB:   { value: 0.45 },
    uAmpC:   { value: 0.25 },
    uSpeedA: { value: 0.45 },
    uSpeedB: { value: 0.20 },
    uSpeedC: { value: 0.10 },
  },
  fog: false,
  lights: false,
  flatShading: true
});

const oceanGeo = new THREE.PlaneGeometry(OCEAN_SIZE, OCEAN_SIZE, OCEAN_SEG, OCEAN_SEG);
oceanGeo.rotateX(-Math.PI / 2);
const ocean = new THREE.Mesh(oceanGeo, oceanMat);
ocean.frustumCulled = false;
scene.add(ocean);

// ===== Low‑poly clouds (few spheres) =====
function makeCloud(){
  const g = new THREE.IcosahedronGeometry(1.0, 0);
  const m = new THREE.MeshStandardMaterial({ color: 0xFFFFFF, roughness: 0.95, metalness: 0.0, flatShading: true });
  const cluster = new THREE.Group();
  const n = 5 + (Math.random()*4|0);
  for (let i=0;i<n;i++){
    const p = new THREE.Mesh(g, m);
    p.scale.setScalar(0.9 + Math.random()*0.8);
    p.position.set((Math.random()-0.5)*3.5, (Math.random()-0.5)*1.0, (Math.random()-0.5)*1.5);
    cluster.add(p);
  }
  const wrapper = new THREE.Group();
  wrapper.add(cluster);
  wrapper.position.set((Math.random()-0.5)*400, 30 + Math.random()*25, (Math.random()-0.5)*400);
  wrapper.scale.setScalar(4.0 + Math.random()*4.0);
  wrapper.userData.vel = 0.2 + Math.random()*0.35;
  scene.add(wrapper);
  return wrapper;
}
const clouds = Array.from({length: 10}, makeCloud);

// ===== Seagulls (instanced simple low‑poly birds) =====
const birdGeom = new THREE.ConeGeometry(0.12, 0.5, 3); // tiny triangle "body"
birdGeom.rotateX(Math.PI/2);
birdGeom.computeVertexNormals();
const birdMat = new THREE.MeshStandardMaterial({ color: 0xffffff, flatShading: true, roughness: 0.6, metalness: 0.0 });
const BIRDS = 24;
const gulls = new THREE.InstancedMesh(birdGeom, birdMat, BIRDS);
gulls.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
scene.add(gulls);
const birdData = new Array(BIRDS).fill(0).map(() => ({
  a: Math.random()*Math.PI*2,
  r: 15 + Math.random()*60,
  h: 6 + Math.random()*10,
  speed: 0.15 + Math.random()*0.25,
  wob: Math.random()*Math.PI*2
}));

// ===== Fins & Dolphins (lightweight procedural groups) =====
function makeSharkFin(){
  const fin = new THREE.Mesh(
    new THREE.ConeGeometry(0.25, 0.6, 4),
    new THREE.MeshStandardMaterial({ color: 0x222a33, flatShading:true, roughness: 0.9 })
  );
  fin.position.y = 0.05; // just above waterline
  const grp = new THREE.Group();
  grp.add(fin);
  grp.position.set((Math.random()-0.5)*60, 0, (Math.random()-0.5)*60);
  grp.userData = {
    t: Math.random()*Math.PI*2,
    speed: 0.2 + Math.random()*0.25,
    dir: new THREE.Vector2(Math.random()-0.5, Math.random()-0.5).normalize(),
  };
  scene.add(grp);
  return grp;
}
const fins = Array.from({length: 6}, makeSharkFin);

function makeDolphin(){
  const body = new THREE.Mesh(
    new THREE.CapsuleGeometry(0.18, 0.7, 2, 6),
    new THREE.MeshStandardMaterial({ color: 0x9ec6df, flatShading:true, roughness: 0.6 })
  );
  const snout = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05, 0.07, 0.25, 5),
    body.material
  );
  snout.rotation.z = Math.PI/2;
  snout.position.set(0.45, 0, 0);
  const fin = new THREE.Mesh(new THREE.ConeGeometry(0.08, 0.2, 4), body.material);
  fin.rotation.x = Math.PI;
  fin.position.set(0, 0.1, 0);
  const d = new THREE.Group();
  d.add(body, snout, fin);
  d.visible = false; // spawned occasionally
  scene.add(d);
  d.userData = { active: false, t: 0, dur: 2 + Math.random()*1.5, start: new THREE.Vector3(), end: new THREE.Vector3() };
  return d;
}
const dolphins = Array.from({length: 5}, makeDolphin);

// ===== Camera control (touch-friendly, auto-reset) =====
let yaw = 0, pitch = -0.07, targetYaw = 0, targetPitch = -0.07, dist = 6.5, targetDist = 6.5;
let isPointerDown = false, lastX = 0, lastY = 0;
let pinchDist = 0;
canvas.addEventListener('pointerdown', (e) => { isPointerDown = true; lastX = e.clientX; lastY = e.clientY; canvas.setPointerCapture(e.pointerId); });
canvas.addEventListener('pointerup',   (e) => { isPointerDown = false; });
canvas.addEventListener('pointermove', (e) => {
  if (!isPointerDown) return;
  const dx = e.clientX - lastX, dy = e.clientY - lastY;
  lastX = e.clientX; lastY = e.clientY;
  targetYaw += dx * -0.0025;
  targetPitch = THREE.MathUtils.clamp(targetPitch + dy * -0.0020, -0.45, 0.25);
});
canvas.addEventListener('wheel', (e) => {
  targetDist = THREE.MathUtils.clamp(targetDist + (e.deltaY > 0 ? 0.7 : -0.7), 4.2, 12.0);
});

// pinch for iPhone
canvas.addEventListener('touchstart', (e) => {
  if (e.touches.length === 2) {
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    pinchDist = Math.hypot(dx, dy);
  }
}, {passive:false});

canvas.addEventListener('touchmove', (e) => {
  if (e.touches.length === 2) {
    e.preventDefault();
    const dx = e.touches[0].clientX - e.touches[1].clientX;
    const dy = e.touches[0].clientY - e.touches[1].clientY;
    const d = Math.hypot(dx, dy);
    const delta = d - pinchDist;
    pinchDist = d;
    targetDist = THREE.MathUtils.clamp(targetDist - delta * 0.01, 4.2, 12.0);
  }
}, {passive:false});

// ===== Spawners for surface life =====
let tPrev = performance.now() * 0.001;
let dolphinCooldown = 2.0;
function trySpawnDolphin(dt){
  dolphinCooldown -= dt;
  if (dolphinCooldown > 0) return;
  dolphinCooldown = 2.0 + Math.random()*3.0;

  const d = dolphins.find(d => !d.userData.active);
  if (!d) return;

  // arc across the water — pop out then splash back in
  const radius = 10 + Math.random()*25;
  const ang = Math.random()*Math.PI*2;
  const start = new THREE.Vector3(Math.cos(ang)*radius, 0, Math.sin(ang)*radius);
  const end   = new THREE.Vector3(Math.cos(ang+0.6)*radius, 0, Math.sin(ang+0.6)*radius);
  d.userData.start.copy(start);
  d.userData.end.copy(end);
  d.userData.dur = 1.6 + Math.random()*1.4;
  d.userData.t = 0;
  d.userData.active = true;
  d.visible = true;
}

function moveFins(dt){
  for (const f of fins){
    const u = f.userData;
    u.t += dt * u.speed;
    f.position.x += u.dir.x * dt * 2.0;
    f.position.z += u.dir.y * dt * 2.0;

    // wrap around
    const R = 80;
    if (f.position.x >  R) f.position.x = -R;
    if (f.position.x < -R) f.position.x =  R;
    if (f.position.z >  R) f.position.z = -R;
    if (f.position.z < -R) f.position.z =  R;

    // slight yaw wiggle
    f.rotation.y = Math.sin(u.t*2.5)*0.3 + Math.atan2(u.dir.x, u.dir.y);
  }
}

function moveDolphins(dt){
  for (const d of dolphins){
    if (!d.userData.active) continue;
    d.userData.t += dt;
    const k = d.userData.t / d.userData.dur;
    if (k >= 1.0){
      d.userData.active = false;
      d.visible = false;
      continue;
    }
    // smooth arc
    const s = d.userData.start, e = d.userData.end;
    const p = new THREE.Vector3().lerpVectors(s, e, k);
    const h = Math.sin(Math.PI * k) * (1.5 + e.distanceTo(s) * 0.06);
    p.y = h;
    d.position.copy(p);

    // face velocity direction
    const dir = new THREE.Vector3().subVectors(e, s).normalize();
    d.quaternion.setFromUnitVectors(new THREE.Vector3(1,0,0), new THREE.Vector3(dir.x, 0.15, dir.z).normalize());
  }
}

function moveBirds(t){
  const m = new THREE.Matrix4();
  for (let i=0;i<BIRDS;i++){
    const b = birdData[i];
    const ang = b.a + t * b.speed;
    const x = Math.cos(ang) * b.r;
    const z = Math.sin(ang) * b.r;
    const y = b.h + Math.sin(t*2.0 + b.wob) * 0.6;
    const yaw = Math.atan2(Math.sin(ang), Math.cos(ang)) + Math.PI/2;
    const roll = Math.sin(t*4.0 + i)*0.25;
    m.makeRotationFromEuler(new THREE.Euler(0, yaw, roll));
    m.setPosition(x, y, z);
    gulls.setMatrixAt(i, m);
  }
  gulls.instanceMatrix.needsUpdate = true;
}

function moveClouds(dt){
  for (const c of clouds){
    c.position.x += dt * c.userData.vel;
    if (c.position.x > 250) c.position.x = -250;
  }
}

// ===== Render loop =====
function resize(){
  const w = window.innerWidth, h = window.innerHeight;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, DPR_CAP));
  renderer.setSize(w, h, false);
  camera.aspect = w / h;
  camera.updateProjectionMatrix();
}
window.addEventListener('resize', resize, { passive:true });

function animate(){
  const tNow = performance.now() * 0.001;
  const dt = Math.min(0.05, tNow - tPrev);
  tPrev = tNow;

  // Ocean time
  oceanMat.uniforms.uTime.value = tNow;

  // Camera gentle auto reset
  yaw   = THREE.MathUtils.damp(yaw,   targetYaw,   2.5, dt);
  pitch = THREE.MathUtils.damp(pitch, targetPitch, 2.5, dt);
  dist  = THREE.MathUtils.damp(dist,  targetDist,  4.0, dt);

  const bob = Math.sin(tNow*0.8) * 0.12 + Math.sin(tNow*0.37)*0.06;
  const lookAt = new THREE.Vector3(0, 0.4 + bob*0.5, 0);
  const cx = Math.sin(yaw) * Math.cos(pitch) * dist;
  const cy = Math.sin(pitch) * dist * 0.6 + 1.9 + bob;
  const cz = Math.cos(yaw) * Math.cos(pitch) * dist;
  camera.position.set(cx, cy, cz);
  camera.lookAt(lookAt);

  moveBirds(tNow);
  moveClouds(dt);
  moveFins(dt);
  moveDolphins(dt);
  trySpawnDolphin(dt);

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
resize();
animate();

// OPTIONAL: vary wave set every so often for "different size waves rolling through"
setInterval(() => {
  const u = oceanMat.uniforms;
  u.uAmpA.value = THREE.MathUtils.lerp(0.6, 1.2, Math.random());
  u.uAmpB.value = THREE.MathUtils.lerp(0.3, 0.7, Math.random());
  u.uAmpC.value = THREE.MathUtils.lerp(0.15,0.45, Math.random());
  u.uSpeedA.value = THREE.MathUtils.lerp(0.25, 0.6, Math.random());
  u.uSpeedB.value = THREE.MathUtils.lerp(0.10, 0.35, Math.random());
  u.uSpeedC.value = THREE.MathUtils.lerp(0.06, 0.18, Math.random());
  // tweak directions
  const angle = Math.random() * Math.PI*2;
  const angle2= angle + (Math.random()*0.8 - 0.4);
  const angle3= angle + (Math.random()*1.6 - 0.8);
  const lenA = THREE.MathUtils.lerp(0.012, 0.022, Math.random());
  const lenB = THREE.MathUtils.lerp(0.008, 0.016, Math.random());
  const lenC = THREE.MathUtils.lerp(0.010, 0.018, Math.random());
  oceanMat.uniforms.uFreqA.value.set(Math.cos(angle)*lenA, Math.sin(angle)*lenA);
  oceanMat.uniforms.uFreqB.value.set(Math.cos(angle2)*lenB, Math.sin(angle2)*lenB);
  oceanMat.uniforms.uFreqC.value.set(Math.cos(angle3)*lenC, Math.sin(angle3)*lenC);
}, 7000);
</script>
</body>
</html>