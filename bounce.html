<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>â€¢ BounCeBall</title>
    <style>
        /* existing styles */

        /* Debug display styles */
        #debugInfo {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #f39c12;
            font-size: 1rem;
            padding: 10px;
            border-radius: 5px;
            display: none; /* Hidden by default */
        }
    </style>
</head>
<body>
    <!-- existing HTML structure -->

    <!-- Debug Information Display -->
    <div id="debugInfo">Acceleration: X=0 Y=0 Z=0</div>

    <script>
        let selectedOption = 0;
        let bounceCount = 0;
        let goal = 32;
        let gameStarted = false;
        let gameEnded = false;
        let startTime = null;
        let velocity = -10; // Initial upward velocity
        const gravity = 0.6; // Gravity strength
        const bounceFactor = -0.7; // Bounce damping
        let isBouncing = false;
        const debugMode = true; // Enable or disable debug mode
        const menuOptions = document.querySelectorAll(".menuOption");
        const titleScreen = document.getElementById("titleScreen");
        const gameScreen = document.getElementById("gameScreen");
        const counter = document.getElementById("counter");
        const ball = document.getElementById("ball");
        const playAgainButton = document.getElementById("playAgain");
        const debugInfo = document.getElementById("debugInfo");

        // Show debug info if debug mode is enabled
        if (debugMode) {
            debugInfo.style.display = "block";
        }

        // Initialize Menu
        function updateMenu() {
            menuOptions.forEach((option, index) => {
                option.classList.remove("selected");
                if (index === selectedOption) {
                    option.classList.add("selected");
                    option.innerHTML = `<span id="arrow">> </span>${option.textContent.split("> ").pop()}`;
                    goal = parseInt(option.getAttribute("data-goal"));
                } else {
                    option.innerHTML = option.textContent.split("> ").pop();
                }
            });
        }
        updateMenu();

        // Handle Menu Clicks
        menuOptions.forEach((option, index) => {
            option.addEventListener("click", () => {
                selectedOption = index;
                updateMenu();
                startGame();
            });
        });

        // Handle Keyboard Navigation and Mouse Clicks for Menu and Game
        document.addEventListener("keydown", (e) => {
            if (!gameStarted) {
                if (e.key === "ArrowDown") {
                    selectedOption = (selectedOption + 1) % menuOptions.length;
                    updateMenu();
                } else if (e.key === "ArrowUp") {
                    selectedOption = (selectedOption - 1 + menuOptions.length) % menuOptions.length;
                    updateMenu();
                } else if (e.key === "Enter" || e.key === " ") {
                    startGame();
                }
            } else if (!gameEnded) {
                bounceBall();
            }
        });

        document.body.addEventListener("click", () => {
            if (gameStarted && !gameEnded) {
                bounceBall();
            }
        });

        // Device Motion Detection for Shaking with Debug Info
        window.addEventListener("devicemotion", (event) => {
            const acceleration = event.acceleration;
            const shakeThreshold = 15;

            // Update debug info
            if (debugMode) {
                debugInfo.textContent = `Acceleration: X=${acceleration.x.toFixed(2)} Y=${acceleration.y.toFixed(2)} Z=${acceleration.z.toFixed(2)}`;
            }

            // Check if acceleration exceeds threshold
            if (Math.abs(acceleration.x) > shakeThreshold || Math.abs(acceleration.y) > shakeThreshold || Math.abs(acceleration.z) > shakeThreshold) {
                bounceBall();
            }
        });

        function startGame() {
            titleScreen.style.display = "none";
            gameScreen.style.display = "flex";
            gameStarted = true;
            gameEnded = false;
            bounceCount = 0;
            counter.textContent = bounceCount;
            startTime = Date.now(); // Start the timer
        }

        function bounceBall() {
            if (gameEnded) return;

            bounceCount++;
            counter.textContent = bounceCount;
            changeBallColor();
            vibrate();

            // Restart bounce physics from the current position
            velocity = -15; // set bounce velocity each hit
            if (!isBouncing) {
                isBouncing = true;
                startBouncePhysics();
            }

            if (bounceCount >= goal) {
                endGame();
            }
        }

        function changeBallColor() {
            const colors = ['#FF5733', '#33FF57', '#3357FF', '#FF33A5'];
            ball.style.background = `radial-gradient(circle at 30% 30%, ${colors[Math.floor(Math.random() * colors.length)]}, #d00000)`;
        }

        function vibrate() {
            if (navigator.vibrate) {
                navigator.vibrate(100); // Vibrate for 100 milliseconds
            }
        }

        function startBouncePhysics() {
            function bounceLoop() {
                if (!gameEnded) {
                    velocity += gravity;
                    let position = parseInt(ball.style.top || window.innerHeight / 2);

                    // Update position based on velocity
                    position += velocity;

                    // Check for bottom boundary
                    if (position >= window.innerHeight - 80) {
                        position = window.innerHeight - 80;
                        velocity *= bounceFactor;
                        vibrate(); // Vibrate on hitting the bottom edge
                    }
                    // Check for top boundary
                    if (position <= 0) {
                        position = 0;
                        velocity *= bounceFactor;
                        vibrate(); // Vibrate on hitting the top edge
                    }

                    ball.style.top = `${position}px`;

                    if (Math.abs(velocity) < 1 && position >= window.innerHeight - 80) {
                        isBouncing = false;
                    } else {
                        requestAnimationFrame(bounceLoop);
                    }
                }
            }
            bounceLoop();
        }

        function endGame() {
            gameEnded = true;
            const elapsedTime = ((Date.now() - startTime) / 1000).toFixed(2);
            document.getElementById("finalTime").textContent = `Goal Reached! Final Time: ${elapsedTime} seconds`;
            document.getElementById("finalTime").style.display = "block";
            document.getElementById("playAgain").style.display = "block";
        }

        function resetGame() {
            gameScreen.style.display = "none";
            titleScreen.style.display = "flex";
            gameStarted = false;
            gameEnded = false;
            bounceCount = 0;
            isBouncing = false;
            document.getElementById("playAgain").style.display = "none";
            document.getElementById("finalTime").style.display = "none";
            document.getElementById("finalTime").textContent = "";
            ball.style.top = "50%";
            updateMenu();
        }

        // Play Again Button
        playAgainButton.addEventListener("click", resetGame);
    </script>
</body>
</html>
