<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Element Sandbox</title>
    <style>
        body {
            margin: 0;
            background-color: #111;
            overflow: hidden;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        canvas {
            image-rendering: pixelated; /* Vital for the retro look */
            width: 100%;
            flex-grow: 1;
            background: #000;
        }
        #controls {
            height: 80px;
            background: #222;
            display: flex;
            overflow-x: auto;
            align-items: center;
            padding: 0 10px;
            gap: 10px;
            border-top: 2px solid #444;
        }
        .btn {
            min-width: 70px;
            height: 50px;
            border: 2px solid #555;
            background: #333;
            color: white;
            border-radius: 8px;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        .btn.active {
            border-color: #fff;
            transform: scale(1.05);
        }
        /* Color indicators for buttons */
        .c-sand { color: #f4a460; }
        .c-water { color: #4facfe; }
        .c-stone { color: #888; }
        .c-fire { color: #ff4500; }
        .c-acid { color: #32cd32; }
        .c-plant { color: #228b22; }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>
    <div id="controls">
        <div class="btn active c-sand" onclick="setBrush(1, this)">SAND</div>
        <div class="btn c-water" onclick="setBrush(2, this)">WATER</div>
        <div class="btn c-stone" onclick="setBrush(3, this)">STONE</div>
        <div class="btn c-fire" onclick="setBrush(4, this)">FIRE</div>
        <div class="btn c-plant" onclick="setBrush(5, this)">PLANT</div>
        <div class="btn c-acid" onclick="setBrush(6, this)">ACID</div>
        <div class="btn" style="color:red" onclick="resetGrid()">CLEAR</div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        // Logic Resolution (Low res for performance & pixel look)
        const COLS = 100;
        const ROWS = 100;
        const CELL_SIZE = 1; // Logic size, rendered via CSS scaling
        
        let grid = [];
        let nextGrid = [];
        let brushType = 1; // Default Sand
        let isDrawing = false;
        let touchX = 0;
        let touchY = 0;

        // Colors
        const PALETTE = [
            '#000000', // 0: Empty
            '#f4a460', // 1: Sand
            '#4facfe', // 2: Water
            '#757575', // 3: Stone
            '#ff4500', // 4: Fire
            '#228b22', // 5: Plant
            '#32cd32'  // 6: Acid
        ];

        function init() {
            // Initialize grid
            for (let i = 0; i < COLS * ROWS; i++) {
                grid[i] = 0;
                nextGrid[i] = 0;
            }
            
            // Set canvas logic size
            canvas.width = COLS;
            canvas.height = ROWS;

            animate();
        }

        function getIdx(x, y) {
            return y * COLS + x;
        }

        function setBrush(type, el) {
            brushType = type;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            if(el) el.classList.add('active');
        }

        function resetGrid() {
            for (let i = 0; i < COLS * ROWS; i++) grid[i] = 0;
        }

        function update() {
            // Copy grid to nextGrid to prevent updating same pixel twice in one frame
            // We clear nextGrid to 0 (or handle movement carefully). 
            // Better approach for simple sand: iterate and move.
            // To avoid "teleporting", we iterate Bottom to Top for falling things.
            
            // Reset nextGrid to current grid (snapshot)
            // But actually, we will modify 'grid' directly but use a direction check to avoid double moves?
            // Standard approach: Iterate bottom-up, left-right (randomized left-right helps)
            
            for (let y = ROWS - 1; y >= 0; y--) {
                // Randomize X direction to prevent bias
                const startX = Math.random() > 0.5 ? 0 : COLS - 1;
                const step = startX === 0 ? 1 : -1;

                for (let i = 0; i < COLS; i++) {
                    const x = startX + (i * step);
                    const idx = getIdx(x, y);
                    const type = grid[idx];

                    if (type === 0) continue; // Skip empty
                    if (type === 3) continue; // Stone doesn't move

                    // 1. SAND BEHAVIOR
                    if (type === 1) {
                        const below = getIdx(x, y + 1);
                        const belowLeft = getIdx(x - 1, y + 1);
                        const belowRight = getIdx(x + 1, y + 1);

                        if (y + 1 < ROWS && grid[below] === 0) {
                            // Fall down
                            grid[below] = 1;
                            grid[idx] = 0;
                        } else if (y + 1 < ROWS && grid[below] === 2) {
                             // Sink in water
                            grid[below] = 1;
                            grid[idx] = 2; // Swap
                        } else if (y + 1 < ROWS && x - 1 >= 0 && grid[belowLeft] === 0) {
                            // Slide left
                            grid[belowLeft] = 1;
                            grid[idx] = 0;
                        } else if (y + 1 < ROWS && x + 1 < COLS && grid[belowRight] === 0) {
                            // Slide right
                            grid[belowRight] = 1;
                            grid[idx] = 0;
                        }
                    }

                    // 2. WATER BEHAVIOR
                    else if (type === 2) {
                        const below = getIdx(x, y + 1);
                        const left = getIdx(x - 1, y);
                        const right = getIdx(x + 1, y);

                        if (y + 1 < ROWS && grid[below] === 0) {
                            // Fall
                            grid[below] = 2;
                            grid[idx] = 0;
                        } else {
                            // Flow sideways (randomly preferred)
                            const dir = Math.random() > 0.5 ? 1 : -1;
                            const side1 = getIdx(x + dir, y);
                            const side2 = getIdx(x - dir, y);

                            if (x + dir >= 0 && x + dir < COLS && grid[side1] === 0) {
                                grid[side1] = 2;
                                grid[idx] = 0;
                            } else if (x - dir >= 0 && x - dir < COLS && grid[side2] === 0) {
                                grid[side2] = 2;
                                grid[idx] = 0;
                            }
                        }
                    }

                    // 4. FIRE BEHAVIOR
                    else if (type === 4) {
                        // Fire moves up and flickers
                        const r = Math.random();
                        if (r < 0.1) {
                            grid[idx] = 0; // Burn out
                            continue;
                        }

                        // Burn neighbors (Plant)
                        const neighbors = [
                            getIdx(x, y-1), getIdx(x, y+1), getIdx(x-1, y), getIdx(x+1, y)
                        ];
                        neighbors.forEach(n => {
                            if (grid[n] === 5) grid[n] = 4; // Plant turns to fire
                        });

                        const above = getIdx(x, y - 1);
                        if (y - 1 >= 0 && grid[above] === 0) {
                            grid[above] = 4;
                            grid[idx] = 0;
                        }
                    }

                    // 5. PLANT BEHAVIOR
                    else if (type === 5) {
                        // Grow if touching water
                         if (Math.random() < 0.02) {
                            const neighbors = [getIdx(x, y-1), getIdx(x, y+1), getIdx(x-1, y), getIdx(x+1, y)];
                            const waterIdx = neighbors.find(n => grid[n] === 2);
                            if (waterIdx) {
                                grid[waterIdx] = 5; // Drink water, grow plant
                            } else {
                                // Slow random growth upwards into empty space
                                const above = getIdx(x, y-1);
                                if (y > 0 && grid[above] === 0 && Math.random() < 0.05) {
                                    grid[above] = 5;
                                }
                            }
                         }
                    }

                    // 6. ACID BEHAVIOR
                    else if (type === 6) {
                        // Falls like water but eats Stone and Plant
                        const below = getIdx(x, y + 1);
                        if (y + 1 < ROWS) {
                            const target = grid[below];
                            if (target === 0) {
                                grid[below] = 6;
                                grid[idx] = 0;
                            } else if (target === 3 || target === 5 || target === 1) { // Eat stone, plant, sand
                                if (Math.random() < 0.3) {
                                    grid[below] = 0; // Destroy target
                                    grid[idx] = 0;   // Destroy acid
                                }
                            }
                        }
                    }
                }
            }
        }

        function draw() {
            // Draw grid to canvas
            const imgData = ctx.getImageData(0, 0, COLS, ROWS);
            const data = imgData.data;

            for (let i = 0; i < grid.length; i++) {
                const type = grid[i];
                if (type === 0) {
                    data[i * 4 + 3] = 0; // Transparent
                } else {
                    const hex = PALETTE[type];
                    // Very simple hex parsing
                    const r = parseInt(hex.substring(1, 3), 16);
                    const g = parseInt(hex.substring(3, 5), 16);
                    const b = parseInt(hex.substring(5, 7), 16);
                    
                    data[i * 4] = r;
                    data[i * 4 + 1] = g;
                    data[i * 4 + 2] = b;
                    data[i * 4 + 3] = 255;
                }
            }
            ctx.putImageData(imgData, 0, 0);
        }

        function animate() {
            // We can run logic multiple times per frame for speed
            update();
            draw();
            requestAnimationFrame(animate);
        }

        // Interaction
        function handleInput(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            
            // Handle multiple touches if needed, or just first one
            const touches = e.touches || [{clientX: e.clientX, clientY: e.clientY}];
            
            for(let i=0; i<touches.length; i++) {
                const cx = touches[i].clientX - rect.left;
                const cy = touches[i].clientY - rect.top;

                // Map screen coords to grid coords
                const scaleX = COLS / rect.width;
                const scaleY = ROWS / rect.height;

                const gx = Math.floor(cx * scaleX);
                const gy = Math.floor(cy * scaleY);

                // Brush size
                const brushSize = 2; 
                for(let by = -brushSize; by <= brushSize; by++) {
                    for(let bx = -brushSize; bx <= brushSize; bx++) {
                        const tx = gx + bx;
                        const ty = gy + by;
                        if(tx >= 0 && tx < COLS && ty >= 0 && ty < ROWS) {
                            if (Math.random() > 0.2) { // Add some noise to brush
                                grid[getIdx(tx, ty)] = brushType;
                            }
                        }
                    }
                }
            }
        }

        canvas.addEventListener('mousedown', e => { isDrawing = true; handleInput(e); });
        canvas.addEventListener('mousemove', e => { if(isDrawing) handleInput(e); });
        canvas.addEventListener('mouseup', () => isDrawing = false);

        canvas.addEventListener('touchstart', e => { isDrawing = true; handleInput(e); }, {passive: false});
        canvas.addEventListener('touchmove', e => { if(isDrawing) handleInput(e); }, {passive: false});
        canvas.addEventListener('touchend', () => isDrawing = false);

        init();
    </script>
</body>
</html>
