<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D Fish Tank with Accessories & Lower Views</title>
  <style>
    body { margin: 0; overflow: hidden; background: #001f3f; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://unpkg.com/three@0.150.1/build/three.min.js"></script>
<script>
  // Scene, Camera, Renderer setup
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(
    75, window.innerWidth / window.innerHeight, 0.1, 1000
  );
  // Lower default view height
  camera.position.set(0, 3, 12);
  camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Lighting
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(5, 10, 7.5);
  scene.add(directionalLight);

  // Create the fish tank: a transparent blue box
  const tankWidth = 20, tankHeight = 15, tankDepth = 30;
  const tankGeometry = new THREE.BoxGeometry(tankWidth, tankHeight, tankDepth);
  const tankMaterial = new THREE.MeshPhysicalMaterial({
    color: 0x0000ff,
    transparent: true,
    opacity: 0.3,
    side: THREE.BackSide,
    roughness: 0,
    metalness: 0
  });
  const tank = new THREE.Mesh(tankGeometry, tankMaterial);
  scene.add(tank);

  // Floor
  const floorGeometry = new THREE.PlaneGeometry(tankWidth, tankDepth);
  const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x228B22 }); // forest green floor
  const floor = new THREE.Mesh(floorGeometry, floorMaterial);
  floor.rotation.x = -Math.PI / 2;
  floor.position.y = -(tankHeight / 2 - 0.1);
  scene.add(floor);

  // Ceiling
  const ceilingGeometry = new THREE.PlaneGeometry(tankWidth, tankDepth);
  const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x87CEEB }); // sky blue ceiling
  const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
  ceiling.rotation.x = Math.PI / 2;
  ceiling.position.y = tankHeight / 2 - 0.1;
  scene.add(ceiling);

  // Floor accessory: a decorative rock (existing rock)
  const rockGeometry1 = new THREE.DodecahedronGeometry(0.8, 0);
  const rockMaterial1 = new THREE.MeshStandardMaterial({ color: 0x808080 });
  const rock1 = new THREE.Mesh(rockGeometry1, rockMaterial1);
  rock1.position.set(-3, -(tankHeight / 2 - 0.8), 2);
  scene.add(rock1);

  // Additional Accessories:

  // Rock cluster
  const rockGeometry2 = new THREE.IcosahedronGeometry(0.5, 0);
  const rockMaterial2 = new THREE.MeshStandardMaterial({ color: 0x696969 });
  for (let i = 0; i < 5; i++) {
    const rock = new THREE.Mesh(rockGeometry2, rockMaterial2);
    rock.position.set(
      (Math.random() - 0.5) * tankWidth * 0.6,
      -(tankHeight / 2 - 0.5),
      (Math.random() - 0.5) * tankDepth * 0.6
    );
    rock.rotation.y = Math.random() * Math.PI;
    scene.add(rock);
  }

  // Seaweed accessory: several green cylinders acting as plants
  for (let i = 0; i < 8; i++) {
    const seaweedGeometry = new THREE.CylinderGeometry(0.1, 0.1, 3, 8);
    const seaweedMaterial = new THREE.MeshStandardMaterial({ color: 0x006400 });
    const seaweed = new THREE.Mesh(seaweedGeometry, seaweedMaterial);
    seaweed.position.set(
      (Math.random() - 0.5) * (tankWidth - 2),
      -(tankHeight / 2 - 1.5),
      (Math.random() - 0.5) * (tankDepth - 2)
    );
    seaweed.rotation.z = (Math.random() - 0.5) * 0.5;
    scene.add(seaweed);
  }

  // A small sunken treasure chest
  const chestBaseGeometry = new THREE.BoxGeometry(1.5, 0.8, 1);
  const chestBaseMaterial = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
  const chestBase = new THREE.Mesh(chestBaseGeometry, chestBaseMaterial);
  chestBase.position.set(3, -(tankHeight / 2 - 0.4), -4);
  scene.add(chestBase);
  // Chest lid
  const chestLidGeometry = new THREE.BoxGeometry(1.5, 0.2, 1);
  const chestLidMaterial = new THREE.MeshStandardMaterial({ color: 0xA0522D });
  const chestLid = new THREE.Mesh(chestLidGeometry, chestLidMaterial);
  chestLid.position.set(3, -(tankHeight / 2 - 0.1), -4);
  chestLid.rotation.x = -Math.PI / 6;
  scene.add(chestLid);

  // Fish class definition with attached body parts (body, tail, eyes)
  class Fish {
    constructor() {
      // Fish body: elongated sphere
      const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 8);
      bodyGeometry.scale(1.5, 1, 1);
      const bodyMaterial = new THREE.MeshStandardMaterial({ color: Math.random() * 0xffffff });
      this.body = new THREE.Mesh(bodyGeometry, bodyMaterial);

      // Realistic tail using quadratic curves
      const tailShape = new THREE.Shape();
      tailShape.moveTo(0, 0);
      tailShape.quadraticCurveTo(-0.8, 0.5, -1.5, 0);
      tailShape.quadraticCurveTo(-0.8, -0.5, 0, 0);
      const extrudeSettings = { depth: 0.1, bevelEnabled: false };
      this.tail = new THREE.Mesh(new THREE.ExtrudeGeometry(tailShape, extrudeSettings), bodyMaterial);
      this.tail.position.set(-1.2, 0, 0);

      // Eyes: two small spheres on the front
      const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
      const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
      const pupilGeometry = new THREE.SphereGeometry(0.04, 8, 8);
      const pupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });

      const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      const leftPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      leftEye.add(leftPupil);
      leftEye.position.set(0.8, 0.2, 0.2);
      leftPupil.position.set(0.05, 0, 0);

      const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
      const rightPupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
      rightEye.add(rightPupil);
      rightEye.position.set(0.8, 0.2, -0.2);
      rightPupil.position.set(0.05, 0, 0);

      // Grouping body parts to ensure they remain attached
      this.fishGroup = new THREE.Group();
      this.fishGroup.add(this.body);
      this.fishGroup.add(this.tail);
      this.fishGroup.add(leftEye);
      this.fishGroup.add(rightEye);

      // Random starting position inside the tank
      this.fishGroup.position.x = Math.random() * (tankWidth - 2) - (tankWidth - 2) / 2;
      this.fishGroup.position.y = Math.random() * (tankHeight - 2) - (tankHeight - 2) / 2;
      this.fishGroup.position.z = Math.random() * (tankDepth - 2) - (tankDepth - 2) / 2;

      // Random velocity for swimming
      this.velocity = new THREE.Vector3(
        (Math.random() - 0.5) * 0.05,
        (Math.random() - 0.5) * 0.05,
        (Math.random() - 0.5) * 0.05
      );

      // Oscillation parameters for natural swimming motion
      this.oscillationSpeed = 0.005 + Math.random() * 0.005;
      this.oscillationAmplitude = 0.5 + Math.random() * 0.5;
      this.timeOffset = Math.random() * Math.PI * 2;
    }

    update() {
      // Update fish position
      this.fishGroup.position.add(this.velocity);
      // Vertical oscillation
      this.fishGroup.position.y += Math.sin(Date.now() * this.oscillationSpeed + this.timeOffset) * 0.01 * this.oscillationAmplitude;
      // Animate tail flapping
      this.tail.rotation.y = Math.sin(Date.now() * this.oscillationSpeed * 50 + this.timeOffset) * 0.5;

      // Bounce off tank walls (inside boundaries)
      if (Math.abs(this.fishGroup.position.x) > (tankWidth / 2 - 1)) this.velocity.x *= -1;
      if (Math.abs(this.fishGroup.position.y) > (tankHeight / 2 - 1)) this.velocity.y *= -1;
      if (Math.abs(this.fishGroup.position.z) > (tankDepth / 2 - 1)) this.velocity.z *= -1;

      // Rotate fish to face movement direction
      const direction = this.velocity.clone().normalize();
      const angle = Math.atan2(direction.z, direction.x);
      this.fishGroup.rotation.y = -angle;
    }
  }

  // Create multiple fish
  const fishArray = [];
  const numFish = 20;
  for (let i = 0; i < numFish; i++) {
    const fish = new Fish();
    fishArray.push(fish);
    scene.add(fish.fishGroup);
  }

  // Responsive resizing
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Camera view presets with lower heights: side1, side2, and top
  const views = [
    { position: new THREE.Vector3(0, 3, 12), lookAt: new THREE.Vector3(0, 0, 0) },   // default lower side view
    { position: new THREE.Vector3(12, 3, 0), lookAt: new THREE.Vector3(0, 0, 0) },   // alternate lower side view
    { position: new THREE.Vector3(0, 10, 0), lookAt: new THREE.Vector3(0, 0, 0) }    // top view (lowered a bit)
  ];
  let currentView = 0;

  // Change camera perspective on click
  window.addEventListener('click', () => {
    currentView = (currentView + 1) % views.length;
    camera.position.copy(views[currentView].position);
    camera.lookAt(views[currentView].lookAt);
  });

  // Animation loop
  function animate() {
    requestAnimationFrame(animate);
    fishArray.forEach(fish => fish.update());
    renderer.render(scene, camera);
  }
  animate();
</script>
</body>
</html>
