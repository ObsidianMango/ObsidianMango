<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes"> <!-- For better iOS experience -->
    <title>Customizable Diamond Ocean Waves</title>
    <style>
        body {
            margin: 0;
            background-color: #000; /* Default background */
            overflow: hidden;
            touch-action: none; /* Prevent default touch behaviors */
            transition: background 0.5s ease; /* Smooth background changes */
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #gear {
            position: fixed;
            top: 10px;
            right: 10px;
            font-size: 30px;
            opacity: 0.5;
            cursor: pointer;
            color: white;
            z-index: 10;
            transition: opacity 0.3s;
        }
        #gear:hover {
            opacity: 1;
        }
        #menu {
            position: fixed;
            top: 50px;
            right: 10px;
            background-color: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 10;
            max-width: 300px;
            overflow-y: auto;
            max-height: 80vh;
            color: black;
            font-family: Arial, sans-serif;
        }
        #menu h3 {
            margin-top: 0;
            color: #333;
        }
        #menu label {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 14px;
        }
        #menu input[type="range"] {
            flex: 1;
            margin-left: 10px;
        }
        #menu span {
            margin-left: 10px;
            min-width: 40px;
            text-align: right;
        }
        #menu select {
            width: 100%;
            padding: 5px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #menu button {
            width: 100%;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        #menu button:hover {
            background-color: #0056b3;
        }
        #menu .color-picker {
            display: flex;
            align-items: center;
            margin: 10px 0;
        }
        #menu .color-picker input[type="color"] {
            margin-left: 10px;
            border: none;
            width: 40px;
            height: 30px;
            cursor: pointer;
        }
        #menu .color-picker label {
            flex: 1;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div id="gear" onclick="toggleMenu()">âš™ï¸</div>
    <div id="menu">
        <h3>Emoji Selector</h3>
        <select id="emojiSelect" onchange="changeEmoji(this.value)">
            <optgroup label="Smileys & Emotion">
                <option value="ğŸ˜€">ğŸ˜€ Grinning Face</option>
                <option value="ğŸ˜">ğŸ˜ Beaming Face with Smiling Eyes</option>
                <option value="ğŸ˜‚">ğŸ˜‚ Face with Tears of Joy</option>
                <option value="ğŸ¤£">ğŸ¤£ Rolling on the Floor Laughing</option>
                <option value="ğŸ˜ƒ">ğŸ˜ƒ Grinning Face with Big Eyes</option>
                <option value="ğŸ˜„">ğŸ˜„ Grinning Face with Smiling Eyes</option>
                <option value="ğŸ˜…">ğŸ˜… Grinning Face with Sweat</option>
                <option value="ğŸ˜†">ğŸ˜† Grinning Squinting Face</option>
                <option value="ğŸ˜‰">ğŸ˜‰ Winking Face</option>
                <option value="ğŸ˜Š">ğŸ˜Š Smiling Face with Smiling Eyes</option>
            </optgroup>
            <optgroup label="People & Body">
                <option value="ğŸ‘‹">ğŸ‘‹ Waving Hand</option>
                <option value="ğŸ¤š">ğŸ¤š Raised Back of Hand</option>
                <option value="ğŸ–ï¸">ğŸ–ï¸ Hand with Fingers Splayed</option>
                <option value="âœ‹">âœ‹ Raised Hand</option>
                <option value="ğŸ––">ğŸ–– Vulcan Salute</option>
                <option value="ğŸ‘Œ">ğŸ‘Œ OK Hand</option>
                <option value="ğŸ¤Œ">ğŸ¤Œ Pinched Fingers</option>
                <option value="ğŸ¤">ğŸ¤ Pinching Hand</option>
                <option value="âœŒï¸">âœŒï¸ Victory Hand</option>
                <option value="ğŸ¤">ğŸ¤ Crossed Fingers</option>
            </optgroup>
            <optgroup label="Animals & Nature">
                <option value="ğŸµ">ğŸµ Monkey Face</option>
                <option value="ğŸ¶">ğŸ¶ Dog Face</option>
                <option value="ğŸ•">ğŸ• Dog</option>
                <option value="ğŸ¦®">ğŸ¦® Guide Dog</option>
                <option value="ğŸ•â€ğŸ¦º">ğŸ•â€ğŸ¦º Service Dog</option>
                <option value="ğŸ©">ğŸ© Poodle</option>
                <option value="ğŸº">ğŸº Wolf</option>
                <option value="ğŸ¦Š">ğŸ¦Š Fox</option>
                <option value="ğŸ¦">ğŸ¦ Raccoon</option>
                <option value="ğŸ±">ğŸ± Cat Face</option>
            </optgroup>
            <optgroup label="Food & Drink">
                <option value="ğŸ‡">ğŸ‡ Grapes</option>
                <option value="ğŸˆ">ğŸˆ Melon</option>
                <option value="ğŸ‰">ğŸ‰ Watermelon</option>
                <option value="ğŸŠ">ğŸŠ Tangerine</option>
                <option value="ğŸ‹">ğŸ‹ Lemon</option>
                <option value="ğŸŒ">ğŸŒ Banana</option>
                <option value="ğŸ">ğŸ Pineapple</option>
                <option value="ğŸ¥­">ğŸ¥­ Mango</option>
                <option value="ğŸ">ğŸ Red Apple</option>
                <option value="ğŸ">ğŸ Green Apple</option>
            </optgroup>
            <optgroup label="Travel & Places">
                <option value="ğŸŒ">ğŸŒ Globe Showing Europe-Africa</option>
                <option value="ğŸŒ">ğŸŒ Globe Showing Americas</option>
                <option value="ğŸŒ">ğŸŒ Globe Showing Asia-Australia</option>
                <option value="ğŸŒ">ğŸŒ Globe with Meridians</option>
                <option value="ğŸ—ºï¸">ğŸ—ºï¸ World Map</option>
                <option value="ğŸ—¾">ğŸ—¾ Map of Japan</option>
                <option value="ğŸ§­">ğŸ§­ Compass</option>
                <option value="ğŸ”ï¸">ğŸ”ï¸ Snow-Capped Mountain</option>
                <option value="â›°ï¸">â›°ï¸ Mountain</option>
                <option value="ğŸŒ‹">ğŸŒ‹ Volcano</option>
            </optgroup>
            <!-- Add more categories if needed, but keeping it reasonable -->
            <optgroup label="Objects">
                <option value="ğŸ’" selected>ğŸ’ Gem Stone (Default)</option>
                <option value="ğŸ“±">ğŸ“± Mobile Phone</option>
                <option value="ğŸ’»">ğŸ’» Laptop</option>
                <option value="ğŸ–¥ï¸">ğŸ–¥ï¸ Desktop Computer</option>
                <option value="ğŸ–¨ï¸">ğŸ–¨ï¸ Printer</option>
                <option value="âŒ¨ï¸">âŒ¨ï¸ Keyboard</option>
                <option value="ğŸ–±ï¸">ğŸ–±ï¸ Computer Mouse</option>
                <option value="ğŸ–²ï¸">ğŸ–²ï¸ Trackball</option>
                <option value="ğŸ•¹ï¸">ğŸ•¹ï¸ Joystick</option>
                <option value="ğŸ—œï¸">ğŸ—œï¸ Clamp</option>
            </optgroup>
        </select>

        <h3>Wave Settings</h3>
        <label>Wave Speed: <input type="range" id="waveSpeedSlider" min="0.01" max="0.2" step="0.01" value="0.05" oninput="updateWaveSpeed(this.value)"><span id="waveSpeedValue">0.05</span></label>
        <label>Wave Frequency: <input type="range" id="waveFrequencySlider" min="0.1" max="1" step="0.01" value="0.3" oninput="updateWaveFrequency(this.value)"><span id="waveFrequencyValue">0.3</span></label>
        <label>Amplitude: <input type="range" id="amplitudeSlider" min="5" max="30" step="1" value="18" oninput="updateAmplitude(this.value)"><span id="amplitudeValue">18</span></label>
        <label>Base Size: <input type="range" id="baseSizeSlider" min="1" max="20" step="1" value="6" oninput="updateBaseSize(this.value)"><span id="baseSizeValue">6</span></label>
        <label>Ripple Speed: <input type="range" id="rippleSpeedSlider" min="0.1" max="2" step="0.1" value="0.6" oninput="updateRippleSpeed(this.value)"><span id="rippleSpeedValue">0.6</span></label>
        <label>Ripple Frequency: <input type="range" id="rippleFrequencySlider" min="0.1" max="2" step="0.1" value="0.6" oninput="updateRippleFrequency(this.value)"><span id="rippleFrequencyValue">0.6</span></label>

        <h3>Background Settings</h3>
        <div class="color-picker">
            <label>Solid Color: <input type="color" id="bgColorPicker" value="#000000" onchange="updateBackgroundColor(this.value)"></label>
        </div>
        <div class="color-picker">
            <label>Gradient Start: <input type="color" id="gradientStart" value="#000000" onchange="updateGradient()"></label>
        </div>
        <div class="color-picker">
            <label>Gradient End: <input type="color" id="gradientEnd" value="#001f3f" onchange="updateGradient()"></label>
        </div>

        <button onclick="resetToDefault()">Back to Default Settings</button>
    </div>
    <script>
        let emojiChar = 'ğŸ’'; // Global emoji variable
        let waveSpeed = isMobile ? 0.05 : 0.07;
        let waveFrequency = 0.3;
        let amplitude = isMobile ? 18 : 20;
        let baseSize = isMobile ? 6 : 4;
        let rippleFrequency = 0.6;
        let rippleSpeed = 0.6;

        // Slider update functions
        function updateWaveSpeed(value) {
            waveSpeed = parseFloat(value);
            document.getElementById('waveSpeedValue').textContent = value;
            draw();
        }
        function updateWaveFrequency(value) {
            waveFrequency = parseFloat(value);
            document.getElementById('waveFrequencyValue').textContent = value;
            draw();
        }
        function updateAmplitude(value) {
            amplitude = parseFloat(value);
            document.getElementById('amplitudeValue').textContent = value;
            draw();
        }
        function updateBaseSize(value) {
            baseSize = parseFloat(value);
            document.getElementById('baseSizeValue').textContent = value;
            draw();
        }
        function updateRippleSpeed(value) {
            rippleSpeed = parseFloat(value);
            document.getElementById('rippleSpeedValue').textContent = value;
            draw();
        }
        function updateRippleFrequency(value) {
            rippleFrequency = parseFloat(value);
            document.getElementById('rippleFrequencyValue').textContent = value;
            draw();
        }

        // Background functions
        function updateBackgroundColor(color) {
            document.body.style.background = color;
            document.getElementById('gradientStart').value = color;
            document.getElementById('gradientEnd').value = color;
        }
        function updateGradient() {
            const start = document.getElementById('gradientStart').value;
            const end = document.getElementById('gradientEnd').value;
            document.body.style.background = `linear-gradient(to bottom, ${start}, ${end})`;
        }

        // Rest of the script remains the same as before
        // (Omit for brevity, but include all previous logic for canvas, ripples, draw, animate, touch handlers, etc.)
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Grid parameters: Further increased cellSize on mobile for smoother performance and less stutter
        const cellSize = isMobile ? 30 : 20; // Larger cells to reduce computations and draws for better responsiveness
        
        // Ripple parameters - adjusted for permanent motion and instant start from touch point
        const ripples = [];
        const rippleDecay = 0; // No decay for permanent motion
        const rippleMaxDuration = Infinity; // Infinite duration to never settle
        const minDragDistance = 2; // Increased to reduce ripple count during fast swipes
        const maxRipples = 50; // Increased limit to allow more persistent ripples without perf issues

        // Track last ripple position for swipe
        let lastGridX = null;
        let lastGridY = null;
        let isSwiping = false;

        // Simplified base wave function for performance (reduced components to minimize stutter)
        function getBaseWaveHeight(x, y, t) {
            let wave1 = Math.sin(waveFrequency * x + t) * Math.cos(0.5 * waveFrequency * y);
            let wave2 = Math.sin(0.8 * waveFrequency * (x + y) - 1.2 * t);
            let wave3 = Math.sin(waveFrequency * 1.2 * x - 1.5 * t); // Horizontal
            let wave4 = Math.sin(waveFrequency * 0.7 * y - 0.9 * t); // Vertical
            let combined = 1.5 * wave1 + 1.5 * wave2 + 1.8 * wave3 + 1.8 * wave4;
            return (combined + 6) / 12; // Adjusted normalization
        }

        // Ripple height with cos for immediate peak at touch point
        function getRippleHeight(gridX, gridY, t) {
            let rippleHeight = 0;
            for (let i = ripples.length - 1; i >= 0; i--) {
                const ripple = ripples[i];
                const age = t - ripple.startTime;
                if (age > rippleMaxDuration) {
                    ripples.splice(i, 1);
                    continue;
                }
                const dx = gridX - ripple.gridX;
                const dy = gridY - ripple.gridY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                const phase = rippleFrequency * dist - rippleSpeed * age;
                const timeAtten = Math.exp(-rippleDecay * age); // No decay, always 1
                const distAtten = Math.exp(-0.02 * dist); // Slower distance decay for broader waves
                const attenuation = timeAtten * distAtten;
                rippleHeight += Math.cos(phase) * attenuation * 1.2; // Adjusted amplification
            }
            if (ripples.length > maxRipples) {
                ripples.shift(); // Remove oldest if too many
            }
            return rippleHeight;
        }

        // Combined height
        function getWaveHeight(gridX, gridY, t) {
            let base = getBaseWaveHeight(gridX, gridY, t);
            let ripple = getRippleHeight(gridX, gridY, t);
            let combined = base + 0.5 * ripple;
            return Math.min(1.4, Math.max(-0.4, combined)); // Wider clamp for more extreme variations
        }

        // Draw function for immediate updates
        function draw() {
            ctx.clearRect(0, 0, window.innerWidth, window.innerHeight);
            
            const cols = Math.floor(window.innerWidth / cellSize);
            const rows = Math.floor(window.innerHeight / cellSize);
            
            for (let y = 0; y < rows; y++) {
                for (let x = 0; x < cols; x++) {
                    const height = getWaveHeight(x, y, time);
                    const normalizedHeight = (height + 0.4) / 1.8; // Adjusted normalization for wider clamp
                    const size = baseSize + amplitude * normalizedHeight;
                    
                    ctx.font = `${size}px sans-serif`;
                    ctx.fillStyle = `rgba(0, 191, 255, ${0.6 + 0.4 * normalizedHeight})`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    const posX = x * cellSize + cellSize / 2;
                    const posY = y * cellSize + cellSize / 2;
                    ctx.fillText(emojiChar, posX, posY);
                }
            }
        }

        // Animate loop
        function animate() {
            time += waveSpeed;
            draw();
            requestAnimationFrame(animate);
        }

        animate();

        // Touch handlers with immediate draw on events for instant responsiveness
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const touchX = touch.clientX - canvas.getBoundingClientRect().left;
            const touchY = touch.clientY - canvas.getBoundingClientRect().top;
            
            const gridX = Math.floor(touchX / cellSize);
            const gridY = Math.floor(touchY / cellSize);
            
            ripples.push({ gridX, gridY, startTime: time });
            draw(); // Immediate draw for instant reaction from touch point
            
            lastGridX = gridX;
            lastGridY = gridY;
            isSwiping = false;
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const touchX = touch.clientX - canvas.getBoundingClientRect().left;
            const touchY = touch.clientY - canvas.getBoundingClientRect().top;
            
            const gridX = Math.floor(touchX / cellSize);
            const gridY = Math.floor(touchY / cellSize);
            
            if (lastGridX !== null && lastGridY !== null) {
                const dx = gridX - lastGridX;
                const dy = gridY - lastGridY;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist >= minDragDistance) {
                    ripples.push({ gridX, gridY, startTime: time });
                    lastGridX = gridX;
                    lastGridY = gridY;
                    isSwiping = true;
                    draw(); // Immediate draw during swipe for smooth feel
                }
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            if (lastGridX !== null && lastGridY !== null && isSwiping) {
                ripples.push({ gridX: lastGridX, gridY: lastGridY, startTime: time });
                draw(); // Immediate draw on lift for instant reaction from touch off
            }
            lastGridX = null;
            lastGridY = null;
            isSwiping = false;
        }, { passive: false });

        // Handle resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(resizeCanvas, 300);
        });
    </script>
</body>
</html>