<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Claw Machine</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    html, body {height: 100%; margin: 0; padding: 0; overflow: hidden; background: #101722; font-family: 'Segoe UI', Arial, sans-serif;}
    #container { width: 100vw; height: 100vh; }
    #ui {
      position: fixed; left: 0; right: 0; bottom: 28px;
      display: flex; justify-content: center; gap: 24px; z-index: 9;
      pointer-events: none; flex-wrap: wrap;
    }
    .btn {
      pointer-events: auto;
      background: rgba(255,224,102,0.90);
      border: none;
      border-radius: 28px;
      padding: 16px 38px;
      font-size: 1.25rem;
      font-weight: bold;
      color: #60460b;
      cursor: pointer;
      box-shadow: 0 4px 30px #ffef9a66, 0 2px 6px #2228;
      transition: transform 0.1s, box-shadow 0.16s;
      user-select: none;
      outline: none;
      position: relative;
    }
    .btn:active { transform: scale(0.96); box-shadow: 0 2px 12px #2226; }
    .btn:hover  { box-shadow: 0 8px 40px #ffe066bb, 0 2px 18px #444a; filter: brightness(1.05);}
    .dpad {
      display: grid;
      grid-template: "a b c" "d e f" "g h i";
      gap: 7px;
      margin-right: 20px;
      pointer-events: auto;
      align-items: center;
      justify-items: center;
    }
    .dpad-btn {
      width: 46px; height: 46px; font-size: 1.25rem; border-radius: 50%;
      padding: 0; min-width: 0; min-height: 0;
      box-shadow: 0 1px 7px #222b, 0 0 0 2px #ffef9a33;
      background: #f4ecd1cc;
      color: #6b6000;
      border: 2px solid #e2c14b;
      font-weight: 600;
      cursor: pointer;
      transition: filter 0.14s;
    }
    .dpad-btn:active, .dpad-btn:focus { filter: brightness(0.92);}
    #showPrizesBtn {
      position:fixed;right:18px;top:24px;z-index:1000;
      padding:13px 32px;font-size:1.15rem;border-radius:16px;
      background: linear-gradient(90deg,#ffe066 60%,#ffd700 100%);
      color:#70550e;border:none;
      box-shadow:0 2px 18px #ffe06680, 0 2px 12px #0003;
      font-weight:700;cursor:pointer;
      letter-spacing:0.03em;
      transition: transform 0.11s, box-shadow 0.16s, filter 0.19s;
    }
    #showPrizesBtn:active { transform:scale(0.96);}
    #showPrizesBtn:hover { box-shadow:0 8px 40px #ffe066bb, 0 2px 20px #444a; }
    #showPrizesBtn.win {
      filter: brightness(1.4) drop-shadow(0 0 25px #ffe066cc);
      animation: prizePulse 0.7s infinite alternate;
    }
    @keyframes prizePulse {
      from { box-shadow:0 2px 28px #ffe06699, 0 2px 12px #ffd900; }
      to   { box-shadow:0 6px 60px #ffe066ff, 0 2px 22px #fff380; }
    }
    #prizeMsg {
      position: fixed; left: 0; right: 0; top: 36px;
      text-align: center; font-size: 2.1rem; color: #fffbe8;
      text-shadow: 0 2px 10px #000a;
      font-weight: 900; letter-spacing: 0.07em;
      opacity: 0; z-index: 99;
      transition: opacity 0.33s, transform 0.22s cubic-bezier(.25,.8,.25,1);
      pointer-events: none;
      transform: translateY(-30px) scale(1.01);
    }
    #prizeMsg.show { opacity: 1; transform: translateY(0) scale(1.09);}
    #prizeMsg span {
      display: inline-block;
      animation: emojiPop 0.42s cubic-bezier(.42,.0,.58,1.4) alternate infinite;
    }
    @keyframes emojiPop { 0% { transform: scale(1);} 50% { transform: scale(1.16);} 100% { transform: scale(1);}}
    #prizeTrophyView {
      display:none;position:fixed;z-index:1200;left:0;top:0;width:100vw;height:100vh;
      background:rgba(26,32,38,0.98);backdrop-filter: blur(8px) brightness(1.14);
      align-items:center;justify-content:center;flex-direction:column;
      transition:opacity 0.19s, transform 0.17s;
      box-shadow: 0 0 0 300vw rgba(17,17,17,0.22) inset;
      animation: showTrophyView 0.25s;
    }
    @keyframes showTrophyView {
      from { opacity:0; transform:scale(1.13);}
      to   { opacity:1; transform:scale(1);}
    }
    #prizeTrophyView button {
      position:absolute;top:18px;right:28px;font-size:2rem;background:none;
      border:none;color:#fff;cursor:pointer;z-index:1220;
      filter:drop-shadow(0 1px 4px #000c);
      transition:filter 0.2s;
    }
    #prizeTrophyView button:hover { filter:brightness(1.6) drop-shadow(0 2px 8px #ffedaa); }
    #winMsg {
      position:fixed;top:24%;left:0;right:0;text-align:center;
      font-size:3.1rem;color:#ffd400;text-shadow:0 4px 32px #000b,0 1px 0 #fff;
      font-weight:900;z-index:1500;pointer-events:none;letter-spacing:0.04em;
      opacity:0;transition:opacity 0.4s;
      text-shadow:0 4px 24px #ffd400,0 0 20px #fff3;
    }
    #winMsg.show {opacity:1; animation: winPop 0.8s;}
    @keyframes winPop {
      0%{transform:scale(0.9);}
      80%{transform:scale(1.16);}
      100%{transform:scale(1);}
    }
    @media (max-width:600px){
      .btn{font-size:1.02rem;padding:10px 13px;}
      .dpad-btn{width:32px;height:32px;font-size:1.09rem;}
      #showPrizesBtn{padding:7px 12px;font-size:1rem;}
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div id="ui">
    <div class="dpad">
      <button class="dpad-btn" id="upBtn"    style="grid-area: b;">&#8593;</button>
      <button class="dpad-btn" id="leftBtn"  style="grid-area: d;">&#8592;</button>
      <button class="dpad-btn" id="rightBtn" style="grid-area: f;">&#8594;</button>
      <button class="dpad-btn" id="downBtn"  style="grid-area: h;">&#8595;</button>
    </div>
    <button class="btn" id="grabBtn">Grab!</button>
  </div>
  <button id="showPrizesBtn">Show Prizes</button>
  <div id="prizeMsg"></div>
  <div id="winMsg"></div>
  <div id="prizeTrophyView"></div>
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
  <script>
  // --- CONFIG ---
  const EMOJIS = [
    "ü¶ñ","üçï","üçî","üå≠","üç©","üçí","üßÄ","üêô","üê∏","ü¶Ñ","üêß","üê≤","ü•í","üçá","ü•ë",
    "ü•®","ü¶Ä","üé≤","üéÆ","üß∏","üéà","üåà","üíé","üå∂Ô∏è","üçâ","üçå","ü§†","ü•≥","üòª","üëæ","üçî","üç©"
  ];
  const BALL_RADIUS = 0.25, CLAW_FINGER_RADIUS = 0.19, BALL_COUNT = 26;
  const CLAW_X_LIMIT = 1.05, CLAW_Z_LIMIT = 0.8, CLAW_Y_HOME = 2.7, CLAW_Y_DROP = 0.58;
  const CLAW_SPEED = 0.048, CLAW_VERT_SPEED = 0.039, CLAW_Z_SPEED = 0.045, CLAW_GRAB_DURATION = 350;
  const FINGER_COUNT = 3;
  const FINGER_OPEN_LENGTH = 0.35, FINGER_CLOSED_LENGTH = 0.14;
  const PRIZE_X = 1.04, PRIZE_Z = 0.79;
  const TUBE_RADIUS = 0.33, TUBE_HEIGHT = 1.14, TUBE_THICK = 0.06, TUBE_Y = TUBE_HEIGHT/2-0.02;
  const PRIZES_TO_WIN = 7;

  // --- THREE.js setup ---
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x1a2228);
  const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.05, 100);
  camera.position.set(0, 3.9, 6.1); camera.lookAt(0,1.6,0);
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  document.getElementById('container').appendChild(renderer.domElement);
  scene.add(new THREE.AmbientLight(0xffffff, 0.95));
  let dLight = new THREE.DirectionalLight(0xfffbbe, 0.8);
  dLight.position.set(0,6,3); scene.add(dLight);

  // --- Physics setup ---
  const world = new CANNON.World();
  world.gravity.set(0,-9.8,0);
  world.broadphase = new CANNON.NaiveBroadphase();
  world.solver.iterations = 13;
  const floor = new THREE.Mesh(new THREE.BoxGeometry(2.7,0.13,2.4), new THREE.MeshPhongMaterial({color:0x426077}));
  floor.position.y = -0.06; scene.add(floor);
  const floorBody = new CANNON.Body({mass:0});
  floorBody.addShape(new CANNON.Box(new CANNON.Vec3(1.35,0.07,1.2)));
  floorBody.position.set(0,0,0); world.addBody(floorBody);
  function makeWall(x,y,z,sx,sy,sz) {
    let mesh = new THREE.Mesh(new THREE.BoxGeometry(sx,sy,sz), new THREE.MeshPhongMaterial({color:0x688bad,transparent:true,opacity:0.34}));
    mesh.position.set(x,y,z); scene.add(mesh);
    let body = new CANNON.Body({mass:0});
    body.addShape(new CANNON.Box(new CANNON.Vec3(sx/2,sy/2,sz/2)));
    body.position.set(x,y,z); world.addBody(body);
  }
  makeWall(-1.31,1.23,0, 0.07,2.5,2.4);
  makeWall( 1.31,1.23,0, 0.07,2.5,2.4);
  makeWall(0,1.23,-1.13, 2.6,2.5,0.07);
  makeWall(0,1.05,1.13, 2.6,2.18,0.07);

  // --- Round Glass Tube as Physical Chute ---
  const tubeGeometry = new THREE.CylinderGeometry(TUBE_RADIUS, TUBE_RADIUS, TUBE_HEIGHT, 46, 1, true);
  const tubeMaterial = new THREE.MeshPhongMaterial({color:0x91bbfa, transparent:true, opacity:0.24, side:THREE.DoubleSide});
  const tubeMesh = new THREE.Mesh(tubeGeometry, tubeMaterial);
  tubeMesh.position.set(PRIZE_X, TUBE_Y, PRIZE_Z);
  scene.add(tubeMesh);
  // Top/bottom rings
  const ringGeom = new THREE.TorusGeometry(TUBE_RADIUS+0.006, 0.023, 13, 34);
  const ringMat = new THREE.MeshPhongMaterial({color:0xffee88, shininess: 65});
  const ringMeshTop = new THREE.Mesh(ringGeom, ringMat);
  ringMeshTop.position.set(PRIZE_X, TUBE_Y+TUBE_HEIGHT/2-0.013, PRIZE_Z); ringMeshTop.rotation.x = Math.PI/2;
  const ringMeshBot = new THREE.Mesh(ringGeom, ringMat);
  ringMeshBot.position.set(PRIZE_X, TUBE_Y-TUBE_HEIGHT/2+0.013, PRIZE_Z); ringMeshBot.rotation.x = Math.PI/2;
  scene.add(ringMeshTop); scene.add(ringMeshBot);
  // Physics: invisible tube (thin vertical wall cylinders)
  const tubeSegments = 12;
  const tubeAngleStep = 2*Math.PI/tubeSegments;
  for(let i=0;i<tubeSegments;i++) {
    let angle = i*tubeAngleStep;
    let cx = PRIZE_X+Math.cos(angle)*(TUBE_RADIUS-TUBE_THICK/2-0.015);
    let cz = PRIZE_Z+Math.sin(angle)*(TUBE_RADIUS-TUBE_THICK/2-0.015);
    let tubeWallBody = new CANNON.Body({mass:0});
    tubeWallBody.addShape(new CANNON.Box(new CANNON.Vec3(TUBE_THICK/2, TUBE_HEIGHT/2, 0.017)));
    tubeWallBody.position.set(cx, TUBE_Y, cz);
    tubeWallBody.quaternion.setFromEuler(0, -angle, 0);
    world.addBody(tubeWallBody);
  }

  // --- Balls ---
  let balls = [];
  let fadingBalls = [];
  let emojiBursts = [];
  let wonPrizes = [];
  let hasWon = false;
  function getRandomColor() {
    let h = Math.floor(Math.random()*360);
    return `hsl(${h},88%,62%)`;
  }
  function createColorBall(x, z, emoji) {
    let mat = new THREE.MeshPhongMaterial({color: getRandomColor(), shininess:60, transparent:true, opacity:1});
    let mesh = new THREE.Mesh(new THREE.SphereGeometry(BALL_RADIUS, 32, 24), mat);
    mesh.position.set(x, 0.31 + BALL_RADIUS, z); scene.add(mesh);
    let body = new CANNON.Body({mass:0.17, position: new CANNON.Vec3(x,0.31+BALL_RADIUS,z), shape: new CANNON.Sphere(BALL_RADIUS), linearDamping: 0.35, angularDamping:0.44 });
    body.allowSleep = true; body.position.set(x,0.31+BALL_RADIUS,z); world.addBody(body);
    balls.push({mesh, body, grabbed: false, beingHeld: false, fading: false, emoji: emoji});
  }
  function setupBalls() {
    balls.forEach(b=>{scene.remove(b.mesh); world.removeBody(b.body);});
    balls = []; let used = [];
    let count = BALL_COUNT;
    let triesTotal = 0;
    for(let i=0; i<count; ++i) {
      let tries=0, x=0,z=0, ok=false;
      while(tries<180 && triesTotal < count*180){
        x = (Math.random()-0.5)*1.5; z = (Math.random()-0.5)*1.15;
        let chuteDist = Math.sqrt((x-PRIZE_X)**2 + (z-PRIZE_Z)**2);
        if (chuteDist < (TUBE_RADIUS-0.03)) { tries++; triesTotal++; continue; }
        if(!used.some(u=>(Math.abs(u.x-x)<BALL_RADIUS*1.15&&Math.abs(u.z-z)<BALL_RADIUS*0.50))) { ok=true; break;}
        tries++; triesTotal++;
      }
      if (!ok) continue;
      used.push({x,z});
      createColorBall(x, z, EMOJIS[i % EMOJIS.length]);
    }
  }

  // --- Claw ---
  let clawX = 0, targetClawX = 0;
  let clawY = CLAW_Y_HOME, targetClawY = CLAW_Y_HOME;
  let clawZ = 0, targetClawZ = 0;
  let clawOpen = 1, targetClawOpen = 1;
  let clawGrabbing = false, heldBall = null;
  let clawFingers = [];
  let lastPrizeEmoji = null;
  const clawGroup = new THREE.Group();

  function buildClaw() {
    while(clawGroup.children.length) clawGroup.remove(clawGroup.children[0]);
    let rail = new THREE.Mesh(new THREE.CylinderGeometry(0.045,0.045,2.11,20), new THREE.MeshPhongMaterial({color:0xe0e0e0}));
    rail.position.set(0, 3.05, 0); rail.rotation.z = Math.PI/2; clawGroup.add(rail);
    let rail2 = new THREE.Mesh(new THREE.CylinderGeometry(0.035,0.035,1.51,20), new THREE.MeshPhongMaterial({color:0xf2f2ea}));
    rail2.position.set(0, 3.05, 0); rail2.rotation.x = Math.PI/2; clawGroup.add(rail2);
    let rod = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,1.8,14), new THREE.MeshPhongMaterial({color:0xcfcfcf}));
    rod.position.set(0,0.93,0); clawGroup.add(rod);
    let head = new THREE.Mesh(new THREE.SphereGeometry(0.16,22,16), new THREE.MeshPhongMaterial({color:0xa9a9a9, shininess:70}));
    head.position.set(0,0,0); clawGroup.add(head);
    clawFingers = [];
    for(let i=0; i<FINGER_COUNT; i++){
      let angle = i * (2*Math.PI / FINGER_COUNT);
      let fingerGroup = new THREE.Group();
      let finger = new THREE.Mesh(new THREE.CylinderGeometry(0.025,0.019,0.29,12,1), new THREE.MeshPhongMaterial({color:0xb0b0b0, shininess:90}));
      finger.position.y = -0.145;
      fingerGroup.add(finger);
      fingerGroup.position.set(Math.sin(angle)*FINGER_OPEN_LENGTH, -0.12, Math.cos(angle)*FINGER_OPEN_LENGTH);
      fingerGroup.userData = { baseAngle: angle };
      clawGroup.add(fingerGroup);
      clawFingers.push(fingerGroup);
    }
    clawGroup.position.set(clawX, clawY, clawZ);
    scene.add(clawGroup);
  }
  buildClaw();
  function updateClawVisual() {
    clawGroup.position.set(clawX, clawY, clawZ);
    let openL = clawOpen * FINGER_OPEN_LENGTH + (1-clawOpen)*FINGER_CLOSED_LENGTH;
    for(let i=0;i<FINGER_COUNT;i++) {
      let a = clawFingers[i].userData.baseAngle;
      clawFingers[i].position.set(Math.sin(a)*openL, -0.12, Math.cos(a)*openL);
    }
  }
  function tickClawTween() {
    clawX += (targetClawX - clawX) * CLAW_SPEED;
    clawY += (targetClawY - clawY) * CLAW_VERT_SPEED;
    clawZ += (targetClawZ - clawZ) * CLAW_Z_SPEED;
    clawOpen += (targetClawOpen - clawOpen) * 0.19;
  }
  function resetClaw() {
    targetClawX = clawX = 0; targetClawY = clawY = CLAW_Y_HOME;
    targetClawZ = clawZ = 0; targetClawOpen = clawOpen = 1;
    clawGrabbing = false; heldBall = null;
  }
  function moveClaw(dx, dz) {
    if(clawGrabbing || hasWon) return;
    targetClawX = Math.max(-CLAW_X_LIMIT, Math.min(CLAW_X_LIMIT, targetClawX + dx*0.36));
    targetClawZ = Math.max(-CLAW_Z_LIMIT, Math.min(CLAW_Z_LIMIT, targetClawZ + dz*0.32));
  }

  // Emoji burst function
  function explodeEmojisAt(pos, emoji) {
    let burst = [];
    for(let i=0;i<18+Math.floor(Math.random()*10);i++) {
      let cnv = document.createElement("canvas"); cnv.width=cnv.height=64;
      let ctx = cnv.getContext("2d");
      ctx.font = "38px serif"; ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(emoji,32,38);
      let tex = new THREE.CanvasTexture(cnv);
      let mat = new THREE.SpriteMaterial({map:tex,transparent:true});
      let sprite = new THREE.Sprite(mat);
      sprite.position.set(pos.x, pos.y, pos.z);
      let ang = Math.random()*Math.PI*2;
      let v = 0.34 + Math.random()*0.45;
      sprite.vel = {
        x: Math.cos(ang) * v * (0.88+0.22*Math.random()),
        y: Math.random()*0.41+0.20,
        z: Math.sin(ang) * v * (0.88+0.22*Math.random())
      };
      sprite.t0 = performance.now();
      sprite.material.opacity = 1;
      scene.add(sprite);
      burst.push(sprite);
    }
    emojiBursts.push(burst);
  }

  // --- Claw Sequence ---
  function doClawSequence() {
    if(clawGrabbing || hasWon) return;
    clawGrabbing = true;
    targetClawY = CLAW_Y_DROP;
    setTimeout(()=>{
      targetClawOpen = 1;
      setTimeout(()=>{
        targetClawOpen = 0;
        setTimeout(()=>{
          let nearest = null, minDist=99;
          balls.forEach(b=>{
            if(b.grabbed) return;
            let rel = new THREE.Vector3(b.body.position.x-clawX, b.body.position.y-(clawY-0.19), b.body.position.z-clawZ);
            let dxy = Math.sqrt(rel.x*rel.x + rel.z*rel.z);
            if(rel.y < 0.19 && rel.y > -0.22 && dxy < BALL_RADIUS * 1.15) {
              let dist = Math.abs(rel.y) + dxy;
              if(dist < minDist) { minDist = dist; nearest = b; }
            }
          });
          if(nearest) {
            nearest.grabbed = true; heldBall = nearest;
            nearest.beingHeld = true;
            nearest.body.velocity.set(0,0,0);
            nearest.body.position.set(clawX, clawY-0.19, clawZ);
            nearest.mesh.position.set(clawX, clawY-0.19, clawZ);
            nearest.body.type = CANNON.Body.KINEMATIC;
          }
          setTimeout(()=>{
            targetClawY = CLAW_Y_HOME;
            setTimeout(()=>{
              let startX = clawX, startZ = clawZ;
              let endX = PRIZE_X, endZ = PRIZE_Z;
              let moveTime = 660;
              let startTime = performance.now();
              function moveClawOverTube() {
                let t = (performance.now() - startTime)/moveTime;
                if (t > 1) t = 1;
                clawX = startX + (endX-startX)*t;
                clawZ = startZ + (endZ-startZ)*t;
                targetClawX = clawX;
                targetClawZ = clawZ;
                if (heldBall) {
                  heldBall.body.position.set(clawX, clawY-0.19, clawZ);
                  heldBall.mesh.position.set(clawX, clawY-0.19, clawZ);
                }
                if (t < 1) requestAnimationFrame(moveClawOverTube);
                else setTimeout(()=>{
                  // Drop: Open claw and let physics take over!
                  targetClawOpen = 1;
                  if(heldBall) {
                    lastPrizeEmoji = heldBall.emoji;
                    heldBall.body.type = CANNON.Body.DYNAMIC;
                    heldBall.beingHeld = false;
                    heldBall.grabbed = false;
                    setTimeout(()=>showPrizeRandomEmoji(), 800);
                    heldBall = null;
                  }
                  setTimeout(()=>{clawGrabbing = false;}, 900);
                }, 400);
              }
              moveClawOverTube();
            }, 340);
          }, 220);
        }, CLAW_GRAB_DURATION);
      }, 230);
    }, 190);
  }

  function showPrizeRandomEmoji() {
    const prizeMsg = document.getElementById('prizeMsg');
    let emoji = lastPrizeEmoji || 'ü¶ñ';
    prizeMsg.innerHTML = `You caught: <span style="font-size:2.5rem">${emoji}</span>`;
    prizeMsg.classList.add('show');
    wonPrizes.push(emoji);

    if(wonPrizes.length === PRIZES_TO_WIN && !hasWon) {
      setTimeout(()=>showWinMsg(), 900);
      document.getElementById('showPrizesBtn').classList.add('win');
    }
    setTimeout(()=>prizeMsg.classList.remove('show'), 2000);
  }

  function showWinMsg() {
    hasWon = true;
    const winMsg = document.getElementById('winMsg');
    winMsg.innerHTML = `üéâ You Win! üéâ`;
    winMsg.classList.add('show');
    setTimeout(()=>{winMsg.classList.remove('show');}, 3400);
  }

  // --- UI HANDLERS ---
  document.getElementById('leftBtn').onclick  = ()=>moveClaw(-1,0);
  document.getElementById('rightBtn').onclick = ()=>moveClaw(1,0);
  document.getElementById('upBtn').onclick    = ()=>moveClaw(0,-1);
  document.getElementById('downBtn').onclick  = ()=>moveClaw(0,1);
  document.getElementById('grabBtn').onclick  = doClawSequence;
  window.addEventListener('keydown',e=>{
    if(e.repeat)return;
    if(e.key==='ArrowLeft'||e.key==='a') moveClaw(-1,0);
    if(e.key==='ArrowRight'||e.key==='d') moveClaw(1,0);
    if(e.key==='ArrowUp'||e.key==='w') moveClaw(0,-1);
    if(e.key==='ArrowDown'||e.key==='s') moveClaw(0,1);
    if(e.key===' '||e.key==='Enter') doClawSequence();
  });
  let lastTap=0, touchX=0, touchY=0;
  renderer.domElement.addEventListener('touchstart',e=>{
    if(e.touches.length==1) {
      touchX = e.touches[0].clientX;
      touchY = e.touches[0].clientY;
    }
  });
  renderer.domElement.addEventListener('touchend',e=>{
    let dx = e.changedTouches[0].clientX - touchX;
    let dy = e.changedTouches[0].clientY - touchY;
    if(Math.abs(dx)>40 || Math.abs(dy)>40) {
      if(Math.abs(dx)>Math.abs(dy)) moveClaw(dx>0 ? 1 : -1, 0);
      else moveClaw(0, dy>0 ? 1 : -1);
    } else {
      let now=Date.now();
      if(now-lastTap<340) doClawSequence();
      lastTap=now;
    }
  });
  window.addEventListener('resize',()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if(trophyRenderer && trophyCamera){
      trophyRenderer.setSize(window.innerWidth, window.innerHeight);
      trophyCamera.aspect = window.innerWidth / window.innerHeight;
      trophyCamera.updateProjectionMatrix();
    }
  });

  // --- PRIZE TROPHY ROOM UI ---
  const showPrizesBtn = document.getElementById('showPrizesBtn');
  const prizeTrophyView = document.getElementById('prizeTrophyView');
  let trophyRenderer, trophyScene, trophyCamera, trophySprites = [], trophyAnimId, isTrophyView = false;
  let suckingIn = false, matrixRain = false, suckedPrizes = [];

  showPrizesBtn.onclick = function() {
    if (!wonPrizes.length) return;
    isTrophyView = !isTrophyView;
    prizeTrophyView.style.display = isTrophyView ? "flex" : "none";
    if (isTrophyView) {
      if (hasWon) {
        startTrophyRoom(true);
        showPrizesBtn.classList.remove('win');
      } else {
        startTrophyRoom(false);
      }
    } else {
      stopTrophyRoom();
    }
  };

  function startTrophyRoom(winMode) {
    prizeTrophyView.innerHTML = '';
    let closeBtn = document.createElement('button');
    closeBtn.textContent = "‚úï";
    closeBtn.onclick = ()=>{ isTrophyView=false; prizeTrophyView.style.display="none"; stopTrophyRoom(); };
    prizeTrophyView.appendChild(closeBtn);

    trophyRenderer = new THREE.WebGLRenderer({alpha:true,antialias:true});
    trophyRenderer.setSize(window.innerWidth, window.innerHeight);
    prizeTrophyView.appendChild(trophyRenderer.domElement);

    trophyScene = new THREE.Scene();
    trophyCamera = new THREE.PerspectiveCamera(65, window.innerWidth/window.innerHeight, 0.1, 50);
    trophyCamera.position.set(0,0,6);
    trophyCamera.lookAt(0,0,0);

    trophyScene.add(new THREE.AmbientLight(0xffffff, 0.84));
    let l = new THREE.DirectionalLight(0xffffe0, 0.43); l.position.set(4,5,7); trophyScene.add(l);

    trophySprites = [];
    const N = wonPrizes.length;
    for(let i=0;i<N;i++){
      let emoji = wonPrizes[i];
      let cnv = document.createElement("canvas"); cnv.width=cnv.height=64;
      let ctx = cnv.getContext("2d");
      ctx.font = "40px serif"; ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(emoji,32,38);
      let tex = new THREE.CanvasTexture(cnv);
      let mat = new THREE.SpriteMaterial({map:tex,transparent:true});
      mat.onBeforeCompile = shader => {
        shader.fragmentShader = shader.fragmentShader.replace(
          '#include <dithering_fragment>',
          `
          float d = distance(gl_PointCoord, vec2(0.5,0.5));
          if(d > 0.52) discard;
          vec3 glow = vec3(1.0,0.94,0.55)*(1.0-d*1.6)*0.22;
          gl_FragColor.rgb += glow;
          #include <dithering_fragment>
          `
        );
      };
      let spr = new THREE.Sprite(mat);
      let angle = i*2*Math.PI/N;
      spr.position.set(Math.cos(angle)*2.3, Math.sin(angle)*1.2, 0);
      spr.scale.set(0.89,0.89,0.89);
      trophyScene.add(spr);
      trophySprites.push({spr, angle0:angle, i});
    }
    suckingIn = false; matrixRain = false; suckedPrizes = [];
    animateTrophyRoom(winMode);

    // Win celebration!
    if (winMode) {
      setTimeout(()=>{ suckingIn = true; suckedPrizes = []; }, 1400);
    }
  }

  function animateTrophyRoom(winMode) {
    if(!isTrophyView) return;
    let t = performance.now()/1000;
    let N = trophySprites.length;
    for(let j=0;j<N;j++) {
      let obj = trophySprites[j];
      if (!suckingIn) {
        let a = obj.angle0 + t*0.29;
        let y = Math.sin(a)*1.2 + Math.sin(t+obj.i)*0.23;
        obj.spr.position.set(Math.cos(a)*2.3, y, Math.sin(a)*0.2);
        obj.spr.material.rotation = t*1.4;
        obj.spr.rotation.y = t*1.5 + j;
      } else if (!suckedPrizes[j]) {
        // Suck toward center, one by one
        let delay = 370*j;
        let progress = Math.max(0, Math.min(1, (performance.now() - (trophySprites[0].t0||performance.now()) - delay)/430));
        if (progress>=1) {
          obj.spr.position.set(0, 0, 0);
          suckedPrizes[j] = true;
          if (j===N-1 && !matrixRain) {
            setTimeout(()=>{
              explodeTrophyRoom(obj.spr.material.map);
              setTimeout(()=>emojiMatrixRain(obj.spr.material.map), 340);
            }, 200);
          }
        } else {
          let a = obj.angle0 + t*0.29;
          let y = Math.sin(a)*1.2 + Math.sin(t+obj.i)*0.23;
          let tx = Math.cos(a)*2.3, ty = y, tz = Math.sin(a)*0.2;
          obj.spr.position.set(
            tx * (1-progress),
            ty * (1-progress),
            tz * (1-progress)
          );
          obj.spr.material.rotation = t*1.4;
          obj.spr.rotation.y = t*1.5 + j;
        }
      } else {
        obj.spr.position.set(0, 0, 0);
      }
    }
    if (suckingIn && !trophySprites[0].t0) {
      let now = performance.now();
      for (let k = 0; k < trophySprites.length; k++) trophySprites[k].t0 = now;
    }
    if (matrixRain) animateMatrixRain();
    trophyRenderer.render(trophyScene, trophyCamera);
    trophyAnimId = requestAnimationFrame(()=>animateTrophyRoom(winMode));
  }

  // Explosion at center
  function explodeTrophyRoom(texture) {
    let burst = [];
    for (let i=0;i<120;i++) {
      let mat = new THREE.SpriteMaterial({map:texture,transparent:true});
      let spr = new THREE.Sprite(mat);
      let a = Math.random()*Math.PI*2;
      let r = 0.4+Math.random()*0.14;
      spr.position.set(0,0,0);
      spr.vel = {
        x: Math.cos(a) * r * (1+0.21*Math.random()),
        y: Math.random()*0.97+0.23,
        z: Math.sin(a) * r * (1+0.21*Math.random())
      };
      spr.t0 = performance.now();
      spr.material.opacity = 0.95+Math.random()*0.05;
      trophyScene.add(spr);
      burst.push(spr);
    }
    setTimeout(()=>{ burst.forEach(spr=>trophyScene.remove(spr)); }, 950);
  }

  // Matrix emoji rain
  let rainSprites = [];
  function emojiMatrixRain(texture) {
    matrixRain = true;
    rainSprites = [];
    for (let i=0;i<130;i++) {
      let mat = new THREE.SpriteMaterial({map:texture,transparent:true});
      let spr = new THREE.Sprite(mat);
      let x = (Math.random()-0.5)*10;
      let z = (Math.random()-0.5)*5;
      spr.position.set(x, 6+Math.random()*7, z);
      spr.scale.set(0.7+Math.random()*0.5,0.7+Math.random()*0.5,0.7);
      spr.vel = {y: -2.4 - Math.random()*2};
      spr.material.opacity = 0.92+Math.random()*0.08;
      trophyScene.add(spr);
      rainSprites.push(spr);
    }
    setTimeout(()=>resetGame(), 4400);
  }
  function animateMatrixRain() {
    for(let s of rainSprites){
      s.position.y += s.vel.y * 0.04;
      if (s.position.y < -7) s.position.y = 8 + Math.random()*3;
    }
  }
  function stopTrophyRoom() {
    if(trophyAnimId) cancelAnimationFrame(trophyAnimId);
    if(trophyRenderer) { trophyRenderer.dispose(); }
    if(prizeTrophyView.firstChild) prizeTrophyView.removeChild(prizeTrophyView.firstChild);
    isTrophyView = false;
    suckingIn = false; matrixRain = false;
    emojiBursts = []; rainSprites = [];
  }
  function resetGame() {
    wonPrizes = [];
    hasWon = false;
    suckingIn = false; matrixRain = false; trophySprites=[];
    isTrophyView = false;
    stopTrophyRoom();
    prizeTrophyView.style.display="none";
    setupBalls();
    resetClaw();
  }

  // --- Animate Main Game ---
  function animate() {
    tickClawTween();
    updateClawVisual();
    world.step(1/60);

    // Remove (fade out) balls that have fallen down the chute and trigger explosion
    for (let i = balls.length - 1; i >= 0; i--) {
      let b = balls[i];
      // Ball hits top of chute: explode
      if (
        !b.grabbed && !b.beingHeld &&
        b.body.position.y < TUBE_Y + TUBE_HEIGHT/2 - 0.11 &&
        Math.abs(b.body.position.x - PRIZE_X) < TUBE_RADIUS &&
        Math.abs(b.body.position.z - PRIZE_Z) < TUBE_RADIUS
      ) {
        if (!b.fading) {
          b.fading = true;
          b.fadeStart = performance.now();
          fadingBalls.push(b);
          world.removeBody(b.body);
          explodeEmojisAt(b.mesh.position, b.emoji);
          balls.splice(i, 1);
        }
      }
    }

    // Emoji burst animation
    for (let k=emojiBursts.length-1;k>=0;k--) {
      let burst = emojiBursts[k];
      let allGone = true;
      for (let spr of burst) {
        let dt = (performance.now()-spr.t0)/900;
        if (dt < 1) {
          spr.position.x += spr.vel.x*0.06*(1-dt*0.4);
          spr.position.y += spr.vel.y*0.06*(1-dt*0.7);
          spr.position.z += (spr.vel.z||0)*0.06*(1-dt*0.4);
          spr.material.opacity = Math.max(0,1-dt);
          allGone = false;
        } else if (spr.parent) {
          scene.remove(spr);
        }
      }
      if (allGone) emojiBursts.splice(k,1);
    }

    balls.forEach(b=>{
      if(b.beingHeld && heldBall===b) {
        b.body.position.set(clawX, clawY-0.19, clawZ);
        b.mesh.position.copy(b.body.position);
      } else {
        b.mesh.position.copy(b.body.position);
        b.mesh.quaternion.copy(b.body.quaternion);
      }
    });

    // Animate faded balls
    let now = performance.now();
    for (let i = fadingBalls.length - 1; i >= 0; i--) {
      let fb = fadingBalls[i];
      let t = Math.min(1, (now - fb.fadeStart) / 800); // 800ms fade
      if (fb.mesh.material.opacity === undefined) {
        fb.mesh.material.transparent = true;
        fb.mesh.material.opacity = 1.0;
      }
      fb.mesh.material.opacity = 1.0 - t;
      if (t >= 1) {
        scene.remove(fb.mesh);
        fadingBalls.splice(i, 1);
      }
    }
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }
  setupBalls();
  resetClaw();
  animate();
  </script>
</body>
</html>