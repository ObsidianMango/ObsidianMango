<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üé≤ d20v5</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #050505;
        font-family: 'Courier New', Courier, monospace;
        color: #0f0;
      }
      
      #container { width: 100vw; height: 100vh; }

      /* UI Overlay */
      .ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        padding: 20px;
        box-sizing: border-box;
      }

      /* Settings Button */
      #settings-btn {
        pointer-events: auto;
        background: rgba(0, 0, 0, 0.8);
        border: 2px solid #0f0;
        color: #0f0;
        font-size: 24px;
        padding: 10px 20px;
        cursor: pointer;
        align-self: flex-end;
        border-radius: 4px;
        text-transform: uppercase;
        font-weight: bold;
        box-shadow: 0 0 10px #0f0;
        transition: all 0.2s;
      }
      #settings-btn:hover { background: #0f0; color: #000; }

      /* Result Display */
      #result-display {
        text-align: center;
        font-size: 48px;
        text-shadow: 0 0 20px #0f0;
        pointer-events: auto;
        background: rgba(0,0,0,0.5);
        padding: 10px;
        border-radius: 10px;
        margin-bottom: 20px;
      }

      /* Modal */
      #settings-modal {
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0,0,0,0.9);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 100;
        pointer-events: auto;
      }
      
      .modal-content {
        border: 2px solid #0f0;
        padding: 40px;
        background: #111;
        text-align: center;
        box-shadow: 0 0 50px rgba(0, 255, 0, 0.2);
        max-width: 90%;
      }

      .btn-row {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 20px;
        flex-wrap: wrap;
      }

      .option-btn {
        background: transparent;
        border: 1px solid #0f0;
        color: #0f0;
        padding: 10px 20px;
        font-size: 18px;
        cursor: pointer;
        transition: 0.2s;
      }
      .option-btn:hover, .option-btn.active {
        background: #0f0;
        color: #000;
        box-shadow: 0 0 15px #0f0;
      }
      
      h2 { margin-top: 0; text-shadow: 0 0 10px #0f0; }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <div class="ui-layer">
      <button id="settings-btn">‚öôÔ∏è OPTIONS</button>
      <div id="result-display">CLICK TO ROLL</div>
    </div>

    <div id="settings-modal">
      <div class="modal-content">
        <h2>DICE CONFIG</h2>
        
        <p>TYPE</p>
        <div class="btn-row" id="type-row">
          <button class="option-btn" data-type="d4">D4</button>
          <button class="option-btn" data-type="d6">D6</button>
          <button class="option-btn" data-type="d8">D8</button>
          <button class="option-btn" data-type="d12">D12</button>
          <button class="option-btn active" data-type="d20">D20</button>
        </div>

        <p>COUNT</p>
        <div class="btn-row" id="count-row">
          <button class="option-btn active" data-count="1">1</button>
          <button class="option-btn" data-count="2">2</button>
          <button class="option-btn" data-count="3">3</button>
          <button class="option-btn" data-count="4">4</button>
          <button class="option-btn" data-count="5">5</button>
        </div>
        
        <br><br>
        <button class="option-btn" id="close-modal">DONE</button>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.152.2/build/three.module.js";

      // --- CONFIG ---
      const CONFIG = {
        bg: 0x111111,
        diceColor: 0x1a1a1a,
        lineColor: 0x00ff00, // Matrix Green
        textColor: "#00ff00",
        rollTime: 1500 // ms
      };

      // --- GLOBALS ---
      let scene, camera, renderer;
      let diceObjects = []; 
      let isRolling = false;
      let currentType = "d20";
      let currentCount = 1;

      // --- INIT ---
      function init() {
        const container = document.getElementById("container");
        
        // Scene
        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(CONFIG.bg, 0.02);

        // Camera
        camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 14); // High angle
        camera.lookAt(0, 0, 0);

        // Renderer
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(CONFIG.bg);
        container.appendChild(renderer.domElement);

        // Lights (Make it look 3D but keep neon style)
        const ambient = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambient);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 5);
        scene.add(dirLight);
        const pLight = new THREE.PointLight(CONFIG.lineColor, 1, 20);
        pLight.position.set(0, 5, 0);
        scene.add(pLight);

        // Floor Grid (Visual anchor)
        const grid = new THREE.GridHelper(50, 50, 0x333333, 0x222222);
        scene.add(grid);

        // Listeners
        window.addEventListener("resize", onResize);
        container.addEventListener("click", () => { if(!isRolling) rollDice(); });
        
        setupUI();
        spawnDice(); // Initial Spawn
        animate();
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // --- UI ---
      function setupUI() {
        const modal = document.getElementById("settings-modal");
        
        document.getElementById("settings-btn").onclick = () => {
          modal.style.display = "flex";
        };
        document.getElementById("close-modal").onclick = () => {
          modal.style.display = "none";
        };

        // Type Buttons
        document.querySelectorAll("#type-row .option-btn").forEach(btn => {
          btn.onclick = (e) => {
            document.querySelectorAll("#type-row .option-btn").forEach(b=>b.classList.remove("active"));
            e.target.classList.add("active");
            currentType = e.target.dataset.type;
            spawnDice();
          };
        });

        // Count Buttons
        document.querySelectorAll("#count-row .option-btn").forEach(btn => {
          btn.onclick = (e) => {
            document.querySelectorAll("#count-row .option-btn").forEach(b=>b.classList.remove("active"));
            e.target.classList.add("active");
            currentCount = parseInt(e.target.dataset.count);
            spawnDice();
          };
        });
      }

      // --- DICE LOGIC (Restored from Original) ---
      function getGeometry(type) {
        switch (type) {
          case "d4": return new THREE.TetrahedronGeometry(1.5, 0);
          case "d6": return new THREE.BoxGeometry(2, 2, 2);
          case "d8": return new THREE.OctahedronGeometry(1.5, 0);
          case "d12": return new THREE.DodecahedronGeometry(1.5, 0);
          case "d20": default: return new THREE.IcosahedronGeometry(1.5, 0);
        }
      }

      function getTrisPerFace(type) {
        // Critical logic from original code
        if (type === "d6") return 2;
        if (type === "d12") return 3;
        return 1;
      }

      function createDiceMesh() {
        const geo = getGeometry(currentType);
        
        // 1. Base Material (Black Plastic)
        const mat = new THREE.MeshStandardMaterial({ 
          color: CONFIG.diceColor,
          roughness: 0.4,
          metalness: 0.5
        });
        const mesh = new THREE.Mesh(geo, mat);

        // 2. Wireframe (Glowing Edges)
        const edges = new THREE.EdgesGeometry(geo);
        const lineMat = new THREE.LineBasicMaterial({ color: CONFIG.lineColor });
        const lines = new THREE.LineSegments(edges, lineMat);
        mesh.add(lines);

        // 3. Numbers (The crucial fix)
        addNumbers(mesh);

        return mesh;
      }

      function addNumbers(mesh) {
        const geometry = mesh.geometry;
        // Fix index if missing
        if (!geometry.index) {
          const pos = geometry.attributes.position;
          const idx = [];
          for(let i=0; i<pos.count; i++) idx.push(i);
          geometry.setIndex(idx);
        }

        const indices = geometry.index.array;
        const posAttr = geometry.attributes.position;
        const trisPerFace = getTrisPerFace(currentType);
        const faceCount = indices.length / (3 * trisPerFace);

        let number = 1;
        
        for (let i = 0; i < indices.length; i += (3 * trisPerFace)) {
          // Calculate Center of the Face (Average of all vertices in the face)
          let center = new THREE.Vector3();
          let normalSum = new THREE.Vector3();

          // Loop through triangles in this face
          for (let t = 0; t < trisPerFace; t++) {
            const idxOffset = i + (t * 3);
            const a = indices[idxOffset];
            const b = indices[idxOffset+1];
            const c = indices[idxOffset+2];

            const vA = new THREE.Vector3().fromBufferAttribute(posAttr, a);
            const vB = new THREE.Vector3().fromBufferAttribute(posAttr, b);
            const vC = new THREE.Vector3().fromBufferAttribute(posAttr, c);

            center.add(vA).add(vB).add(vC);

            // Calculate Normal
            const edge1 = new THREE.Vector3().subVectors(vB, vA);
            const edge2 = new THREE.Vector3().subVectors(vC, vA);
            normalSum.add(new THREE.Vector3().crossVectors(edge1, edge2).normalize());
          }

          center.divideScalar(trisPerFace * 3);
          const normal = normalSum.normalize();

          // Create Label
          const label = createLabel(number.toString());
          
          // Position: Center + slight offset along normal to prevent clipping
          label.position.copy(center.add(normal.multiplyScalar(0.02))); 
          
          // Rotate: Look away from center
          label.lookAt(center.clone().add(normal));
          
          // Identify face for logic later
          label.userData = { isLabel: true, value: number };
          
          mesh.add(label);
          number++;
        }
      }

      function createLabel(text) {
        const canvas = document.createElement("canvas");
        canvas.width = 128; 
        canvas.height = 128;
        const ctx = canvas.getContext("2d");
        
        // High contrast text
        ctx.fillStyle = CONFIG.textColor;
        ctx.font = "bold 80px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, 64, 64);

        const tex = new THREE.CanvasTexture(canvas);
        // Important: settings to prevent z-fighting / missing numbers
        const mat = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
          side: THREE.DoubleSide,
          polygonOffset: true,
          polygonOffsetFactor: -2, // Pulls towards camera
          polygonOffsetUnits: -2
        });

        const plane = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), mat);
        return plane;
      }


      // --- ANIMATION LOGIC (Restored & Smoothed) ---
      function spawnDice() {
        // Clear old
        diceObjects.forEach(d => scene.remove(d.mesh));
        diceObjects = [];
        
        // Setup positions
        const spacing = 3;
        const startX = -((currentCount - 1) * spacing) / 2;

        for (let i = 0; i < currentCount; i++) {
          const mesh = createDiceMesh();
          const x = startX + i * spacing;
          
          // Resting Position
          mesh.position.set(x, 1.5, 0); 
          // Random Rotation
          mesh.rotation.set(Math.random()*6, Math.random()*6, Math.random()*6);
          
          scene.add(mesh);
          diceObjects.push({
            mesh: mesh,
            homePos: new THREE.Vector3(x, 0, 0) // Target X/Z
          });
        }
        document.getElementById("result-display").innerText = "CLICK TO ROLL";
      }

      function rollDice() {
        if (isRolling) return;
        isRolling = true;
        document.getElementById("result-display").innerText = "...";

        const startTime = performance.now();
        
        diceObjects.forEach(d => {
            // Define Flight Path
            d.startPos = d.mesh.position.clone();
            // Start high up and slightly random offset
            d.startPos.set(d.homePos.x + (Math.random()-0.5)*2, 10, (Math.random()-0.5)*2);
            d.mesh.position.copy(d.startPos);

            // Rotations
            d.startRot = d.mesh.rotation.clone();
            d.targetRot = new THREE.Euler(
                d.startRot.x + (Math.random() * 8 + 4) * Math.PI,
                d.startRot.y + (Math.random() * 8 + 4) * Math.PI,
                d.startRot.z + (Math.random() * 8 + 4) * Math.PI
            );
        });

        function loop() {
          const now = performance.now();
          const elapsed = now - startTime;
          let t = elapsed / CONFIG.rollTime;
          
          if (t >= 1) {
            t = 1;
            isRolling = false;
            finalize();
            return; // Stop animation
          } else {
            requestAnimationFrame(loop);
          }

          // Ease Out Cubic for ground movement
          const easeOut = 1 - Math.pow(1 - t, 3);
          
          // Parabola for Height (The "Throw" you liked)
          // sin(t * PI) creates an arc. We multiply by (1-t) to dampen it slightly at the end
          // to prevent the "hard snap".
          const height = Math.sin(t * Math.PI) * 8; 
          // However, sin(PI) is 0, so it lands naturally.
          
          // Add a tiny bounce at the very end
          let bounce = 0;
          if (t > 0.8) {
              // small bump
              bounce = Math.sin((t-0.8) * 10 * Math.PI) * 0.5 * (1-t); 
          }

          diceObjects.forEach(d => {
            // Position
            d.mesh.position.x = THREE.MathUtils.lerp(d.startPos.x, d.homePos.x, easeOut);
            d.mesh.position.z = THREE.MathUtils.lerp(d.startPos.z, d.homePos.z, easeOut);
            
            // Y is the arc. If t is near 1, we force it to ground to prevent floating.
            d.mesh.position.y = (t > 0.95 ? 0 : Math.abs(height)) + 1.5; // +1.5 is radius

            // Rotation
            d.mesh.rotation.x = THREE.MathUtils.lerp(d.startRot.x, d.targetRot.x, easeOut);
            d.mesh.rotation.y = THREE.MathUtils.lerp(d.startRot.y, d.targetRot.y, easeOut);
            d.mesh.rotation.z = THREE.MathUtils.lerp(d.startRot.z, d.targetRot.z, easeOut);
          });
          
          renderer.render(scene, camera);
        }
        loop();
      }

      function finalize() {
        // Snap to final exact values to ensure fairness
        diceObjects.forEach(d => {
          d.mesh.position.copy(d.homePos);
          d.mesh.position.y = 1.5; // Resting height
          d.mesh.rotation.copy(d.targetRot);
        });
        renderer.render(scene, camera);
        calculateResults();
      }

      function calculateResults() {
        const results = [];
        const camDir = camera.position.clone().normalize(); // Roughly

        diceObjects.forEach(d => {
          let bestVal = "?";
          let bestDist = Infinity;
          
          // Find the label closest to the camera
          d.mesh.children.forEach(child => {
            if (child.userData.isLabel) {
              const worldPos = new THREE.Vector3();
              child.getWorldPosition(worldPos);
              const dist = worldPos.distanceTo(camera.position);
              
              if (dist < bestDist) {
                bestDist = dist;
                bestVal = child.userData.value;
              }
            }
          });
          
          results.push(bestVal);
          
          // Highlight winning face
          d.mesh.children.forEach(c => {
             if(c.userData.value === bestVal) {
                 c.material.color.setHex(0xffffff); // Flash white
                 c.scale.set(1.5, 1.5, 1.5);
             }
          });
        });

        // Display
        const sum = results.reduce((a,b)=>a+b, 0);
        document.getElementById("result-display").innerText = 
          results.length > 1 ? `${results.join(" + ")} = ${sum}` : `${sum}`;
          
        // Crit Effects
        if (currentType === "d20" && currentCount === 1) {
            if(sum === 20) flash(0x00ff00);
            if(sum === 1) flash(0xff0000);
        }
      }
      
      function flash(colorHex) {
          const div = document.createElement("div");
          div.style.position = "fixed";
          div.style.top = 0; div.style.left = 0;
          div.style.width = "100%"; div.style.height = "100%";
          div.style.background = "#" + new THREE.Color(colorHex).getHexString();
          div.style.opacity = 0.3;
          div.style.pointerEvents = "none";
          document.body.appendChild(div);
          
          // Fade out
          let op = 0.3;
          const timer = setInterval(() => {
              op -= 0.05;
              div.style.opacity = op;
              if(op <= 0) {
                  clearInterval(timer);
                  div.remove();
              }
          }, 50);
      }

      init();
    </script>
  </body>
</html>
