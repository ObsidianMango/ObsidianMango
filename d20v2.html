<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>üé≤ d20v4 Smooth</title>
    <style>
      :root {
        --primary: #bb86fc;
        --accent: #03dac6;
        --surface: rgba(20, 20, 20, 0.95);
        --glass: rgba(255, 255, 255, 0.05);
      }
      body {
        margin: 0;
        overflow: hidden;
        background: radial-gradient(circle at center, #1a1a1a 0%, #000 100%);
        font-family: 'Segoe UI', Tahoma, sans-serif;
        color: white;
        user-select: none;
      }
      #container {
        width: 100vw;
        height: 100vh;
        display: block;
      }

      /* --- UI STYLES --- */
      #ui-layer {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
      }

      /* Settings Panel (Top Right) */
      .settings-container {
        position: absolute;
        top: 20px;
        right: 20px;
        pointer-events: auto;
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 10px;
        z-index: 100;
      }

      #toggle-settings {
        background: rgba(0,0,0,0.5);
        border: 1px solid var(--primary);
        color: var(--primary);
        width: 44px;
        height: 44px;
        border-radius: 50%;
        font-size: 22px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s;
      }
      #toggle-settings:hover { transform: rotate(90deg); }

      #settings-panel {
        background: var(--surface);
        padding: 20px;
        border-radius: 12px;
        border: 1px solid rgba(255,255,255,0.1);
        display: flex;
        flex-direction: column;
        gap: 15px;
        box-shadow: 0 10px 40px rgba(0,0,0,0.8);
        width: 220px;
        transition: opacity 0.3s, transform 0.3s;
        transform-origin: top right;
      }
      
      #settings-panel.hidden {
        opacity: 0;
        transform: scale(0.9);
        pointer-events: none;
      }

      .control-group label {
        display: block;
        font-size: 11px;
        text-transform: uppercase;
        letter-spacing: 1px;
        color: #888;
        margin-bottom: 8px;
      }

      .grid-buttons {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 5px;
      }

      .grid-buttons button {
        background: var(--glass);
        border: 1px solid rgba(255,255,255,0.1);
        color: #ddd;
        padding: 8px 0;
        border-radius: 6px;
        cursor: pointer;
        font-size: 14px;
        transition: all 0.2s;
      }

      .grid-buttons button:hover { background: rgba(255,255,255,0.1); }
      
      .grid-buttons button.active {
        background: var(--primary);
        color: #000;
        font-weight: bold;
        box-shadow: 0 0 10px rgba(187, 134, 252, 0.3);
        border-color: var(--primary);
      }

      /* Bottom Control Bar */
      .bottom-bar {
        padding: 40px 20px;
        text-align: center;
        pointer-events: auto;
        background: linear-gradient(to top, rgba(0,0,0,0.8), transparent);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
      }

      #result-display {
        font-size: 3.5rem;
        font-weight: 800;
        text-shadow: 0 0 20px var(--primary);
        min-height: 70px;
        font-variant-numeric: tabular-nums;
      }

      #roll-btn {
        background: linear-gradient(135deg, var(--primary), #7c4dff);
        border: none;
        padding: 16px 80px;
        font-size: 1.4rem;
        border-radius: 50px;
        color: white;
        font-weight: bold;
        cursor: pointer;
        box-shadow: 0 4px 20px rgba(124, 77, 255, 0.4);
        transition: transform 0.1s, box-shadow 0.2s;
        letter-spacing: 2px;
      }

      #roll-btn:active { transform: scale(0.96); }

      /* Crit Animations */
      .crit-msg {
        position: fixed;
        top: 40%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 6rem;
        font-weight: 900;
        pointer-events: none;
        z-index: 999;
        text-shadow: 0 10px 40px rgba(0,0,0,1);
        animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
      }
      @keyframes popIn { from { transform: translate(-50%, -50%) scale(0); opacity: 0; } to { transform: translate(-50%, -50%) scale(1); opacity: 1; } }
      .nat20 { color: #00ff00; }
      .nat1 { color: #ff3333; }

    </style>
  </head>
  <body>
    <div id="container"></div>

    <div id="ui-layer">
      <div class="settings-container">
        <button id="toggle-settings">‚öôÔ∏è</button>
        <div id="settings-panel" class="hidden">
          
          <div class="control-group">
            <label>Dice Type</label>
            <div class="grid-buttons" id="type-selector">
              <button data-val="d4">D4</button>
              <button data-val="d6">D6</button>
              <button data-val="d8">D8</button>
              <button data-val="d10">D10</button>
              <button data-val="d12">D12</button>
              <button data-val="d20" class="active">D20</button>
            </div>
          </div>

          <div class="control-group">
            <label>Quantity</label>
            <div class="grid-buttons" id="count-selector">
              <button data-val="1" class="active">1</button>
              <button data-val="2">2</button>
              <button data-val="3">3</button>
              <button data-val="4">4</button>
              <button data-val="5">5</button>
              <button data-val="6">6</button>
            </div>
          </div>
        </div>
      </div>

      <div class="bottom-bar">
        <div id="result-display">Ready</div>
        <button id="roll-btn">ROLL</button>
      </div>
    </div>

    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.152.2/build/three.module.js";

      // --- CONFIGURATION ---
      const CONFIG = {
        color: 0x6200ea, // Deep Purple
        textColor: 0xffffff,
        animDuration: 1800 // ms
      };

      // --- STATE ---
      let state = {
        diceType: "d20",
        diceCount: 1,
        isRolling: false,
        dice: [] // Array of dice objects
      };

      // --- THREE.JS GLOBALS ---
      let scene, camera, renderer, floor;

      function init() {
        scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x050505, 10, 50);

        camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 15, 15);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        document.getElementById("container").appendChild(renderer.domElement);

        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambient);
        
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(10, 20, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        const rimLight = new THREE.PointLight(CONFIG.color, 2, 20);
        rimLight.position.set(-5, 5, -5);
        scene.add(rimLight);

        // Floor
        const floorGeo = new THREE.PlaneGeometry(100, 100);
        const floorMat = new THREE.ShadowMaterial({ opacity: 0.4 });
        floor = new THREE.Mesh(floorGeo, floorMat);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Events
        window.addEventListener("resize", onResize);
        document.getElementById("roll-btn").addEventListener("click", startRoll);
        document.getElementById("toggle-settings").addEventListener("click", () => {
          document.getElementById("settings-panel").classList.toggle("hidden");
        });
        
        setupUI();
        // Initial spawn (Preview mode)
        spawnDice(true); 
        animate();
      }

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // --- UI LOGIC ---
      function setupUI() {
        const types = document.querySelectorAll("#type-selector button");
        const counts = document.querySelectorAll("#count-selector button");

        types.forEach(btn => btn.addEventListener("click", (e) => {
          types.forEach(b => b.classList.remove("active"));
          e.target.classList.add("active");
          state.diceType = e.target.dataset.val;
          spawnDice(true); // Immediate update
        }));

        counts.forEach(btn => btn.addEventListener("click", (e) => {
          counts.forEach(b => b.classList.remove("active"));
          e.target.classList.add("active");
          state.diceCount = parseInt(e.target.dataset.val);
          spawnDice(true); // Immediate update
        }));
      }

      // --- DICE FACTORY ---
      function getGeometry(type) {
        switch(type) {
          case "d4": return new THREE.TetrahedronGeometry(1.2);
          case "d6": return new THREE.BoxGeometry(1.5, 1.5, 1.5);
          case "d8": return new THREE.OctahedronGeometry(1.2);
          case "d10": return new THREE.OctahedronGeometry(1.2); // Placeholder for d10 (uses d8 shape visually for now to keep code small)
          case "d12": return new THREE.DodecahedronGeometry(1.2);
          case "d20": default: return new THREE.IcosahedronGeometry(1.2);
        }
      }

      function createDiceMesh(type) {
        const geo = getGeometry(type);
        const mat = new THREE.MeshPhysicalMaterial({
          color: CONFIG.color,
          metalness: 0.1,
          roughness: 0.1,
          clearcoat: 1.0,
          clearcoatRoughness: 0.1,
          flatShading: true
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        addLabels(mesh, type);
        return mesh;
      }

      function createLabelTexture(text) {
        const cvs = document.createElement("canvas");
        cvs.width = 256; cvs.height = 256;
        const ctx = cvs.getContext("2d");
        ctx.fillStyle = "rgba(0,0,0,0)";
        ctx.clearRect(0,0,256,256);
        ctx.font = "bold 120px Arial";
        ctx.fillStyle = "white";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        // Shadow for readability
        ctx.shadowColor = "black";
        ctx.shadowBlur = 8;
        ctx.fillText(text, 128, 128);
        return new THREE.CanvasTexture(cvs);
      }

      function addLabels(mesh, type) {
        if (!mesh.geometry.index) return;
        const pos = mesh.geometry.attributes.position;
        const idx = mesh.geometry.index.array;
        
        // Approximate faces. 
        // Note: For a perfect d10/d20, manual face mapping is usually required. 
        // This is a procedural approximation that places numbers on flat surfaces.
        let trisPerFace = 1;
        if (type === "d6") trisPerFace = 2;
        if (type === "d12") trisPerFace = 3; 

        let faceNum = 1;
        for (let i = 0; i < idx.length; i += 3 * trisPerFace) {
          // Get center of face
          const a = idx[i];
          const b = idx[i+1];
          const c = idx[i+2];
          const vA = new THREE.Vector3().fromBufferAttribute(pos, a);
          const vB = new THREE.Vector3().fromBufferAttribute(pos, b);
          const vC = new THREE.Vector3().fromBufferAttribute(pos, c);
          
          const center = new THREE.Vector3().add(vA).add(vB).add(vC).divideScalar(3);
          const normal = new THREE.Vector3().crossVectors(
            new THREE.Vector3().subVectors(vB,vA),
            new THREE.Vector3().subVectors(vC,vA)
          ).normalize();

          // Add Plane
          const labelGeo = new THREE.PlaneGeometry(0.8, 0.8);
          const labelMat = new THREE.MeshBasicMaterial({
            map: createLabelTexture(faceNum.toString()),
            transparent: true,
            side: THREE.DoubleSide,
            depthTest: false // Ensures label is always on top of the face color
          });
          const label = new THREE.Mesh(labelGeo, labelMat);
          
          // Push slightly out
          label.position.copy(center.add(normal.multiplyScalar(0.05)));
          label.lookAt(center.clone().add(normal));
          label.userData = { isLabel: true, val: faceNum };
          mesh.add(label);
          faceNum++;
        }
      }

      // --- SPAWNING & ROLLING ---
      
      // isPreview: true = sit still at center. false = prepare for animation
      function spawnDice(isPreview = false) {
        // Clear old
        state.dice.forEach(d => scene.remove(d.mesh));
        state.dice = [];

        // Cleanup critical messages
        document.querySelectorAll('.crit-msg').forEach(e => e.remove());

        const spacing = 2.5;
        const startX = -((state.diceCount - 1) * spacing) / 2;

        for(let i=0; i<state.diceCount; i++) {
          const mesh = createDiceMesh(state.diceType);
          const targetX = startX + i * spacing;
          
          if (isPreview) {
            // Place directly on floor
            mesh.position.set(targetX, 1.2, 0);
            mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
          } else {
            // Place high up for drop
            mesh.position.set(targetX, 15, 0); // Start high
          }

          scene.add(mesh);
          
          state.dice.push({
            mesh: mesh,
            targetX: targetX, // Where it lands on X
            landed: isPreview,
            // Rotations for animation
            startRot: new THREE.Euler(Math.random()*6, Math.random()*6, Math.random()*6),
            endRot: new THREE.Euler(
              Math.random()*10 + 5, 
              Math.random()*10 + 5, 
              Math.random()*10 + 5
            )
          });
        }
        
        if (isPreview) {
            document.getElementById("result-display").innerText = "Ready";
            state.isRolling = false;
        }
      }

      function startRoll() {
        if (state.isRolling) return;
        state.isRolling = true;
        document.getElementById("settings-panel").classList.add("hidden");
        document.getElementById("result-display").innerText = "...";
        
        // Reset dice to high position
        spawnDice(false);
        
        state.startTime = performance.now();
      }

      // --- PHYSICS ANIMATION ---
      
      // Bounce easing function: returns 0.0 to 1.0 (where 1.0 is the bottom)
      function easeOutBounce(x) {
        const n1 = 7.5625;
        const d1 = 2.75;
        if (x < 1 / d1) { return n1 * x * x; } 
        else if (x < 2 / d1) { return n1 * (x -= 1.5 / d1) * x + 0.75; } 
        else if (x < 2.5 / d1) { return n1 * (x -= 2.25 / d1) * x + 0.9375; } 
        else { return n1 * (x -= 2.625 / d1) * x + 0.984375; }
      }

      function animate() {
        requestAnimationFrame(animate);

        if (state.isRolling) {
            const now = performance.now();
            const elapsed = now - state.startTime;
            let t = elapsed / CONFIG.animDuration;

            if (t > 1) t = 1;

            // Movement Logic
            state.dice.forEach(d => {
                // Y Position: Drop from 15 to 1.2 (radius) using Bounce
                const dropHeight = 15 - 1.2;
                const bounce = easeOutBounce(t); // 0 -> 1
                d.mesh.position.y = 15 - (dropHeight * bounce);

                // Rotation: Interpolate
                // We use a different ease for rotation so it stops exactly when the bounce settles
                const rotProgress = Math.min(1, t * 1.1); // Finish rotation slightly before complete stop
                const easeRot = 1 - Math.pow(1 - rotProgress, 3);

                d.mesh.rotation.x = THREE.MathUtils.lerp(d.startRot.x, d.endRot.x, easeRot);
                d.mesh.rotation.y = THREE.MathUtils.lerp(d.startRot.y, d.endRot.y, easeRot);
                d.mesh.rotation.z = THREE.MathUtils.lerp(d.startRot.z, d.endRot.z, easeRot);
            });

            if (t === 1) {
                finishRoll();
            }
        }

        renderer.render(scene, camera);
      }

      function finishRoll() {
        state.isRolling = false;
        const results = [];
        const up = new THREE.Vector3(0, 1, 0); // We want the face pointing UP? 
        // Actually camera is angle. Let's calculate face pointing to Camera.
        const camDir = camera.position.clone().normalize();

        state.dice.forEach(d => {
            const res = calculateResult(d.mesh, camDir);
            results.push(res);
            highlight(d.mesh, res);
        });

        const sum = results.reduce((a,b)=>a+b, 0);
        const txt = results.length > 1 ? `${results.join("+")} = ${sum}` : `${sum}`;
        document.getElementById("result-display").innerText = txt;

        // Visual FX
        if (state.diceType === "d20" && state.diceCount === 1) {
            if (sum === 20) showCrit("NAT 20", "nat20");
            if (sum === 1) showCrit("FAIL", "nat1");
        }
      }

      function calculateResult(mesh, targetDir) {
          // Find face normal most aligned with targetDir
          mesh.updateMatrixWorld();
          const normalMatrix = new THREE.Matrix3().getNormalMatrix(mesh.matrixWorld);
          const pos = mesh.geometry.attributes.position;
          const idx = mesh.geometry.index.array;
          
          let bestDot = -Infinity;
          let bestVal = 1;

          // Scan children (labels) to find position
          // Actually, let's just use the labels we added. They are positioned at face centers.
          // The label closest to the camera is the winner.
          mesh.children.forEach(child => {
             if (child.userData.isLabel) {
                 const worldPos = new THREE.Vector3();
                 child.getWorldPosition(worldPos);
                 const dist = worldPos.distanceTo(camera.position);
                 // We want the closest one
                 if (-dist > bestDot) {
                     bestDot = -dist;
                     bestVal = child.userData.val;
                 }
             }
          });
          return bestVal;
      }

      function highlight(mesh, val) {
          mesh.children.forEach(c => {
              if (c.userData.val === val) {
                  c.scale.set(1.5, 1.5, 1.5);
                  c.material.color.setHex(0x00ff00);
              }
          });
      }

      function showCrit(txt, cls) {
          const div = document.createElement("div");
          div.className = `crit-msg ${cls}`;
          div.innerText = txt;
          document.body.appendChild(div);
          setTimeout(() => div.remove(), 2500);
      }

      init();
    </script>
  </body>
</html>
